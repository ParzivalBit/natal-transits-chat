'use client';

import React, { useMemo, useState } from 'react';
import { polarToXY, describeArc, resolveCollisions } from '@/lib/graphics/polar';
import { planetChar, signChar, type PlanetName, type ZodiacSign } from '@/lib/graphics/glyphs';
import { ASPECT_COLORS } from '@/lib/graphics/tokens';
import type { SynastryAspect, ChartPoint } from '@/lib/synastry/aspects';

type HouseCusp = number;
type Axes = { asc: number; mc: number };

export type SynastryWheelProProps = {
  user:   { points: ChartPoint[]; houses?: HouseCusp[]; axes?: Axes };
  person: { points: ChartPoint[]; houses?: HouseCusp[]; axes?: Axes };
  aspects: SynastryAspect[];
  options?: {
    radii?: { zodiac: number; innerGap: number; center: number };
    showLabels?: boolean;
    minorAspects?: boolean;
    angleOffsetDeg?: number;
  };
  onHover?: (payload:
    | { type: 'planet'; owner: 'user'|'person'; name: string }
    | { type: 'aspect'; aspect: string; from: { owner:'user'|'person'; name:string }, to:{ owner:'user'|'person'; name:string } }
  ) => void;
  size?: number;
  responsive?: boolean;
  className?: string;
};

// palette
const COLOR_USER = '#1d4ed8';   // blu
const COLOR_PERSON = '#f59e0b'; // arancione
const GRID = '#e5e7eb';
const GRID_STRONG = '#9ca3af';
const TEXT = '#374151';
const FILL_BAND = 'rgba(0,0,0,0)'; // bande trasparenti (solo bordi). Cambia se vuoi un leggero fill.

const isNum = (v: unknown): v is number => typeof v === 'number' && Number.isFinite(v);
const norm = (d: number) => ((d % 360) + 360) % 360;

export default function SynastryWheelPro({
  user, person, aspects,
  options, onHover, size = 560, responsive = true, className
}: SynastryWheelProProps) {
  const r = size / 2;

  // === struttura radiale ===
  // partiamo da: fascia zodiacale (spessa), poi fascia utente, poi fascia persona, poi aspect ring
  const radiiBase = {
    zodiac: r * 0.94,     // bordo esterno dei segni (etichette)
    innerGap: r * 0.44,   // raggio ESTERNO dell'aspettogramma (bordo inferiore fascia persona)
    center: r * 0.34,     // cerchio guida interno
    ...(options?.radii ?? {}),
  };

  const thickness = {
    zodiacBand:  r * 0.06,  // spessore fascia segni
    userBand:    r * 0.10,  // spessore fascia utente
    personBand:  r * 0.10,  // spessore fascia persona
  };

  // bordi fascia segni
  const RzOuter = radiiBase.zodiac;
  const RzInner = RzOuter - thickness.zodiacBand;

  // bordi fascia persona (vincolo: bordo inferiore = innerGap)
  const RpInner = radiiBase.innerGap;
  const RpOuter = RpInner + thickness.personBand;

  // bordi fascia utente (vincoli: sup=RzInner, inf=RpOuter)
  const RuOuter = RzInner;
  const RuInner = RpOuter;

  // raggio medio per i glifi
  const RuMid = (RuOuter + RuInner) / 2;
  const RpMid = (RpOuter + RpInner) / 2;

  // assi robusti
  const axesUser: Axes | undefined = useMemo(() => {
    const a = user.axes?.asc, m = user.axes?.mc;
    if (!isNum(a) || !isNum(m)) return undefined;
    return { asc: norm(a), mc: norm(m) };
  }, [user.axes?.asc, user.axes?.mc]);

  const axesPerson: Axes | undefined = useMemo(() => {
    const a = person.axes?.asc, m = person.axes?.mc;
    if (!isNum(a) || !isNum(m)) return undefined;
    return { asc: norm(a), mc: norm(m) };
  }, [person.axes?.asc, person.axes?.mc]);

  // rotazione: ASC utente a ore 9 (270° schermo)
  const rot = useMemo(() => norm(270 - (axesUser?.asc ?? 180)), [axesUser?.asc]);
  const applyRot = (deg: number) => norm(deg + rot + (options?.angleOffsetDeg ?? 0));

  const [hover, setHover] = useState<{ key: string; kind: 'planet'|'aspect' } | null>(null);
  const setH = (v: typeof hover) => {
    setHover(v);
    if (!onHover || !v) return;
    if (v.kind === 'planet') {
      const [owner, name] = v.key.split(':') as ['user'|'person', string];
      onHover({ type: 'planet', owner, name });
    } else {
      const [a,b,asp] = v.key.split('|');
      const [owA, nmA] = a.split(':') as ['user'|'person', string];
      const [owB, nmB] = b.split(':') as ['user'|'person', string];
      onHover({ type:'aspect', aspect: asp, from:{owner:owA,name:nmA}, to:{owner:owB,name:nmB} });
    }
  };

  // posizioni pianeti (ruotate)
  const userPos = user.points.map(p => ({ ...p, ang: applyRot(p.lon) }));
  const personPos = person.points.map(p => ({ ...p, ang: applyRot(p.lon) }));

  // collision avoidance
  const userAngles = resolveCollisions(userPos.map(p => p.ang), 8);
  const personAngles = resolveCollisions(personPos.map(p => p.ang), 8);

  const cx = r, cy = r;

  // =======================================================================
  // DRAWERS
  // =======================================================================
function drawZodiac() {
  const arcs = [];
  for (let i = 0; i < 12; i++) {
    const start = applyRot(i * 30);
    const end = applyRot((i + 1) * 30);
    const mid = applyRot(i * 30 + 15);
    const path = describeArc(cx, cy, RzOuter, start, end);
    arcs.push(
      <g key={`z${i}`}>
        {/* SOLO bordo esterno segni */}
        <path d={path} stroke={GRID} strokeWidth={1.2} fill="none" />
        {/* NIENTE bordo interno qui: sarà il bordo ESTERNO fascia utente */}
        <text x={polarToXY(cx, cy, RzOuter + 8, mid).x}
              y={polarToXY(cx, cy, RzOuter + 8, mid).y}
              textAnchor="middle" dominantBaseline="middle"
              fontSize={12} fill={TEXT}>
          {signChar(([
            'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
            'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
          ][i] as ZodiacSign))}
        </text>
      </g>
    );
  }
  return <g>{arcs}</g>;
}

  // === fascia case con tacche che attraversano lo spessore ===
  function drawHouseBand(cusps: number[] | undefined, color: string, rOuter: number, rInner: number, labelsInside: boolean) {
    if (!cusps || cusps.length !== 12) return null;

    const ticks: React.ReactNode[] = [];
    const labels: React.ReactNode[] = [];

    const labelOffset = labelsInside ? -12 : 12;
    for (let i = 0; i < 12; i++) {
      const v = cusps[i];
      const next = cusps[(i + 1) % 12];
      if (!isNum(v) || !isNum(next)) continue;

      const a = applyRot(v);
      const pOut = polarToXY(cx, cy, rOuter, a);
      const pIn  = polarToXY(cx, cy, rInner, a);

      ticks.push(
        <line
          key={`tick-${color}-${i}`}
          x1={pOut.x} y1={pOut.y} x2={pIn.x} y2={pIn.y}
          stroke={color} strokeWidth={1.6} opacity={0.95}
        />
      );

      // label numero casa a metà settore sulla linea mediana della fascia
      const arc = (next - v + 360) % 360;
      const mid = applyRot(v + arc / 2);
      const rMid = (rOuter + rInner) / 2;
      const lp = polarToXY(cx, cy, rMid + labelOffset, mid);
      labels.push(
        <text
          key={`hlabel-${color}-${i}`}
          x={lp.x} y={lp.y} fontSize={10}
          fill={color} textAnchor="middle" dominantBaseline="middle"
        >
          {i + 1}
        </text>
      );
    }

    return (
      <g>
        {/* due bordi della fascia */}
        <circle cx={cx} cy={cy} r={rOuter} fill={FILL_BAND} stroke={GRID_STRONG} />
        <circle cx={cx} cy={cy} r={rInner} fill="none" stroke={GRID_STRONG} />
        {ticks}
        {labels}
      </g>
    );
  }

  function drawAxes(ax: Axes | undefined, color: string) {
    if (!ax || !isNum(ax.asc) || !isNum(ax.mc)) return null;
    const asc = applyRot(ax.asc);
    const mc  = applyRot(ax.mc);

    const pAsc = polarToXY(cx, cy, RzOuter + 10, asc);
    const pDesc = polarToXY(cx, cy, RzOuter + 10, asc + 180);
    const pMc = polarToXY(cx, cy, RzOuter + 10, mc);
    const pIc = polarToXY(cx, cy, RzOuter + 10, mc + 180);

    return (
      <g>
        <line x1={pAsc.x} y1={pAsc.y} x2={pDesc.x} y2={pDesc.y} stroke={color} strokeWidth={1.6}/>
        <line x1={pMc.x} y1={pMc.y} x2={pIc.x} y2={pIc.y} stroke={color} strokeWidth={1.6}/>
        <text x={pAsc.x} y={pAsc.y} fontSize={10} fill={color} dx={-10} dy={0}>ASC</text>
        <text x={pMc.x}  y={pMc.y}  fontSize={10} fill={color} dx={0} dy={-6}>MC</text>
      </g>
    );
  }

  function drawPlanets(
    pos: Array<ChartPoint & { ang: number }>,
    color: string,
    rMid: number,
    owner: 'user'|'person'
  ) {
    const angs = pos === userPos ? userAngles : personAngles;
    const inHoverAspect = (name: string, who: 'user'|'person') => {
      if (!hover || hover.kind !== 'aspect') return false;
      const [a, b] = hover.key.split('|');
      return a === `${who}:${name}` || b === `${who}:${name}`;
    };

    return (
      <g>
        {pos.map((p, i) => {
          const ang = angs[i];
          const pt = polarToXY(cx, cy, rMid, ang);
          const activeByPlanet = hover?.kind==='planet' && hover.key === `${owner}:${p.name}`;
          const activeByAspect = inHoverAspect(p.name as string, owner);
          const active = activeByPlanet || activeByAspect;

          return (
            <g key={`${owner}:${p.name}`}
               onMouseEnter={() => setH({ kind:'planet', key:`${owner}:${p.name}` })}
               onMouseLeave={() => setH(null)}
               style={{ cursor: 'pointer' }}>
              {active && (
                <circle cx={pt.x} cy={pt.y} r={6} fill="none" stroke={color} strokeWidth={2}/>
              )}
              <text x={pt.x} y={pt.y} fontSize={14}
                    textAnchor="middle" dominantBaseline="middle"
                    fill={color} style={{ fontWeight: active ? 600 : 400 }}>
                {planetChar(p.name as PlanetName)}
              </text>
              {p.retro && (
                <text x={pt.x+9} y={pt.y-8} fontSize={9} fill={color}>R</text>
              )}
            </g>
          );
        })}
      </g>
    );
  }

  // aspettogramma confinato nel ring centrale + hover cooperativo
  function drawAspects(lines: SynastryAspect[]) {
    const clipId = 'syn-center-clip';
    return (
      <g>
        <circle cx={cx} cy={cy} r={radiiBase.center} fill="none" stroke={GRID} />
        <circle cx={cx} cy={cy} r={radiiBase.innerGap} fill="none" stroke={GRID_STRONG} />
        <defs>
          <clipPath id={clipId}>
            <circle cx={cx} cy={cy} r={radiiBase.innerGap} />
          </clipPath>
        </defs>
        <g clipPath={`url(#${clipId})`}>
          {lines.map((a, idx) => {
            const fromAng =
              (a.a.owner === 'user'
                ? userPos.find(p => p.name === a.a.name)?.ang
                : personPos.find(p => p.name === a.a.name)?.ang) ?? null;
            const toAng =
              (a.b.owner === 'user'
                ? userPos.find(p => p.name === a.b.name)?.ang
                : personPos.find(p => p.name === a.b.name)?.ang) ?? null;
            if (fromAng == null || toAng == null) return null;

            const A = polarToXY(cx, cy, radiiBase.innerGap, fromAng);
            const B = polarToXY(cx, cy, radiiBase.innerGap, toAng);

            const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
            const c1x = (A.x + mx) / 2, c1y = (A.y + my) / 2;
            const c2x = (B.x + mx) / 2, c2y = (B.y + my) / 2;

            const color =
              a.aspect === 'trine'     ? ASPECT_COLORS.trine :
              a.aspect === 'sextile'   ? ASPECT_COLORS.sextile :
              a.aspect === 'square'    ? ASPECT_COLORS.square :
              a.aspect === 'opposition'? ASPECT_COLORS.opposition :
              ASPECT_COLORS.conjunction;

            const key = `${a.a.owner}:${a.a.name}|${a.b.owner}:${a.b.name}|${a.aspect}`;
            const active =
              (hover?.kind==='aspect' && hover.key === key) ||
              (hover?.kind==='planet' && (hover.key === `${a.a.owner}:${a.a.name}` || hover.key === `${a.b.owner}:${a.b.name}`));

            return (
              <path key={idx}
                d={`M ${A.x} ${A.y} C ${c1x} ${c1y} ${c2x} ${c2y} ${B.x} ${B.y}`}
                fill="none"
                stroke={color}
                strokeOpacity={active ? 1 : 0.7}
                strokeWidth={active ? 2.2 : 1.3}
                onMouseEnter={() => setH({ kind:'aspect', key })}
                onMouseLeave={() => setH(null)}
                style={{ cursor: 'pointer' }}
              />
            );
          })}
        </g>
      </g>
    );
  }

  return (
    <div className={className}>
      <svg viewBox={`0 0 ${size} ${size}`} className={responsive ? 'h-auto w-full' : undefined}>
        {/* base */}
        <circle cx={cx} cy={cy} r={r-1} fill="white" stroke={GRID} />

        {/* fascia segni */}
        {drawZodiac()}

        {/* fascia UTENTE: bordi + tacche (bordo sup = RzInner, bordo inf = RpOuter) */}
        {drawHouseBand(user.houses, COLOR_USER, RuOuter, RuInner, false)}

        {/* fascia PERSONA: bordi + tacche (bordo sup = RuInner, bordo inf = RpInner = aspect ring) */}
        {drawHouseBand(person.houses, COLOR_PERSON, RpOuter, RpInner, true)}

        {/* assi */}
        {drawAxes(axesUser, COLOR_USER)}
        {drawAxes(axesPerson, COLOR_PERSON)}

        {/* aspettogramma */}
        {drawAspects(aspects)}

        {/* glifi dentro le fasce (raggio mediano) */}
        {drawPlanets(userPos, COLOR_USER, RuMid, 'user')}
        {drawPlanets(personPos, COLOR_PERSON, RpMid, 'person')}

        {/* legend */}
        <g>
          <circle cx={16} cy={size-24} r={5} fill={COLOR_USER} />
          <text x={28} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>User</text>
          <circle cx={76} cy={size-24} r={5} fill={COLOR_PERSON} />
          <text x={88} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>Person</text>
        </g>
      </svg>
    </div>
  );
}