# Repository Knowledge Base (chunk 0009)


## File: src\app\dashboard\transits\page.tsx

```tsx
// src/app/dashboard/transits/page.tsx
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import dynamicImport from 'next/dynamic';
import { redirect } from 'next/navigation';

export const dynamic = 'force-dynamic';

type HouseSystem = 'placidus' | 'whole';

type ChartPoint = {
  name: string;
  longitude: number;
  sign?: string;
  house?: number | null;
  retro?: boolean;
};

type Props = {
  searchParams?: { [key: string]: string | string[] | undefined };
};

// Componenti client
const ChartWheel = dynamicImport<{
  points: ChartPoint[];
  houseCusps?: number[];
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';
  showHouseNumbers?: boolean;
  showZodiacRing?: boolean;
  size?: number;
  className?: string;
}>(() => import('@/components/ChartWheel'), { ssr: false });

const ChatUI = dynamicImport(() => import('@/components/ChatUI'), { ssr: false });
const HouseSystemSwitcher = dynamicImport(() => import('@/components/HouseSystemSwitcher'), { ssr: false });

// Pianeti di transito (runtime) â€” usa la tua API
import { computePlanetsAtUTC, type RuntimePoint } from '@/lib/planets/runtime';

// ----------------- util locali

function has12(arr: unknown[] | null | undefined): arr is number[] {
  return !!arr && arr.length === 12 && arr.every(v => Number.isFinite(Number(v)));
}

function zodiacSignFromLon(lon: number): string {
  const signs = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  const idx = Math.floor((((lon % 360) + 360) % 360) / 30);
  return signs[idx];
}

// aspetto (maggiore) piÃ¹ vicino e distanza in gradi
function nearestMajorAspectDelta(d: number): { aspect: number | null; delta: number } {
  const majors = [0, 60, 90, 120, 180];
  let best: number | null = null;
  let min = 999;
  for (const a of majors) {
    const diff = Math.abs(((d - a + 540) % 360) - 180);
    if (diff < min) { min = diff; best = a; }
  }
  return { aspect: best, delta: min };
}

// punteggio semplice: piÃ¹ Ã¨ stretto lâ€™orbe, piÃ¹ alto
function scoreAspect(planet: string, aspect: number | null, orb: number): number {
  if (aspect === null) return 0;
  const baseOrb =
    planet === 'Sun' || planet === 'Moon' ? 6 :
    planet === 'Mercury' || planet === 'Venus' ? 4 :
    planet === 'Mars' ? 4 :
    3.5;
  const maxOrb =
    aspect === 0 ? baseOrb + 1.0 :
    aspect === 180 ? baseOrb + 0.5 :
    baseOrb;
  const v = Math.max(0, maxOrb - orb);
  const w =
    aspect === 0 ? 1.05 :
    aspect === 180 ? 1.02 :
    aspect === 120 ? 1.00 :
    aspect === 90 ? 0.98 :
    aspect === 60 ? 0.95 : 0.9;
  return v * w;
}

export default async function Page({ searchParams }: Props) {
  const supabase = createSupabaseServerComponentClient();
  const auth = await supabase.auth.getUser();
  const userId = auth.data.user?.id ?? null;
  if (!userId) redirect('/onboarding');

  // 1) Data selezionata (default: oggi UTC)
  const dParam = typeof searchParams?.d === 'string' ? searchParams!.d : undefined;
  const today = new Date();
  const yyyy = today.getUTCFullYear();
  const mm = String(today.getUTCMonth() + 1).padStart(2, '0');
  const dd = String(today.getUTCDate()).padStart(2, '0');
  const dateUTC = dParam ?? `${yyyy}-${mm}-${dd}`;            // "YYYY-MM-DD"
  const dateObjUTC = new Date(`${dateUTC}T00:00:00Z`);        // mezzanotte UTC

  // 2) Sistema case preferito
  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', userId)
    .maybeSingle();

  const system: HouseSystem = prefs?.house_system === 'placidus' ? 'placidus' : 'whole';

  // 3) Cuspidi natalizie (schema verticale)
  const { data: cuspsRows } = await supabase
    .from('house_cusps')
    .select('cusp, longitude')
    .eq('user_id', userId)
    .eq('system', system)
    .order('cusp', { ascending: true });

  const houseCusps = Array.isArray(cuspsRows) && cuspsRows.length === 12
    ? cuspsRows.map(r => Number(r.longitude))
    : undefined;

  const mcDeg = has12(houseCusps) ? houseCusps[9] : undefined;

  // 4) Punti natali (per aspetto con transiti)
  const { data: natalRows } = await supabase
    .from('chart_points')
    .select('name, longitude')
    .eq('user_id', userId)
    .order('name', { ascending: true });

  const natalPoints: ChartPoint[] = Array.isArray(natalRows)
    ? natalRows.map(r => ({ name: r.name, longitude: Number(r.longitude) }))
    : [];

  // 5) Pianeti di transito (runtime) per la data selezionata
  const transitRaw: RuntimePoint[] = computePlanetsAtUTC(dateObjUTC);
  const transitPoints: ChartPoint[] = transitRaw.map((p) => ({
    name: p.name,
    longitude: Number(p.longitude),
    retro: !!p.retro,
    sign: zodiacSignFromLon(Number(p.longitude)),
    house: null,
  }));

  // 6) Top 3 transiti del giorno
  type TransitHit = { planet: string; target: string; aspect: number; orb: number; score: number };
  const hits: TransitHit[] = [];
  for (const tp of transitPoints) {
    for (const np of natalPoints) {
      const d = Math.abs(((tp.longitude - np.longitude + 540) % 360) - 180);
      const { aspect, delta } = nearestMajorAspectDelta(d);
      const score = scoreAspect(String(tp.name), aspect, delta);
      if (score > 0.5 && aspect !== null) {
        hits.push({
          planet: String(tp.name),
          target: String(np.name),
          aspect,
          orb: Number(delta),
          score,
        });
      }
    }
  }
  hits.sort((a, b) => b.score - a.score);
  const top3 = hits.slice(0, 3);

  return (
    <div className="grid lg:grid-cols-2 gap-6">
      {/* Colonna sinistra */}
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-semibold">Transits</h2>
          <HouseSystemSwitcher current={system} />
        </div>

        {/* Date picker */}
        <form className="mb-4" action="/dashboard/transits" method="get">
          <label className="text-xs text-gray-600 mr-2">Date (UTC):</label>
          <input
            type="date"
            name="d"
            defaultValue={dateUTC}
            className="border rounded-md px-2 py-1 text-sm"
          />
          <button
            type="submit"
            className="ml-2 px-3 py-1 text-sm rounded-md border bg-white hover:bg-gray-50"
          >
            Go
          </button>
        </form>

        {/* Ruota: transiti + case natalizie utente */}
        <div className="mb-4">
          <ChartWheel
            key={`${system}-${(houseCusps?.[0] ?? 0).toFixed(3)}-${dateUTC}`}
            points={transitPoints}
            houseCusps={houseCusps}
            mcDeg={mcDeg}
            orientation="by-asc"
            showZodiacRing
            showHouseNumbers
            size={460}
          />
        </div>

        {/* Top 3 transiti */}
        <div>
          <h3 className="text-sm font-semibold mb-2">Top transits for {dateUTC}</h3>
          {top3.length === 0 ? (
            <p className="text-sm text-gray-600">Nessun aspetto rilevante nei range di orb impostati.</p>
          ) : (
            <ul className="text-sm space-y-1">
              {top3.map((t, i) => (
                <li key={i} className="flex items-center justify-between">
                  <span>
                    <span className="font-medium">{t.planet}</span>{' '}
                    {t.aspect === 0 && 'conj.'}
                    {t.aspect === 60 && 'sext.'}
                    {t.aspect === 90 && 'sq.'}
                    {t.aspect === 120 && 'trine'}
                    {t.aspect === 180 && 'opp.'}{' '}
                    <span className="font-medium">{t.target}</span>
                  </span>
                  <span className="text-xs text-gray-500">orb {t.orb.toFixed(2)}Â°</span>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>

      {/* Colonna destra: Chat */}
      <div className="rounded-2xl border p-4 min-h-[480px]">
        <h2 className="text-lg font-semibold mb-3">Ask about today</h2>
        <ChatUI />
      </div>
    </div>
  );
}

```


## File: src\app\globals.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;


html, body {
height: 100%;
}
```


## File: src\app\lab\daily-pro\action.ts

```ts
// FILE: src/app/lab/daily-pro/action.ts
"use server";

import { createSupabaseServerComponentClient } from "../../../lib/supabaseServer";
import type { DailyData } from "./loadData";

// Mappa dai codici interni (conj, sq, tri, opp, sext) ai valori DB
const DB_ASPECTS: Record<string, string> = {
  conj: "conjunction",
  sext: "sextile",
  sq: "square",
  tri: "trine",
  opp: "opposition",
};

export async function upsertTransitDay(
  payload: Pick<DailyData, "transitingAspects" | "dateISO">
) {
  const sb = createSupabaseServerComponentClient();

  const {
    data: { user },
    error: uerr,
  } = await sb.auth.getUser();
  if (uerr || !user) throw new Error("Not authenticated");

  // Cancella record giÃ  presenti per la data
  const del = await sb
    .from("transit_events")
    .delete()
    .eq("user_id", user.id)
    .eq("date", payload.dateISO);
  if (del.error) throw new Error(del.error.message);

  if (!payload.transitingAspects?.length) {
    return { ok: true, inserted: 0 };
  }

  const rows = payload.transitingAspects.map((a) => {
    const aspectKey = DB_ASPECTS[a.aspect] ?? "conjunction"; // fallback safe
    return {
      user_id: user.id,
      date: payload.dateISO,
      t_planet: a.t,
      n_point: a.n,
      aspect: aspectKey,
      orb: a.orb,
      score: Math.max(1, Math.round(100 - a.orb * 10)),
    };
  });

  const ins = await sb.from("transit_events").insert(rows);
  if (ins.error) throw new Error(ins.error.message);

  return { ok: true, inserted: rows.length };
}

```


## File: src\app\lab\daily-pro\ClientDailyPro.tsx

```tsx
// FILE: src/app/lab/daily-pro/ClientDailyPro.tsx
"use client";

import React, { useState } from "react";
import DailySkyWheelPro, {
  type ProPoint,
  type AspectType,
} from "@/components/astro/DailySkyWheelPro";

function Controls({
  enabledAspects,
  setEnabledAspects,
  orbOffsetDeg,
  setOrbOffsetDeg,
}: {
  enabledAspects: Record<AspectType, boolean>;
  setEnabledAspects: (val: Record<AspectType, boolean>) => void;
  orbOffsetDeg: number;
  setOrbOffsetDeg: (v: number) => void;
}) {
  const toggle = (k: AspectType) =>
    setEnabledAspects({ ...enabledAspects, [k]: !enabledAspects[k] });

  return (
    <div className="mb-4 grid gap-3 rounded-xl border border-gray-200 bg-white p-4 text-sm shadow-sm">
      <div className="font-medium text-gray-800">Impostazioni aspetti</div>

      <div className="grid grid-cols-2 gap-2 sm:grid-cols-5">
        {(["conjunction", "sextile", "square", "trine", "opposition"] as AspectType[]).map(
          (t) => (
            <label key={t} className="inline-flex items-center gap-2">
              <input
                type="checkbox"
                className="h-4 w-4 accent-gray-900"
                checked={enabledAspects[t]}
                onChange={() => toggle(t)}
              />
              <span className="capitalize">{t}</span>
            </label>
          )
        )}
      </div>

      <div className="mt-2">
        <label htmlFor="orb" className="mb-1 block text-gray-700">
          Orb globale (Â± gradi):{" "}
          <span className="font-semibold">
            {orbOffsetDeg >= 0 ? `+${orbOffsetDeg}` : orbOffsetDeg}Â°
          </span>
        </label>
        <input
          id="orb"
          type="range"
          min={-4}
          max={6}
          step={1}
          value={orbOffsetDeg}
          onChange={(e) => setOrbOffsetDeg(Number(e.target.value))}
          className="w-full"
        />
        <p className="mt-1 text-xs text-gray-500">
          Applica un offset agli orbi base (conj 8Â°, sext 4Â°, sq 6Â°, tr 6Â°, opp 8Â°).
        </p>
      </div>
    </div>
  );
}

export default function ClientDailyPro({ today }: { today: ProPoint[] }) {
  const [enabledAspects, setEnabledAspects] = useState<Record<AspectType, boolean>>({
    conjunction: true,
    sextile: true,
    square: true,
    trine: true,
    opposition: true,
  });
  const [orbOffsetDeg, setOrbOffsetDeg] = useState<number>(0);

  return (
    <div className="mx-auto max-w-5xl px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-2xl font-semibold tracking-tight">Daily Sky â€” Pro</h1>
        <p className="text-sm text-gray-500">
          Cielo del giorno: pianeti in transito e aspetti (toggle + orb come in transits-pro).
        </p>
      </div>

      {/* Controls */}
      <Controls
        enabledAspects={enabledAspects}
        setEnabledAspects={setEnabledAspects}
        orbOffsetDeg={orbOffsetDeg}
        setOrbOffsetDeg={setOrbOffsetDeg}
      />

      {/* Wheel */}
      <div className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
        <div className="aspect-square w-full max-w-[720px] mx-auto">
          <DailySkyWheelPro
            today={today}
            enabledAspects={enabledAspects}
            orbOffsetDeg={orbOffsetDeg}
            responsive
          />
        </div>
      </div>
    </div>
  );
}

```


## File: src\app\lab\daily-pro\loadData.ts

```ts
// FILE: src/app/lab/daily-pro/loadData.ts
import {
  ASPECTS,
  acuteDelta,
  closestAspectDelta,
  maxOrbForPair,
  PointName,
  Point,
} from "../../../lib/aspects";
import { createSupabaseServerComponentClient } from "../../../lib/supabaseServer";
import { computePlanetsAtUTC } from "../../../lib/planets/runtime";

export type HouseSystem = "whole" | "placidus";

export type DailyData = {
  houseSystem: HouseSystem;
  natalPoints: Point[];
  natalCusps: number[];
  todayPoints: Point[];
  todayCusps: number[];
  transitingAspects: Array<{
    t: PointName;
    n: PointName;
    aspect: keyof typeof ASPECTS;
    orb: number;
  }>;
  dateISO: string;
};

export async function loadDaily(): Promise<DailyData> {
  const sb = createSupabaseServerComponentClient();

  // Auth
  const {
    data: { user },
    error: uerr,
  } = await sb.auth.getUser();
  if (uerr || !user) throw new Error("Not authenticated");

  // Preferenze
  const { data: prefs, error: perr } = await sb
    .from("user_prefs")
    .select("house_system, current_lat, current_lon")
    .eq("user_id", user.id)
    .single();
  if (perr) throw new Error(perr.message);

  const houseSystem: HouseSystem = (prefs?.house_system as HouseSystem) || "whole";

  // Punti natali
  const { data: natalPoints, error: nperr } = await sb
    .from("chart_points")
    .select("name, longitude, retro")
    .eq("user_id", user.id);
  if (nperr) throw new Error(nperr.message);

  // Case natali
  const { data: cuspsRow } = await sb
    .from("house_cusps")
    .select("c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12")
    .eq("user_id", user.id)
    .eq("house_system", houseSystem)
    .maybeSingle();

  const natalCusps: number[] = cuspsRow
    ? [
        cuspsRow.c1,
        cuspsRow.c2,
        cuspsRow.c3,
        cuspsRow.c4,
        cuspsRow.c5,
        cuspsRow.c6,
        cuspsRow.c7,
        cuspsRow.c8,
        cuspsRow.c9,
        cuspsRow.c10,
        cuspsRow.c11,
        cuspsRow.c12,
      ]
    : [];

  // Data corrente
  const now = new Date();
  const dateISO = now.toISOString().slice(0, 10);

  // Pianeti runtime
  const todayPoints = computePlanetsAtUTC(now).map((p) => ({
    name: p.name,
    longitude: p.longitude,
    retro: p.retro,
  })) as Point[];

  // Fallback: todayCusps = natalCusps (fino a che non colleghiamo calcolo runtime case)
  const todayCusps = natalCusps;

  // Aspetti transiting â†’ natal
  const aspectList: DailyData["transitingAspects"] = [];
  for (const t of todayPoints) {
    const tn = t.name as PointName;
    if (
      ![
        "Sun",
        "Moon",
        "Mercury",
        "Venus",
        "Mars",
        "Jupiter",
        "Saturn",
        "Uranus",
        "Neptune",
        "Pluto",
      ].includes(tn)
    )
      continue;

    for (const n of (natalPoints as unknown as Point[]) ?? []) {
      const nn = n.name as PointName;
      const delta = acuteDelta(t.longitude, n.longitude);
      const hit = closestAspectDelta(delta);
      const max = maxOrbForPair(tn, nn, hit.aspect.key);
      if (hit.orb <= max) {
        aspectList.push({
          t: tn,
          n: nn,
          aspect: hit.aspect.key,
          orb: +hit.orb.toFixed(2),
        });
      }
    }
  }

  return {
    houseSystem,
    natalPoints: (natalPoints as unknown as Point[]) ?? [],
    natalCusps,
    todayPoints,
    todayCusps,
    transitingAspects: aspectList,
    dateISO,
  };
}

```


## File: src\app\lab\daily-pro\page.tsx

```tsx
// FILE: src/app/lab/daily-pro/page.tsx
import { Suspense } from "react";
import ClientDailyPro from "./ClientDailyPro";
import { computeDailyPlanets } from "@/lib/planets/runtime";

// ---------------------------
// Tipi locali
// ---------------------------

type RuntimePlanet = {
  name: string;
  longitude: number;
  retro?: boolean;
  sign?: string | null;
};

export type ProPoint = {
  id: string;
  name: string;
  lon: number;
  retro?: boolean;
  sign?: string | null;
};

export const revalidate = 60;

// ---------------------------
// Data loader (server)
// ---------------------------

async function loadDailyData() {
  const nowUTC = new Date();
  const todayRaw: RuntimePlanet[] = await computeDailyPlanets(nowUTC);
  const today: ProPoint[] = todayRaw.map((p) => ({
    id: p.name,
    name: p.name,
    lon: p.longitude,
    retro: !!p.retro,
    sign: p.sign ?? null,
  }));
  return { today };
}

// ---------------------------
// Page (Server Component)
// ---------------------------

export default async function Page() {
  const { today } = await loadDailyData();
  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamento Daily Skyâ€¦</div>}>
      <ClientDailyPro today={today} />
    </Suspense>
  );
}

```


## File: src\app\lab\daily-pro\sbServer.ts

```ts

```


## File: src\app\lab\natal-pro\page.tsx

```tsx
// src/app/lab/natal-pro/page.tsx
import nextDynamic from 'next/dynamic';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import { redirect } from 'next/navigation';
import { computeHouses } from '@/lib/astro';

const ChartWheelPro = nextDynamic(() => import('@/components/astro/ChartWheelPro'), { ssr: false });

export const dynamic = 'force-dynamic';

type HouseSystem = 'placidus' | 'whole';
interface ChartPoint {
  name: string;
  longitude: number;
  sign: string;
  house: number | null;
  retro: boolean;
}

export default async function Page() {
  const supabase = createSupabaseServerComponentClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) redirect('/onboarding');

  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', user.id)
    .maybeSingle();

  const system: HouseSystem = prefs?.house_system === 'placidus' ? 'placidus' : 'whole';

  const { data: cuspsRows } = await supabase
    .from('house_cusps')
    .select('cusp, longitude')
    .eq('user_id', user.id)
    .eq('system', system)
    .order('cusp');

  let cusps: number[] | null =
    Array.isArray(cuspsRows) && cuspsRows.length === 12 ? cuspsRows.map(r => Number(r.longitude)) : null;

  //let mc: number | undefined;

  if (!cusps) {
    const { data: bd } = await supabase
      .from('birth_data')
      .select('date,time,tz_offset_minutes,lat,lon')
      .eq('user_id', user.id)
      .maybeSingle();

    if (bd?.date && bd.time && bd.lat != null && bd.lon != null) {
      const [hh, mm] = String(bd.time).slice(0, 5).split(':').map(Number);
      const local = new Date(`${bd.date}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00Z`);
      const tzOff = Number(bd.tz_offset_minutes ?? 0);
      const jdUT = local.getTime() / 86400000 + 2440587.5 - tzOff/1440;

      const pkt = computeHouses(system, {
        jd: jdUT,
        latDeg: Number(bd.lat),
        lonDeg: Number(bd.lon),
        tzMinutes: tzOff,
      });

      cusps = pkt.cusps;
      //mc = pkt.mc;
    }
  }

  const { data: pointsRaw } = await supabase
    .from('chart_points')
    .select('name,longitude,sign,house,retro')
    .eq('user_id', user.id)
    .order('name');

  const points: ChartPoint[] = Array.isArray(pointsRaw)
    ? pointsRaw.map((p: unknown) => {
        const obj = p as { name: string; longitude: number; sign: string | null; house: number | null; retro: boolean | null };
        return {
          name: String(obj.name),
          longitude: Number(obj.longitude),
          sign: String(obj.sign ?? ''),
          house: obj.house ?? null,
          retro: Boolean(obj.retro),
        };
      })
    : [];

  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">Lab Â· Natal Pro</h1>
      <ChartWheelPro
        title={`Natal (system: ${system})`}
        points={points}
        houseCusps={cusps ?? undefined}
      />
    </div>
  );
}

```


## File: src\app\lab\people-pro\[id]\ChatSynastryPane.tsx

```tsx
// FILE: src/app/lab/people/[id]/ChatSynastryPane.tsx
"use client";

import React, { useState } from "react";

export type SynastryContext = {
  user: {
    id: string;
    houseSystem: "placidus" | "whole";
    houses?: number[];
    points: { name: string; lon: number; retro?: boolean }[];
    axes?: { AC: number; IC: number; DC: number; MC: number };
  };
  person: {
    id: string;
    name?: string | null;
    houseSystem: "placidus" | "whole";
    houses?: number[];
    points: { name: string; lon: number; retro?: boolean }[];
    axes?: { AC: number; IC: number; DC: number; MC: number };
  };
  aspects: {
    a: { who: "user" | "person"; name: string; lon: number };
    b: { who: "user" | "person"; name: string; lon: number };
    type: "conjunction" | "sextile" | "square" | "trine" | "opposition";
    delta: number; exact: number; strength: number;
  }[];
};

export default function ChatSynastryPane({ context }: { context: SynastryContext }) {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Array<{ role: "user" | "assistant"; content: string }>>([
    { role: "assistant", content: "Ciao! Fammi una domanda sulla sinastria; ho giÃ  il contesto calcolato." },
  ]);

  const onSend = async () => {
    if (!input.trim()) return;
    setMessages((m) => [...m, { role: "user", content: input }]);
    // Stub: integra qui il tuo endpoint chat (POST /api/chat) passando { messages, context }
    setMessages((m) => [...m, { role: "assistant", content: "Ricevuto! UserÃ² il contesto di sinastria per risponderti." }]);
    setInput("");
  };

  return (
    <div className="flex h-full flex-col gap-3">
      <div className="rounded-lg border border-gray-200 bg-white p-3 shadow-sm">
        <div className="mb-2 text-sm font-medium">Chat Sinastria</div>
        <div className="h-64 overflow-auto rounded-md border p-2 text-sm">
          {messages.map((m, i) => (
            <div key={i} className={`mb-2 ${m.role === "user" ? "text-gray-900" : "text-sky-700"}`}>
              <strong>{m.role === "user" ? "Tu" : "Assistente"}:</strong> {m.content}
            </div>
          ))}
        </div>
        <div className="mt-2 flex gap-2">
          <input
            className="flex-1 rounded-md border px-2 py-1 text-sm"
            placeholder="Scriviâ€¦"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => (e.key === "Enter" ? onSend() : undefined)}
          />
          <button className="rounded-md bg-gray-900 px-3 py-1 text-sm text-white" onClick={onSend}>
            Invia
          </button>
        </div>
      </div>

      <details className="rounded-lg border border-gray-200 bg-white p-3 text-xs shadow-sm">
        <summary className="cursor-pointer select-none font-medium">Vedi SynastryContext (debug)</summary>
        <pre className="mt-2 max-h-72 overflow-auto">{JSON.stringify(context, null, 2)}</pre>
      </details>
    </div>
  );
}

```


## File: src\app\lab\people-pro\[id]\page.tsx

```tsx
// src/app/lab/people-pro/[id]/page.tsx
import React from 'react';
import { headers } from 'next/headers';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';

import SynastryWheelPro from '@/components/astro/SynastryWheelPro';
import PeoplePanel from '@/components/PeoplePanel';
import ChatSynastryPane from './ChatSynastryPane';

import type {
  ChartPoint,            // tipi usati dalla ruota
  SynastryAspect,
  AspectName,
} from '@/lib/synastry/aspects';
import type { SynastryContext } from './ChatSynastryPane';

// --------------------------------------------------
// UtilitÃ 
// --------------------------------------------------
type HouseSystem = 'placidus' | 'whole';
type Axes = { asc: number; mc: number };

type RawPointRow = { name: string; longitude: number; retro?: boolean | null };

type ApiAspect = {
  a: { who: 'user' | 'person'; name: ChartPoint['name'] | string; lon: number };
  b: { who: 'user' | 'person'; name: ChartPoint['name'] | string; lon: number };
  type: AspectName | 'quincunx' | 'semi-sextile';
  exact?: number;
  delta?: number;
  strength?: number;
};

type ChatMajorAspect = {
  a: { who: 'user' | 'person'; name: string; lon: number };
  b: { who: 'user' | 'person'; name: string; lon: number };
  type: 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile';
  delta: number;
  exact: number;
  strength: number;
};

//type CuspRow = {
  //cusp?: number | null;   // alcuni schema usano "cusp"
  //house?: number | null;  // altri "house"
  //longitude: number | null;
  //system?: string | null;
//};


const MAJOR_TYPES = new Set<ChatMajorAspect['type']>([
  'conjunction',
  'opposition',
  'trine',
  'square',
  'sextile',
]);

const norm360 = (d: number) => ((Number(d) % 360) + 360) % 360;

const ALLOWED_NAMES = new Set<string>([
  'Sun',
  'Moon',
  'Mercury',
  'Venus',
  'Mars',
  'Jupiter',
  'Saturn',
  'Uranus',
  'Neptune',
  'Pluto',
  'ASC',
  'MC',
]);

function toChartPoints(rows: RawPointRow[]): ChartPoint[] {
  return (rows ?? [])
    .filter((r) => Number.isFinite(Number(r.longitude)))
    .filter((r) => ALLOWED_NAMES.has(String(r.name)))
    .map(
      (r): ChartPoint => ({
        name: r.name as ChartPoint['name'],
        lon: norm360(Number(r.longitude)),
        retro: !!r.retro,
      }),
    );
}

function toAxes(points: ChartPoint[]): Axes | undefined {
  const asc = points.find((p) => p.name === 'ASC')?.lon;
  const mc = points.find((p) => p.name === 'MC')?.lon;
  return asc != null && mc != null ? { asc, mc } : undefined;
}

// Adattatori aspetti
function toWheelAspects(api: ApiAspect[]): SynastryAspect[] {
  return api.map((a) => ({
    a: { owner: a.a.who, name: a.a.name as ChartPoint['name'], lon: a.a.lon },
    b: { owner: a.b.who, name: a.b.name as ChartPoint['name'], lon: a.b.lon },
    aspect: a.type as SynastryAspect['aspect'],
    orb: Math.abs(a.exact ?? a.delta ?? 0),
    applying: (a.delta ?? 0) < 0,
    score: a.strength ?? 0,
    exact: a.exact ?? Math.abs(a.delta ?? 0),
  }));
}

function toChatMajorAspects(api: ApiAspect[]): ChatMajorAspect[] {
  return api
    .filter((a) => MAJOR_TYPES.has(a.type as ChatMajorAspect['type']))
    .map((a) => ({
      a: { who: a.a.who, name: String(a.a.name), lon: a.a.lon },
      b: { who: a.b.who, name: String(a.b.name), lon: a.b.lon },
      type: a.type as ChatMajorAspect['type'],
      exact: Math.abs(a.exact ?? a.delta ?? 0),
      delta: Number(a.delta ?? 0),
      strength: Number(a.strength ?? 0),
    }));
}

// --------------------------------------------------
// Data load
// --------------------------------------------------
async function getHouseSystem(): Promise<HouseSystem> {
  const sb = createSupabaseServerComponentClient();
  const { data: { user } } = await sb.auth.getUser();
  if (!user) return 'placidus';
  const { data } = await sb
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', user.id)
    .maybeSingle();
  const sys = (data?.house_system ?? 'placidus') as HouseSystem;
  return sys === 'whole' || sys === 'placidus' ? sys : 'placidus';
}

async function getUserChart(houseSystem: HouseSystem): Promise<{
  points: ChartPoint[];
  houses?: number[];
  axes?: Axes;
}> {
  const sb = createSupabaseServerComponentClient();

  const { data: { user } } = await sb.auth.getUser();
  if (!user) return { points: [] };

  // punti utente
  type DbPointRow = { name: string; longitude: number | null; retro?: boolean | null };
  const { data: pts } = await sb
    .from('chart_points')
    .select('name, longitude, retro')
    .eq('user_id', user.id);

  const points = toChartPoints(
    (pts ?? []).map((r: DbPointRow): RawPointRow => ({
      name: String(r.name),
      longitude: Number(r.longitude ?? NaN),
      retro: !!r.retro,
    })),
  );

  // cuspidi utente: prova system esatto -> fallback senza filtro
  type CuspRow = { cusp?: number | null; house?: number | null; longitude: number | null; system?: string | null };

  const { data: cuspsExact } = await sb
    .from('house_cusps')
    .select('cusp, house, longitude, system')
    .eq('user_id', user.id)
    .eq('system', houseSystem)
    .order('cusp', { ascending: true });

  let cusps = (cuspsExact as CuspRow[] | null) ?? null;

  if (!cusps || cusps.length < 12) {
    const { data: cuspsAny } = await sb
      .from('house_cusps')
      .select('cusp, house, longitude, system')
      .eq('user_id', user.id)
      .order('cusp', { ascending: true });
    cusps = (cuspsAny as CuspRow[] | null) ?? null;
  }

  const orderedCusps = (cusps ?? [])
    .map((row: CuspRow): { idx: number; lon: number } => {
      const idx = row.cusp ?? row.house ?? NaN;
      const lon = row.longitude ?? NaN;
      return { idx: Number(idx), lon: Number(lon) };
    })
    .filter((x) => Number.isFinite(x.idx) && Number.isFinite(x.lon))
    .sort((a, b) => a.idx - b.idx);

  const houses = orderedCusps.length === 12 ? orderedCusps.map((c) => norm360(c.lon)) : undefined;

  return { points, houses, axes: toAxes(points) };
}


async function getPersonChart(personId: string, houseSystem: HouseSystem): Promise<{
  label?: string | null;
  points: ChartPoint[];
  houses?: number[];
  axes?: Axes;
}> {
  const sb = createSupabaseServerComponentClient();

  const { data: person } = await sb
    .from('people')
    .select('id,label')
    .eq('id', personId)
    .maybeSingle();

  // punti persona
  type DbPointRow = { name: string; longitude: number | null; retro?: boolean | null };
  const { data: pts } = await sb
    .from('people_chart_points')
    .select('name, longitude, retro')
    .eq('person_id', personId);

  const points = toChartPoints(
    (pts ?? []).map((r: DbPointRow): RawPointRow => ({
      name: String(r.name),
      longitude: Number(r.longitude ?? NaN),
      retro: !!r.retro,
    })),
  );

  // cuspidi persona: system esatto -> fallback senza filtro
  type CuspRow = { cusp?: number | null; house?: number | null; longitude: number | null; system?: string | null };

  const { data: cuspsExact } = await sb
    .from('people_house_cusps')
    .select('cusp, house, longitude, system')
    .eq('person_id', personId)
    .eq('system', houseSystem)
    .order('cusp', { ascending: true });

  let cusps = (cuspsExact as CuspRow[] | null) ?? null;

  if (!cusps || cusps.length < 12) {
    const { data: cuspsAny } = await sb
      .from('people_house_cusps')
      .select('cusp, house, longitude, system')
      .eq('person_id', personId)
      .order('cusp', { ascending: true });
    cusps = (cuspsAny as CuspRow[] | null) ?? null;
  }

  const orderedCusps = (cusps ?? [])
    .map((row: CuspRow): { idx: number; lon: number } => {
      const idx = row.cusp ?? row.house ?? NaN;
      const lon = row.longitude ?? NaN;
      return { idx: Number(idx), lon: Number(lon) };
    })
    .filter((x) => Number.isFinite(x.idx) && Number.isFinite(x.lon))
    .sort((a, b) => a.idx - b.idx);

  const houses = orderedCusps.length === 12 ? orderedCusps.map((c) => norm360(c.lon)) : undefined;

  return { label: person?.label ?? null, points, houses, axes: toAxes(points) };
}

async function getApiAspects(personId: string): Promise<ApiAspect[]> {
  // Costruisci URL assoluto dagli header della richiesta corrente
  const h = headers();
  const host = h.get('x-forwarded-host') ?? h.get('host') ?? 'localhost:3000';
  const proto = h.get('x-forwarded-proto') ?? (host.startsWith('localhost') ? 'http' : 'https');
  const url = `${proto}://${host}/api/synastry/compute`;

  // ðŸ”‘ Inoltra la raw cookie header del client alla route API
  const cookieHeader = h.get('cookie') ?? '';

  const res = await fetch(url, {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      ...(cookieHeader ? { cookie: cookieHeader } : {}), // <- questo Ã¨ quello che serve a Supabase
    },
    body: JSON.stringify({ person_id: personId }),
    cache: 'no-store',
  });

  if (!res.ok) return [];
  const json = (await res.json().catch(() => null)) as { aspects?: ApiAspect[] } | null;
  return Array.isArray(json?.aspects) ? (json!.aspects as ApiAspect[]) : [];
}


// --------------------------------------------------
// Page
// --------------------------------------------------
export default async function Page({ params }: { params: { id: string } }) {
  const personId = params.id;
  const houseSystem = await getHouseSystem();

  const [{ points: uPts, houses: uHouses, axes: uAxes }, person, apiAspects] =
    await Promise.all([
      getUserChart(houseSystem),
      getPersonChart(personId, houseSystem),
      getApiAspects(personId),
    ]);

  const wheelAspects: SynastryAspect[] = toWheelAspects(apiAspects);
  const chatAspects: ChatMajorAspect[] = toChatMajorAspects(apiAspects);

  const hasUser = uPts.length > 0;
  const hasPerson = person.points.length > 0;

  // Contesto per la chat (solo major)
  const chatContext: SynastryContext = {
    user: {
      id: 'me',
      houseSystem,
      houses: uHouses,
      points: uPts.map((p) => ({ name: p.name, lon: p.lon, retro: p.retro })),
      axes: uAxes
        ? {
            AC: uAxes.asc,
            DC: norm360(uAxes.asc + 180),
            MC: uAxes.mc,
            IC: norm360(uAxes.mc + 180),
          }
        : undefined,
    },
    person: {
      id: personId,
      name: person.label ?? null,
      houseSystem,
      houses: person.houses,
      points: person.points.map((p) => ({
        name: p.name,
        lon: p.lon,
        retro: p.retro,
      })),
      axes: person.axes
        ? {
            AC: person.axes.asc,
            DC: norm360(person.axes.asc + 180),
            MC: person.axes.mc,
            IC: norm360(person.axes.mc + 180),
          }
        : undefined,
    },
    aspects: chatAspects,
  };

  return (
    <section className="grid grid-cols-1 lg:grid-cols-12 gap-6 p-4">
      <div className="lg:col-span-8 rounded border p-4 bg-white">
        <div className="flex items-center justify-between mb-3">
          <h2 className="font-semibold">
            Sinastria {person.label ? `â€” ${person.label}` : ''}
          </h2>
          <details className="text-sm">
            <summary className="cursor-pointer select-none">Modifica persona</summary>
            <div className="mt-3">
              <PeoplePanel
                houseSystem={houseSystem}
                defaultPerson={{ id: personId, label: person.label ?? '' }}
              />
            </div>
          </details>
        </div>

        {!(hasUser && hasPerson) ? (
          <div className="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded p-3">
            Dati insufficienti per renderizzare la sinastria.
            <ul className="list-disc ml-5 mt-2">
              {!hasUser && <li>Mancano i punti del tema utente.</li>}
              {!hasPerson && <li>Mancano i punti del tema della persona.</li>}
            </ul>
          </div>
        ) : (
          <SynastryWheelPro
            user={{ points: uPts, houses: uHouses ?? [], axes: uAxes }}
            person={{
              points: person.points,
              houses: person.houses ?? [],
              axes: person.axes,
            }}
            aspects={wheelAspects}
            options={{
              showLabels: true,
              minorAspects: true,
            }}
          />
        )}
      </div>

      <div className="lg:col-span-4 rounded border p-4 bg-white">
        <h3 className="font-semibold mb-3">Chat Sinastria</h3>
        <ChatSynastryPane context={chatContext} />
      </div>
    </section>
  );
}

```


## File: src\app\lab\people-pro\page.tsx

```tsx
// FILE: src/app/lab/people-pro/page.tsx
import { Suspense } from "react";
import PeoplePanel from "@/components/PeoplePanel";
import PeopleList from "@/components/PeopleList";

export const revalidate = 60;

/**
 * Pagina "people-pro" (elenco + form).
 * - Colonna sinistra: form creazione/modifica persona (PeoplePanel)
 * - Colonna destra: lista persone (PeopleList)
 * Alla submit -> redirect automatico a /lab/people/[id]
 * Al click su card -> navigazione a /lab/people/[id]
 */
export default async function Page() {
  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamentoâ€¦</div>}>
      <div className="mx-auto max-w-6xl px-4 py-8 grid gap-6 md:grid-cols-[1.2fr,1fr]">
        <section className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
          <h1 className="mb-3 text-xl font-semibold">Aggiungi/Modifica Persona</h1>
          <PeoplePanel />
        </section>

        <aside className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
          <h2 className="mb-3 text-lg font-semibold">Persone salvate</h2>
          <PeopleList />
        </aside>
      </div>
    </Suspense>
  );
}

```


## File: src\app\lab\transits-pro\ClientTransitsPro.tsx

```tsx
// FILE: src/app/lab/transits-pro/ClientTransitsPro.tsx
"use client";

import React, { useState } from "react";
import TransitsWheelPro, {
  type ProPoint,
  type AspectType,
} from "@/components/astro/TransitsWheelPro";

function Controls({
  enabledAspects,
  setEnabledAspects,
  orbOffsetDeg,
  setOrbOffsetDeg,
}: {
  enabledAspects: Record<AspectType, boolean>;
  setEnabledAspects: (val: Record<AspectType, boolean>) => void;
  orbOffsetDeg: number;
  setOrbOffsetDeg: (v: number) => void;
}) {
  const toggle = (k: AspectType) =>
    setEnabledAspects({ ...enabledAspects, [k]: !enabledAspects[k] });

  return (
    <div className="mb-4 grid gap-3 rounded-xl border border-gray-200 bg-white p-4 text-sm shadow-sm">
      <div className="font-medium text-gray-800">Impostazioni aspetti (natal â†” transit)</div>

      <div className="grid grid-cols-2 gap-2 sm:grid-cols-5">
        {(["conjunction", "sextile", "square", "trine", "opposition"] as AspectType[]).map(
          (t) => (
            <label key={t} className="inline-flex items-center gap-2">
              <input
                type="checkbox"
                className="h-4 w-4 accent-gray-900"
                checked={enabledAspects[t]}
                onChange={() => toggle(t)}
              />
              <span className="capitalize">{t}</span>
            </label>
          )
        )}
      </div>

      <div className="mt-2">
        <label htmlFor="orb" className="mb-1 block text-gray-700">
          Orb globale (Â± gradi):{" "}
          <span className="font-semibold">
            {orbOffsetDeg >= 0 ? `+${orbOffsetDeg}` : orbOffsetDeg}Â°
          </span>
        </label>
        <input
          id="orb"
          type="range"
          min={-4}
          max={6}
          step={1}
          value={orbOffsetDeg}
          onChange={(e) => setOrbOffsetDeg(Number(e.target.value))}
          className="w-full"
        />
        <p className="mt-1 text-xs text-gray-500">
          Applica un offset agli orbi base (conj 8Â°, sext 4Â°, sq 6Â°, tr 6Â°, opp 8Â°).
        </p>
      </div>
    </div>
  );
}

export default function ClientTransitsPro({
  today,
  natal,
  houseCusps,
}: {
  today: ProPoint[];
  natal: ProPoint[];
  houseCusps?: number[];
}) {
  const [enabledAspects, setEnabledAspects] = useState<Record<AspectType, boolean>>({
    conjunction: true,
    sextile: true,
    square: true,
    trine: true,
    opposition: true,
  });
  const [orbOffsetDeg, setOrbOffsetDeg] = useState<number>(0);

  return (
    <div className="mx-auto max-w-5xl px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-2xl font-semibold tracking-tight">Transits â€” Pro</h1>
        <p className="text-sm text-gray-500">
          Aspetti tra i pianeti natali dellâ€™utente e i pianeti del cielo di oggi.
        </p>
      </div>

      {/* Controls */}
      <Controls
        enabledAspects={enabledAspects}
        setEnabledAspects={setEnabledAspects}
        orbOffsetDeg={orbOffsetDeg}
        setOrbOffsetDeg={setOrbOffsetDeg}
      />

      {/* Wheel */}
      <div className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
        <div className="aspect-square w-full max-w-[720px] mx-auto">
          <TransitsWheelPro
            today={today}
            natal={natal}
            houseCusps={houseCusps}
            enabledAspects={enabledAspects}
            orbOffsetDeg={orbOffsetDeg}
            responsive
          />
        </div>
      </div>
    </div>
  );
}

```


## File: src\app\lab\transits-pro\page.tsx

```tsx
// FILE: src/app/lab/transits-pro/page.tsx
import { Suspense } from "react";
import ClientTransitsPro from "./ClientTransitsPro";
import { computeDailyPlanets } from "@/lib/planets/runtime";
import { createSupabaseServerComponentClient } from "@/lib/supabaseServer";
import { computeHousesForDateUTC } from "@/lib/houses/runtime";

// ---------------------------
// Tipi locali (adattatore)
// ---------------------------

type RuntimePlanet = {
  name: string;
  longitude: number;
  retro?: boolean;
  sign?: string | null;
};

export type ProPoint = {
  id: string;
  name: string;
  lon: number;
  retro?: boolean;
  sign?: string | null;
};

type HouseSystem = "placidus" | "whole";

// Caching leggero
export const revalidate = 60;

// ---------------------------
// Loader pianeti natali da DB: chart_points
// ---------------------------

async function loadNatalForUser() {
  const supabase = createSupabaseServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { natal: [] as ProPoint[], missingReason: "not_logged" as const };
  }

  const { data, error } = await supabase
    .from("chart_points")
    .select("name, longitude, sign, house, retro")
    .eq("user_id", user.id);

  if (error) {
    return { natal: [] as ProPoint[], missingReason: "db_error" as const };
  }

  if (!data || data.length === 0) {
    return { natal: [] as ProPoint[], missingReason: "no_points" as const };
  }

  const natal: ProPoint[] = data
    .filter((row) => typeof row.longitude === "number" && row.name)
    .map((row) => ({
      id: row.name,
      name: row.name,
      lon: ((row.longitude % 360) + 360) % 360,
      retro: !!row.retro,
      sign: row.sign ?? null,
    }));

  return { natal, missingReason: null as null };
}

// ---------------------------
// Loader house cusps (natal) dal runtime case
// ---------------------------

async function loadNatalHouses() {
  const supabase = createSupabaseServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { cusps: undefined as number[] | undefined, reason: "not_logged" as const };

  // Sistema case da user_prefs
  const { data: prefs } = await supabase
    .from("user_prefs")
    .select("house_system")
    .eq("user_id", user.id)
    .maybeSingle();

  const system = (prefs?.house_system ?? "placidus") as HouseSystem;

  // Dati di nascita (UTC + luogo) â€” adatta al tuo schema reale
  const { data: birth } = await supabase
    .from("birth_data")
    .select("date, lat, lon")
    .eq("user_id", user.id)
    .maybeSingle();

  if (!birth?.date || birth.lat == null || birth.lon == null) {
    return { cusps: undefined, reason: "no_birth_data" as const };
  }

  const houses = await computeHousesForDateUTC({
    system,
    dateUTC: new Date(birth.date),
    latDeg: birth.lat,
    lonDeg: birth.lon,
  });

  const cusps =
    houses?.cusps && Array.isArray(houses.cusps) && houses.cusps.length >= 12
      ? houses.cusps.slice(0, 12).map((d: number) => ((d % 360) + 360) % 360)
      : undefined;

  return { cusps, reason: null as null };
}

// ---------------------------
// Loader transiti di oggi
// ---------------------------

async function loadToday() {
  const nowUTC = new Date();
  const todayRaw: RuntimePlanet[] = await computeDailyPlanets(nowUTC);
  const today: ProPoint[] = todayRaw.map((p) => ({
    id: p.name,
    name: p.name,
    lon: p.longitude,
    retro: !!p.retro,
    sign: p.sign ?? null,
  }));
  return today;
}

// ---------------------------
// Page (Server Component)
// ---------------------------

export default async function Page() {
  const [today, natalRes, housesRes] = await Promise.all([
    loadToday(),
    loadNatalForUser(),
    loadNatalHouses(),
  ]);

  const { natal, missingReason } = natalRes;
  const { cusps: houseCusps, reason: housesReason } = housesRes;

  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamento Transitsâ€¦</div>}>
      <ClientTransitsPro today={today} natal={natal} houseCusps={houseCusps} />

      {(missingReason || housesReason) && (
        <div className="mx-auto mt-4 max-w-5xl px-4 space-y-2">
          {missingReason === "not_logged" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Accedi per vedere i tuoi pianeti natali e le case nella ruota dei transiti.
            </div>
          )}
          {missingReason === "no_points" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Nessun punto natale trovato in <em>chart_points</em>.
            </div>
          )}
          {missingReason === "db_error" && (
            <div className="rounded-lg border border-rose-300 bg-rose-50 p-3 text-sm text-rose-800">
              Errore nel caricamento dei punti natali. Riprova piÃ¹ tardi.
            </div>
          )}
          {housesReason === "no_birth_data" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Dati di nascita mancanti: imposta data/ora/luogo di nascita per calcolare le case (sistema: da <code>user_prefs.house_system</code>).
            </div>
          )}
        </div>
      )}
    </Suspense>
  );
}

```


## File: src\app\layout.tsx

```tsx
// src/app/layout.tsx
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'Natal + Transits + Chat',
  description: 'Your chart-aware AI astrologer â€” wellness & entertainment only.',
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-white text-gray-900">
        <header className="border-b">
          <div className="mx-auto max-w-5xl px-4 py-4 flex items-center justify-between">
            <div className="font-semibold">Natal + Transits + Chat</div>
            <nav className="text-sm text-gray-600">MVP</nav>
          </div>
        </header>
        <main className="mx-auto max-w-5xl px-4 py-10">
          {children}
        </main>
        <footer className="border-t text-xs text-gray-500">
          <div className="mx-auto max-w-5xl px-4 py-6 space-y-2">
            <p>
              Disclaimer: this app provides content for wellness &amp; entertainment purposes only.
              It does not replace professional medical, legal, or financial advice.
            </p>
            <p>
              Transparency: MVP uses Whole Sign houses when birth time is available; otherwise a solar chart
              (no houses/ASC) with simplified orbs.
            </p>
          </div>
        </footer>
      </body>
    </html>
  )
}

```


## File: src\app\onboarding\page.tsx

```tsx
import Link from 'next/link';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import AuthForm from '@/components/AuthForm';
import BirthSection from '@/components/BirthSection';
import CurrentLocationForm from '@/components/CurrentLocationForm';

export const dynamic = 'force-dynamic';

export default async function OnboardingPage() {
  const supabase = createSupabaseServerComponentClient();

  // Auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return (
      <main className="max-w-3xl mx-auto p-6 space-y-6">
        <h1 className="text-2xl font-semibold">Get started</h1>
        <p className="text-sm text-gray-600">
          Create an account or sign in to save your chart and preferences.
        </p>
        <AuthForm />
      </main>
    );
  }

  // Dati salvati
  const { data: birth } = await supabase
    .from('birth_data')
    .select('name,date,time,place_name,lat,lon')
    .eq('user_id', user.id)
    .maybeSingle();

  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('current_place_name,current_lat,current_lon,current_tz_name')
    .eq('user_id', user.id)
    .maybeSingle();

  return (
    <main className="max-w-3xl mx-auto p-6 space-y-10">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Onboarding</h1>
        <Link href="/dashboard" className="text-sm rounded border px-3 py-2 hover:bg-gray-50">
          Go to dashboard
        </Link>
      </header>

      {/* Top bar azioni account */}
        {user ? (
        <div className="mb-4 flex items-center justify-end">
          <form action="/api/auth/signout" method="post">
             <button className="rounded-lg border px-3 py-1 text-sm hover:bg-gray-50">
             Sign out
             </button>
          </form>
        </div>
        ) : null}


      {/* Birth section gestita da client component (legge ?edit=birth) */}
      <section id="birth" className="space-y-3">
        <h2 className="text-lg font-medium">Birth data</h2>
        <BirthSection
          birth={{
            name: birth?.name ?? '',
            date: birth?.date ?? '',
            time: birth?.time ?? '',
            place_name: birth?.place_name ?? '',
            lat: birth?.lat ?? null,
            lon: birth?.lon ?? null,
          }}
        />
      </section>

      {/* Current Location */}
      <section id="location" className="space-y-3">
        <h2 className="text-lg font-medium">Current location (for transits)</h2>
        <CurrentLocationForm
          initial={{
            place_name: prefs?.current_place_name ?? '',
            lat: prefs?.current_lat ?? null,
            lon: prefs?.current_lon ?? null,
            tz_name: prefs?.current_tz_name ?? '',
          }}
        />
      </section>
    </main>
  );
}

```


## File: src\app\page.tsx

```tsx
// src/app/page.tsx
import Link from 'next/link';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';

export const dynamic = 'force-dynamic';

export default async function HomePage() {
  const supabase = createSupabaseServerComponentClient();
  const { data: { user } } = await supabase.auth.getUser();

  const ctaHref = user ? '/dashboard' : '/onboarding';

  return (
    <main className="min-h-screen flex items-center justify-center p-8">
      <div className="max-w-3xl text-center space-y-6">
        <h1 className="text-3xl font-bold">Il tuo astrologo AI tascabile</h1>
        <p className="text-gray-600">
          Tema natale, transiti quotidiani/settimanali, e una chat AI che conosce la tua carta.
        </p>
        <div className="flex items-center justify-center gap-3">
          <Link
            href={ctaHref}
            className="rounded-xl bg-blue-600 text-white px-5 py-3 hover:bg-blue-700"
          >
            Get Started
          </Link>
          <Link
            href="/onboarding"
            className="rounded-xl border px-5 py-3 hover:bg-gray-50"
          >
            Onboarding
          </Link>
        </div>
        <p className="text-xs text-gray-500">
          Benessere/entertainment. Non sostituisce consigli medici/legali/finanziari.
        </p>
      </div>
    </main>
  );
}

```


## File: src\components\astro\_parts.tsx

```tsx
// FILE: src/components/astro/_parts.tsx
"use client";

import React from "react";
import type { Point } from "../../lib/aspects";
import { ASPECTS } from "../../lib/aspects";
import "./proTheme.css";

/* ===== utilities ===== */
const rad = (deg: number) => ((deg - 90) * Math.PI) / 180;
const X = (cx: number, r: number, deg: number) => cx + r * Math.cos(rad(deg));
const Y = (cy: number, r: number, deg: number) => cy + r * Math.sin(rad(deg));

/* ===== glifi & colori ===== */
const ZODIAC_GLYPH: Record<number, string> = {
  0: "â™ˆ", 30: "â™‰", 60: "â™Š", 90: "â™‹", 120: "â™Œ", 150: "â™",
  180: "â™Ž", 210: "â™", 240: "â™", 270: "â™‘", 300: "â™’", 330: "â™“",
};
const SIGN_COLOR_VAR: Record<number, string> = {
  0: "var(--sign-aries)",      30: "var(--sign-taurus)",
  60: "var(--sign-gemini)",    90: "var(--sign-cancer)",
  120: "var(--sign-leo)",      150: "var(--sign-virgo)",
  180: "var(--sign-libra)",    210: "var(--sign-scorpio)",
  240: "var(--sign-sagittarius)", 270: "var(--sign-capricorn)",
  300: "var(--sign-aquarius)", 330: "var(--sign-pisces)",
};

const PLANET_GLYPH: Record<string, string> = {
  Sun: "â˜‰", Moon: "â˜½", Mercury: "â˜¿", Venus: "â™€", Mars: "â™‚",
  Jupiter: "â™ƒ", Saturn: "â™„", Uranus: "â™…", Neptune: "â™†", Pluto: "â™‡",
  NNode: "â˜Š", SNode: "â˜‹", Asc: "ASC", Mc: "MC",
};

/* ===== 1) Zodiac Ring ===== */
type ZodiacProps = { cx: number; cy: number; r: number };
export function ZodiacRingPro({ cx, cy, r }: ZodiacProps) {
  const stroke = "var(--wheel-stroke)";
  return (
    <g>
      <circle cx={cx} cy={cy} r={r} fill="none" stroke={stroke} strokeWidth={3} />
      {Array.from({ length: 12 }).map((_, i) => {
        const deg = i * 30;
        const x1 = X(cx, r - 18, deg), y1 = Y(cy, r - 18, deg);
        const x2 = X(cx, r, deg),     y2 = Y(cy, r, deg);
        return (
          <line key={`zdiv-${i}`} x1={x1} y1={y1} x2={x2} y2={y2}
            stroke={stroke} strokeWidth={2}/>
        );
      })}
      {Object.entries(ZODIAC_GLYPH).map(([degStr, glyph]) => {
        const base = Number(degStr);
        const deg = base + 15; // centro settore
        return (
          <text key={`zgl-${base}`} x={X(cx, r - 28, deg)} y={Y(cy, r - 28, deg) + 7}
            textAnchor="middle" fontSize={22} style={{ fill: SIGN_COLOR_VAR[base] }}>
            {glyph}
          </text>
        );
      })}
    </g>
  );
}

/* ===== 2) Houses Ring (dell'utente) ===== */
type HousesProps = { cx: number; cy: number; rOuter: number; rInner: number; cusps: number[] };
export function HousesRingPro({ cx, cy, rOuter, rInner, cusps }: HousesProps) {
  const grid = "var(--grid-strong)";
  return (
    <g>
      <circle cx={cx} cy={cy} r={rOuter} fill="none" stroke={grid} />
      <circle cx={cx} cy={cy} r={rInner} fill="none" stroke={grid} />
      {cusps?.length === 12 && cusps.map((deg, i) => (
        <line key={`h-${i}`} x1={X(cx, rInner, deg)} y1={Y(cy, rInner, deg)}
          x2={X(cx, rOuter, deg)} y2={Y(cy, rOuter, deg)} stroke={grid} />
      ))}
    </g>
  );
}

/* ===== 3) Pianeti (oggi) ===== */
type PlanetGlyphsProps = {
  cx: number; cy: number; r: number; points: Point[];
  onHover?: (key: string | null)=>void; hoverSet?: Set<string> | null; ringId?: "t";
};
export function PlanetGlyphsPro({ cx, cy, r, points, onHover, hoverSet }: PlanetGlyphsProps) {
  return (
    <g>
      {points.map((p) => {
        const k = `t:${p.name}`;
        const active = !hoverSet || hoverSet.has(k);
        const x = X(cx, r, p.longitude), y = Y(cy, r, p.longitude);
        const glyph = PLANET_GLYPH[p.name] ?? p.name.slice(0,2);
        return (
          <g key={k} transform={`translate(${x},${y})`}
             onMouseEnter={()=>onHover?.(k)} onMouseLeave={()=>onHover?.(null)}
             style={{ cursor: "pointer" }}>
            <circle r={13} fill={active ? "var(--planet-fill)" : "var(--planet-fill-dim)"} />
            <text x={0} y={4} textAnchor="middle" fontSize={12} fill="var(--planet-label)">{glyph}</text>
          </g>
        );
      })}
    </g>
  );
}

/* ===== 4) Aspect Lines (oggiâ†”oggi) ===== */
type AspectLinesProps = {
  cx: number; cy: number; r: number;
  aspects: Array<{ a: string; b: string; aspect: keyof typeof ASPECTS; orb: number }>;
  idx: Map<string, number>; hoverSet: Set<string> | null;
};
const ASPECT_COLOR: Record<keyof typeof ASPECTS, string> = {
  conj: "var(--aspect-conjunction)",
  sext: "var(--aspect-sextile)",
  sq:   "var(--aspect-square)",
  tri:  "var(--aspect-trine)",
  opp:  "var(--aspect-opposition)",
};
export function AspectLinesStraightToday({ cx, cy, r, aspects, idx, hoverSet }: AspectLinesProps) {
  return (
    <g>
      {aspects.map((a, i) => {
        const d1 = idx.get(a.a), d2 = idx.get(a.b);
        if (d1 == null || d2 == null) return null;
        const key1 = `t:${a.a}`, key2 = `t:${a.b}`;
        const active = !hoverSet || hoverSet.has(key1) || hoverSet.has(key2);
        const x1 = X(cx, r, d1), y1 = Y(cy, r, d1);
        const x2 = X(cx, r, d2), y2 = Y(cy, r, d2);
        return (
          <line key={`${i}-${a.a}-${a.b}`} x1={x1} y1={y1} x2={x2} y2={y2}
            stroke={ASPECT_COLOR[a.aspect]} strokeOpacity={active ? 0.9 : 0.25}
            strokeWidth={active ? 1.8 : 0.8}/>
        );
      })}
    </g>
  );
}

/* ===== 5) Cerchi aspectogram ===== */
export function AspectGuides({ cx, cy, rOuter, rInner }:{cx:number;cy:number;rOuter:number;rInner:number}) {
  return (
    <g>
      <circle cx={cx} cy={cy} r={rOuter} fill="none" stroke="var(--grid-strong)" />
      <circle cx={cx} cy={cy} r={rInner} fill="none" stroke="var(--grid-stroke)" />
    </g>
  );
}

```


## File: src\components\astro\ChartWheelPro.tsx

```tsx
// src/components/astro/ChartWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { ProPoint } from '@/lib/graphics/types';
import {
  signColor,
  planetChar,
  PlanetName,
  ZodiacSign,
  signChar,
} from '@/lib/graphics/glyphs';
import { ASPECT_COLORS } from '@/lib/graphics/tokens';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type Axes = { asc: number; mc: number };

export default function ChartWheelPro({
  title = 'ChartWheelPro (Natal)',
  points,
  houseCusps,
  axes,                 // opzionale
  size = 520,
  className,
  responsive = true,
  usePlanetBadges = false,
}: {
  title?: string;
  points: ProPoint[];
  houseCusps?: number[];
  axes?: Axes;
  size?: number;
  className?: string;
  responsive?: boolean;
  usePlanetBadges?: boolean;
}) {
  const r = size / 2;

  // â€”â€” RAGGI (dal centro verso lâ€™esterno) â€”â€”
  const aspectsR          = r * 0.34;
  const housesNumR        = r * 0.48;
  const housesNumInnerR   = r * 0.44;
  const housesNumOuterR   = r * 0.52;
  const planetsR          = r * 0.76;
  const zodiacInnerR      = r * 0.86;
  const zodiacOuterR      = r * 0.98;

  // â€”â€” Assi: derivazione se non forniti â€”â€” //
  const baseAxes: Axes = useMemo(() => {
    if (axes) return { asc: norm(axes.asc), mc: norm(axes.mc) };
    if (houseCusps && houseCusps.length === 12) {
      return { asc: norm(houseCusps[0]!), mc: norm(houseCusps[9]!) };
    }
    return { asc: 180, mc: 90 }; // placeholder
  }, [axes, houseCusps]);

  // â€”â€” Rotazione ANGOLI (non testo): vogliamo AC a 270Â° (sinistra) â€”â€” //
  // polarToXY usa 0Â° in alto, 90Â° a destra, 180Â° in basso, 270Â° a sinistra.
  // Quindi rot = 270 - ASC.
  const rot = useMemo(() => norm(270 - baseAxes.asc), [baseAxes.asc]);
  const applyRot = (deg: number) => norm(deg + rot);

  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanetIdx, setHoverPlanetIdx] = useState<number | null>(null);
  const [focusPlanetIdx, setFocusPlanetIdx] = useState<number | null>(null);

  const planetAnglesRaw = useMemo(
    () => resolveCollisions(points.map(p => p.longitude), 8),
    [points]
  );

  // â€”â€” aspetti natal â€”â€” //
  const aspects = useMemo(() => {
    const results: { from: number; to: number; type: keyof typeof ASPECT_COLORS }[] = [];
    const defs = [
      { type: 'conjunction' as const, deg: 0 },
      { type: 'opposition'  as const, deg: 180 },
      { type: 'trine'       as const, deg: 120 },
      { type: 'square'      as const, deg: 90 },
      { type: 'sextile'     as const, deg: 60 },
    ];
    const orb = 6;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const diff = Math.abs(points[i].longitude - points[j].longitude) % 360;
        const d = diff > 180 ? 360 - diff : diff;
        const found = defs.find(a => Math.abs(d - a.deg) <= orb);
        if (found) results.push({ from: i, to: j, type: found.type });
      }
    }
    return results;
  }, [points]);

  const aspectsByPlanet = useMemo(() => {
    const map = new Map<number, number[]>();
    aspects.forEach((a, idx) => {
      (map.get(a.from) ?? map.set(a.from, []).get(a.from)!).push(idx);
      (map.get(a.to) ?? map.set(a.to, []).get(a.to)!).push(idx);
    });
    return map;
  }, [aspects]);

  const highlightedPlanets = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) {
      const a = aspects[hoverAspectIdx];
      if (a) { set.add(a.from); set.add(a.to); }
    }
    if (hoverPlanetIdx != null) {
      set.add(hoverPlanetIdx);
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) { const a = aspects[idx]; set.add(a.from); set.add(a.to); }
    }
    if (focusPlanetIdx != null) set.add(focusPlanetIdx);
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, focusPlanetIdx, aspects, aspectsByPlanet]);

  const highlightedAspects = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) set.add(hoverAspectIdx);
    if (hoverPlanetIdx != null) {
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) set.add(idx);
    }
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, aspectsByPlanet]);

  function buildAriaLabel(p: ProPoint): string {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}Â° ${sign}`;
  }

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 text-sm font-medium">{title}</div>

      <svg
        role="img"
        aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* â€”â€” Zodiac band â€”â€” */}
        {Array.from({ length: 12 }).map((_, i) => {
          const path = describeDonutSector(
            r, r, zodiacOuterR, zodiacInnerR,
            applyRot(i * 30), applyRot(i * 30 + 30)
          );
          return <path key={`sec-${i}`} d={path} fill="white" stroke="none" />;
        })}
        {Array.from({ length: 12 }).map((_, i) => {
          const deg = applyRot(i * 30);
          const p1 = polarToXY(r, r, zodiacInnerR, deg);
          const p2 = polarToXY(r, r, zodiacOuterR, deg);
          return <line key={`sep-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#111827" strokeWidth={1} opacity={0.7} />;
        })}
        <circle cx={r} cy={r} r={zodiacOuterR} fill="none" stroke="#111827" strokeWidth={1.5} />
        <circle cx={r} cy={r} r={zodiacInnerR} fill="none" stroke="#111827" strokeWidth={1} opacity={0.6} />

        {renderZodiacBandColored(r, size, (zodiacInnerR + zodiacOuterR) / 2, applyRot)}

        {/* â€”â€” Case â€”â€” */}
        {houseCusps && houseCusps.length === 12 && houseCusps.map((deg, i) => {
          const d = applyRot(deg);
          const p1 = polarToXY(r, r, 0, d);
          const p2 = polarToXY(r, r, zodiacInnerR, d);
          return <line key={`cusp-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#9ca3af" strokeWidth={0.9} />;
        })}

        {/* â€”â€” Assi + etichette â€”â€” */}
        {renderAxes(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}
        {renderAxisLabels(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}

        {/* â€”â€” Rete aspetti â€”â€” */}
        {aspects.map((a, idx) => {
          const a1 = applyRot(planetAnglesRaw[a.from]);
          const a2 = applyRot(planetAnglesRaw[a.to]);
          const p1 = polarToXY(r, r, aspectsR, a1);
          const p2 = polarToXY(r, r, aspectsR, a2);
          const isHi = highlightedAspects.has(idx);
          return (
            <line
              key={idx}
              x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
              stroke={ASPECT_COLORS[a.type]}
              strokeWidth={isHi ? 2.6 : 1.2}
              opacity={isHi ? 1 : 0.75}
              onMouseEnter={() => setHoverAspectIdx(idx)}
              onMouseLeave={() => setHoverAspectIdx(null)}
            />
          );
        })}

        {/* â€”â€” Anello numeri case â€”â€” */}
        <circle cx={r} cy={r} r={housesNumInnerR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        <circle cx={r} cy={r} r={housesNumOuterR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        {houseCusps && houseCusps.length === 12 && renderHouseNumbers(r, size, housesNumR, houseCusps, applyRot)}

        {/* â€”â€” Pianeti â€”â€” */}
        {points.map((p, i) => {
          const aRot = applyRot(planetAnglesRaw[i]);

          const tickStartR = zodiacInnerR;
          const tickEndR   = zodiacInnerR - (zodiacInnerR - planetsR) * 0.45;

          const tickStart = polarToXY(r, r, tickStartR, aRot);
          const tickEnd   = polarToXY(r, r, tickEndR, aRot);
          const glyph     = polarToXY(r, r, planetsR, aRot);

          const isHi = highlightedPlanets.has(i) || focusPlanetIdx === i;
          const char = planetChar(p.name as PlanetName);
          const glyphFont = 14 * (size / 520);

          return (
            <g
              key={i}
              tabIndex={0}
              role="img"
              aria-label={buildAriaLabel(p)}
              onFocus={() => setFocusPlanetIdx(i)}
              onBlur={() => setFocusPlanetIdx(null)}
              onMouseEnter={() => setHoverPlanetIdx(i)}
              onMouseLeave={() => setHoverPlanetIdx(null)}
              style={{ cursor: 'pointer' }}
            >
              <line x1={tickStart.x} y1={tickStart.y} x2={tickEnd.x} y2={tickEnd.y} stroke="#111827" strokeWidth={0.9} opacity={0.85} />
              <circle cx={glyph.x} cy={glyph.y} r={9 * (size / 520)} fill="white" />
              <text
                x={glyph.x}
                y={glyph.y}
                textAnchor="middle"
                dominantBaseline="central"
                fontSize={glyphFont}
                fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                fill="#111827"
                pointerEvents="none"
              >
                {char}
              </text>
              {usePlanetBadges ? (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={10 * (size / 520)} fill="white" stroke={isHi ? '#111827' : 'black'} strokeWidth={isHi ? 1.8 : 1} />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={13.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
                </>
              ) : (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={12 * (size / 520)} fill="transparent" pointerEvents="all" />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={12.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.9} />}
                </>
              )}
              <title>{buildAriaLabel(p)}</title>
            </g>
          );
        })}
      </svg>
    </div>
  );
}

/** Glifi dei segni colorati (testo diritto), con angoli ruotati */
function renderZodiacBandColored(
  cx: number,
  size: number,
  radius: number,
  applyRot: (deg: number) => number
) {
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs.map((s, i) => {
    const mid = applyRot(i * 30 + 15);
    const { x, y } = polarToXY(cx, cx, radius, mid);
    return (
      <text
        key={s}
        x={x}
        y={y}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize={14 * (size / 520)}
        fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
        fill={signColor(s)}
      >
        {signChar(s)}
      </text>
    );
  });
}

function renderAxes(
  r: number,
  size: number,
  axesRot: Axes,   // asc/mc giÃ  ruotati via applyRot
  outerRingR: number
) {
  // Invertiamo MC/IC per avere MC in alto e IC in basso
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Chart axes">
      {items.map((it, idx) => {
        const p1 = polarToXY(r, r, 0, it.deg);
        const p2 = polarToXY(r, r, outerRingR, it.deg);
        return (
          <line
            key={idx}
            x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
            stroke="#111827" strokeWidth={1.1} opacity={0.7}
          />
        );
      })}
    </g>
  );
}

function renderAxisLabels(
  r: number,
  size: number,
  axesRot: Axes,
  outerRingR: number
) {
  const labelR = outerRingR + 14 * (size / 520);
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Axis labels">
      {items.map((it, idx) => {
        const t = polarToXY(r, r, labelR, it.deg);
        return (
          <text
            key={idx}
            x={t.x}
            y={t.y}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={11 * (size / 520)}
            fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
            fill="#111827"
          >
            {it.label}
          </text>
        );
      })}
    </g>
  );
}

/** Numeri delle case nel â€œmiddleâ€ tra cusp[i] e cusp[i+1], con rotazione applicata */
function renderHouseNumbers(
  r: number,
  size: number,
  radius: number,
  cusps: number[],
  applyRot: (deg: number) => number
) {
  const items = Array.from({ length: 12 }).map((_, i) => {
    const a = applyRot(cusps[i]!);
    const b = applyRot(cusps[(i + 1) % 12]!);
    const mid = midAngle(a, b);
    const { x, y } = polarToXY(r, r, radius, mid);
    return { i: i + 1, x, y };
  });
  return (
    <g aria-label="House numbers">
      {items.map(({ i, x, y }) => (
        <text
          key={i}
          x={x}
          y={y}
          textAnchor="middle"
          dominantBaseline="central"
          fontSize={12 * (size / 520)}
          fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
          fill="#111827"
          opacity={0.85}
        >
          {i}
        </text>
      ))}
    </g>
  );
}

function midAngle(a: number, b: number) {
  let d = norm(b - a);
  if (d > 180) d -= 360;
  return norm(a + d / 2);
}

function norm(deg: number) {
  let d = deg % 360;
  if (d < 0) d += 360;
  return d;
}

/** Settore ad anello (donut) tra due raggi */
function describeDonutSector(
  cx: number, cy: number,
  rOuter: number, rInner: number,
  startDeg: number, endDeg: number
): string {
  const startOuter = polarToXY(cx, cy, rOuter, endDeg);
  const endOuter   = polarToXY(cx, cy, rOuter, startDeg);
  const startInner = polarToXY(cx, cy, rInner, startDeg);
  const endInner   = polarToXY(cx, cy, rInner, endDeg);
  const delta = norm(endDeg - startDeg);
  const largeArc = delta <= 180 ? 0 : 1;
  return [
    `M ${startOuter.x} ${startOuter.y}`,
    `A ${rOuter} ${rOuter} 0 ${largeArc} 0 ${endOuter.x} ${endOuter.y}`,
    `L ${startInner.x} ${startInner.y}`,
    `A ${rInner} ${rInner} 0 ${largeArc} 1 ${endInner.x} ${endInner.y}`,
    'Z',
  ].join(' ');
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs[idx]!;
}

```


## File: src\components\astro\css\proTheme.css

```css
/* FILE: src/components/astro/proTheme.css */

/* 
  Palette guidata da CSS variables.
  Se ChartWheelPro/natal-pro definiscono giÃ  variabili di tema,
  queste faranno semplicemente da fallback.
*/

:root {
  /* Segni â€“ fallback */
  --sign-aries: #e05858;
  --sign-taurus: #c58b2b;
  --sign-gemini: #d6a11a;
  --sign-cancer: #4aa9c8;
  --sign-leo: #f08c2e;
  --sign-virgo: #3e8e7e;
  --sign-libra: #b66ad3;
  --sign-scorpio: #6b5bd3;
  --sign-sagittarius: #3ea56e;
  --sign-capricorn: #2f4858;
  --sign-aquarius: #4b8bd8;
  --sign-pisces: #6fb0ff;

  /* Aspetti â€“ fallback */
  --aspect-conjunction: #3a3a3a;
  --aspect-sextile: #1e88e5;
  --aspect-square: #d32f2f;
  --aspect-trine: #43a047;
  --aspect-opposition: #8e24aa;

  /* Ruota */
  --wheel-stroke: #101419;
  --grid-stroke: #9aa4b214;   /* linee sottili intermedie */
  --grid-strong: #9aa4b235;   /* linee cuspidi/cerchi principali */
  --planet-fill: #0f172a;     /* balloon pianeti */
  --planet-fill-dim: #0f172a55;
  --planet-label: #ffffff;
}

```


## File: src\components\astro\DailySkyWheelPro.tsx

```tsx
// FILE: src/components/astro/DailySkyWheelPro.tsx
"use client";

import React, { useMemo, useState, useId } from "react";
import { polarToXY } from "@/lib/graphics/polar";
import {
  planetChar,
  signChar,
  signColor,
  aspectColor,
  type PlanetName,
  type ZodiacSign,
} from "@/lib/graphics/glyphs";

// -------------------------------
// Tipi
// -------------------------------

export type ProPoint = {
  id: string;      // "Sun" | ...
  name: string;
  lon: number;     // [0..360)
  retro?: boolean;
  sign?: string | null;
};

export type AspectType = "conjunction" | "sextile" | "square" | "trine" | "opposition";

export type InterAspect = {
  id: string;
  a: ProPoint;
  b: ProPoint;
  type: AspectType;
  exactAngle: number; // 0,60,90,120,180
  delta: number;      // distanza dall'esatto
  strength: number;   // 0..1
};

// -------------------------------
// Costanti (coerenti con ChartWheelPro)
// -------------------------------

const STROKES = {
  ringThin: 0.22,
  ringMid: 0.28,
  ringBold: 0.9,
  aspects: 0.35,
  aspectsHi: 1.0,
  planetHalo: 0.35,
  planetHaloHi: 1.0,
};

const ASPECTS_MAP: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

// Orbi "base" (come deciso in Step 3); lo slider applica un offset globale
const ORBS_BASE: Record<AspectType, number> = {
  conjunction: 8,
  sextile: 4,
  square: 6,
  trine: 6,
  opposition: 8,
};

// -------------------------------
// Utility
// -------------------------------

function norm360(d: number) {
  return ((d % 360) + 360) % 360;
}

function angularDistance(a: number, b: number): number {
  let d = Math.abs(a - b) % 360;
  if (d > 180) d = 360 - d;
  return d;
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor(norm360(longitude) / 30);
  const signs: ZodiacSign[] = [
    "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
    "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"
  ];
  return signs[idx]!;
}

function PlanetGlyph({ name, size, fill = "currentColor" }: { name: string; size: number; fill?: string }) {
  const g = planetChar(name as PlanetName) ?? "â€¢";
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={name}
      fill={fill}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

function SignGlyph({ sign, size }: { sign: ZodiacSign; size: number }) {
  const g = signChar(sign);
  const c = signColor(sign);
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={sign}
      fill={c} // solo glifo colorato, nessun contorno
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

// -------------------------------
// Props
// -------------------------------

export type DailySkyWheelProProps = {
  today: ProPoint[];
  /** Abilitazione per tipo di aspetto (default: tutti true) */
  enabledAspects?: Partial<Record<AspectType, boolean>>;
  /** Offset globale in gradi applicato agli orbi base (puÃ² essere negativo/positivo) */
  orbOffsetDeg?: number;
  size?: number;
  className?: string;
  responsive?: boolean;
};

// -------------------------------
// Component
// -------------------------------

const CX = 260;
const CY = 260;

export default function DailySkyWheelPro({
  today,
  enabledAspects,
  orbOffsetDeg = 0,
  size = 520,
  className,
  responsive = true,
}: DailySkyWheelProProps) {
  const uid = useId();

  // --- Geometrie (come concordato) ---
  const R_ZOD_OUT = 252;   // bordo esterno fascia segni
  const R_ZOD_IN  = 228;   // bordo interno fascia segni
  const R_PLANET  = 200;   // corona pianeti
  const R_ASPECT  = 150;   // hub aspetti
  const PLANET_TICK_LEN = 18;
  const PLANET_TICK_OPACITY = 0.28;
  const PLANET_TICK_WIDTH = 1.0;

  // Stato hover
  const [hoverPlanetId, setHoverPlanetId] = useState<string | null>(null);
  const [hoverAspectId, setHoverAspectId] = useState<string | null>(null);

  // Pianeti con posizioni e segni
  const planets = useMemo(() => {
    return today.map((p) => {
      const theta = norm360(p.lon);
      const posPlan = polarToXY(CX, CY, R_PLANET, theta);
      const posAsp  = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return {
        ...p,
        theta,
        x: posPlan.x, y: posPlan.y,
        ax: posAsp.x, ay: posAsp.y,
        signZ: s,
      };
    });
  }, [today]);

  // Mappa enabled (default tutti attivi)
  const enabled: Record<AspectType, boolean> = useMemo(() => {
    const allTrue: Record<AspectType, boolean> = {
      conjunction: true, sextile: true, square: true, trine: true, opposition: true,
    };
    return { ...allTrue, ...(enabledAspects ?? {}) };
  }, [enabledAspects]);

  // Orbi effettivi applicando l'offset (clamp min 0)
  const ORBS: Record<AspectType, number> = useMemo(() => {
    const clamp = (v: number) => Math.max(0, v);
    return {
      conjunction: clamp(ORBS_BASE.conjunction + orbOffsetDeg),
      sextile:     clamp(ORBS_BASE.sextile     + orbOffsetDeg),
      square:      clamp(ORBS_BASE.square      + orbOffsetDeg),
      trine:       clamp(ORBS_BASE.trine       + orbOffsetDeg),
      opposition:  clamp(ORBS_BASE.opposition  + orbOffsetDeg),
    };
  }, [orbOffsetDeg]);

  // Calcolo aspetti (rispetta enabled + ORBS correnti)
  type BestMatch = { t: AspectType; exact: number; delta: number; strength: number };

const aspects = useMemo<InterAspect[]>(() => {
  const out: InterAspect[] = [];

  for (let i = 0; i < today.length; i++) {
    for (let j = i + 1; j < today.length; j++) {
      const a = today[i];
      const b = today[j];
      const d = angularDistance(a.lon, b.lon);

      let best: BestMatch | undefined;

      for (const t of Object.keys(ASPECTS_MAP) as AspectType[]) {
        if (!enabled[t]) continue; // skip se tipo disabilitato

        const exact = ASPECTS_MAP[t];
        const orb = ORBS[t];
        const delta = Math.abs(d - exact);

        if (delta <= orb) {
          const strength = orb === 0 ? 0 : 1 - delta / orb;
          if (!best || delta < best.delta) {
            best = { t, exact, delta, strength };
          }
        }
      }

      if (best) {
        out.push({
          id: `${a.id}-${b.id}-${best.t}`,
          a,
          b,
          type: best.t,
          exactAngle: best.exact,
          delta: best.delta,
          strength: best.strength,
        });
      }
    }
  }

  return out;
}, [today, enabled, ORBS]);

  // Hover sets
  const involvedAspects = useMemo(() => {
    if (hoverPlanetId) return new Set(aspects.filter(a => a.a.id === hoverPlanetId || a.b.id === hoverPlanetId).map(a => a.id));
    if (hoverAspectId) return new Set([hoverAspectId]);
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  const involvedPlanets = useMemo(() => {
    if (hoverPlanetId) {
      const ids = aspects
        .filter(a => a.a.id === hoverPlanetId || a.b.id === hoverPlanetId)
        .flatMap(a => [a.a.id, a.b.id]);
      return new Set<string>([hoverPlanetId, ...ids]);
    }
    if (hoverAspectId) {
      const a = aspects.find(x => x.id === hoverAspectId);
      if (a) return new Set<string>([a.a.id, a.b.id]);
    }
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  // Zodiac band (ticks + glifi)
  const zodiacMarks = useMemo(() => {
    const out: {
      sign: ZodiacSign; mid: number;
      tx1: number; ty1: number; tx2: number; ty2: number;
      gx: number; gy: number;
    }[] = [];
    for (let i = 0; i < 12; i++) {
      const sign = ([
        "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
        "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces",
      ] as ZodiacSign[])[i]!;
      const start = i * 30;
      const mid = start + 15;

      const t1 = polarToXY(CX, CY, R_ZOD_OUT, start);
      const t2 = polarToXY(CX, CY, R_ZOD_IN,  start);
      const g  = polarToXY(CX, CY, (R_ZOD_OUT + R_ZOD_IN) / 2, mid);

      out.push({
        sign, mid,
        tx1: t1.x, ty1: t1.y,
        tx2: t2.x, ty2: t2.y,
        gx: g.x, gy: g.y,
      });
    }
    return out;
  }, []);

  // --- Render ---
  return (
    <div className={className}>
      <svg
        width={responsive ? "100%" : size}
        height={responsive ? "100%" : size}
        viewBox="0 0 520 520"
        role="img"
        aria-label="Daily Sky Pro Wheel"
      >
        {/* Fascia segni */}
        <circle cx={CX} cy={CY} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringBold} strokeWidth={2.1} />
        <circle cx={CX} cy={CY} r={R_ZOD_IN}  fill="none" stroke="currentColor" strokeOpacity={STROKES.ringMid} strokeWidth={1.2} />

        {/* Ticks settore e glifi dei segni */}
        {zodiacMarks.map((z, i) => (
          <g key={`z-${i}-${uid}`}>
            <line
              x1={z.tx1} y1={z.ty1}
              x2={z.tx2} y2={z.ty2}
              stroke="currentColor"
              strokeOpacity={STROKES.ringMid}
              strokeWidth={1}
            />
            <g transform={`translate(${z.gx}, ${z.gy})`}>
              <SignGlyph sign={z.sign} size={16} />
            </g>
          </g>
        ))}

        {/* Hub aspetti (cerchio interno) */}
        <circle cx={CX} cy={CY} r={R_ASPECT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />

        {/* Aspettogramma: linee tra proiezioni sull'hub */}
        {aspects.map((a) => {
          const A = planets.find(p => p.id === a.a.id)!;
          const B = planets.find(p => p.id === a.b.id)!;
          const isHi = involvedAspects.has(a.id);
          const c = aspectColor(a.type);
          const w = isHi ? 1.35 : 0.95;
          const op = isHi ? STROKES.aspectsHi : STROKES.aspects;

          return (
            <g key={a.id}
               onMouseEnter={() => setHoverAspectId(a.id)}
               onMouseLeave={() => setHoverAspectId(null)}>
              <line x1={A.ax} y1={A.ay} x2={B.ax} y2={B.ay} stroke={c} strokeOpacity={op} strokeWidth={w} />
              <circle cx={A.ax} cy={A.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
              <circle cx={B.ax} cy={B.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
            </g>
          );
        })}

        {/* Tacche per-pianeta (lunghezza fissa) */}
        {planets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke="currentColor"
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Pianeti: nessun bordo di default; halo solo in hover/involved */}
        {planets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const sCol = signColor(p.signZ);
          const haloOpacity = involved ? STROKES.planetHaloHi : STROKES.planetHalo;
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={p.id}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={sCol}
                  strokeOpacity={haloOpacity}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} />
            </g>
          );
        })}
      </svg>
    </div>
  );
}

```


## File: src\components\astro\DailyWheelPro.tsx

```tsx
// FILE: src/components/astro/DailyWheelPro.tsx
"use client";

import React, { useMemo, useState } from "react";
import { Point, ASPECTS } from "../../lib/aspects";
import {
  ZodiacRingPro,
  HousesRingPro,
  PlanetGlyphsPro,
  AspectLinesStraight,
} from "./_parts";

type Props = {
  natalPoints: Point[];
  natalCusps: number[];
  todayPoints: Point[];
  todayCusps: number[];
  aspects: Array<{ t: string; n: string; aspect: keyof typeof ASPECTS; orb: number }>;
  className?: string;
};

export default function DailyWheelPro({
  natalPoints,
  natalCusps,
  todayPoints,
  aspects,
  className,
}: Props) {
  const [hoverKey, setHoverKey] = useState<string | null>(null);

  const hoverFilter = useMemo(() => {
    if (!hoverKey) return null;
    const [, name] = hoverKey.split(":");
    return new Set<string>([`n:${name}`, `t:${name}`]);
  }, [hoverKey]);

  const natalIndex = useMemo(() => {
    const m = new Map<string, number>();
    natalPoints.forEach((p) => m.set(p.name, p.longitude));
    return m;
  }, [natalPoints]);

  const todayIndex = useMemo(() => {
    const m = new Map<string, number>();
    todayPoints.forEach((p) => m.set(p.name, p.longitude));
    return m;
  }, [todayPoints]);

  const width = 720;
  const height = 720;
  const cx = width / 2;
  const cy = height / 2;

  const R_ZODIAC = 320;
  const R_HOUSES_OUT = 292;
  const R_HOUSES_IN = 250;
  const R_PLANETS_NATAL = 238;
  const R_PLANETS_TRANSIT = 200;
  const R_ASPECT_OUT = 170;
  const R_ASPECT_IN = 80;

  return (
    <div className={className ?? ""}>
      <svg width={width} height={height} role="img" aria-label="Daily Pro Wheel">
        <defs>
          <filter id="soft-blur" x="-20%" y="-20%" width="140%" height="140%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="0.6" />
          </filter>
          <clipPath id="clip-aspects">
            <circle cx={cx} cy={cy} r={R_ASPECT_OUT} />
          </clipPath>
        </defs>

        <ZodiacRingPro cx={cx} cy={cy} r={R_ZODIAC} />
        <HousesRingPro cx={cx} cy={cy} rOuter={R_HOUSES_OUT} rInner={R_HOUSES_IN} cusps={natalCusps} />

        <PlanetGlyphsPro
          cx={cx}
          cy={cy}
          r={R_PLANETS_NATAL}
          points={natalPoints}
          ringId="n"
          onHover={setHoverKey}
          hoverFilter={hoverFilter}
        />
        <PlanetGlyphsPro
          cx={cx}
          cy={cy}
          r={R_PLANETS_TRANSIT}
          points={todayPoints}
          ringId="t"
          onHover={setHoverKey}
          hoverFilter={hoverFilter}
        />

        <g clipPath="url(#clip-aspects)">
          <AspectLinesStraight
            cx={cx}
            cy={cy}
            rOuter={R_ASPECT_OUT}
            aspects={aspects}
            natalIndex={natalIndex}
            todayIndex={todayIndex}
            hoverFilter={hoverFilter}
          />
        </g>

        <circle cx={cx} cy={cy} r={R_ASPECT_OUT} fill="none" stroke="currentColor" strokeOpacity="0.1" />
        <circle cx={cx} cy={cy} r={R_ASPECT_IN} fill="none" stroke="currentColor" strokeOpacity="0.08" />
      </svg>
    </div>
  );
}

```


## File: src\components\astro\SynastryWheelPro.tsx

```tsx
'use client';

import React, { useMemo, useState } from 'react';
import { polarToXY, describeArc, resolveCollisions } from '@/lib/graphics/polar';
import { planetChar, signChar, type PlanetName, type ZodiacSign } from '@/lib/graphics/glyphs';
import { ASPECT_COLORS } from '@/lib/graphics/tokens';
import type { SynastryAspect, ChartPoint } from '@/lib/synastry/aspects';

type HouseCusp = number;
type Axes = { asc: number; mc: number };

export type SynastryWheelProProps = {
  user:   { points: ChartPoint[]; houses?: HouseCusp[]; axes?: Axes };
  person: { points: ChartPoint[]; houses?: HouseCusp[]; axes?: Axes };
  aspects: SynastryAspect[];
  options?: {
    radii?: { zodiac: number; innerGap: number; center: number };
    showLabels?: boolean;
    minorAspects?: boolean;
    angleOffsetDeg?: number;
  };
  onHover?: (payload:
    | { type: 'planet'; owner: 'user'|'person'; name: string }
    | { type: 'aspect'; aspect: string; from: { owner:'user'|'person'; name:string }, to:{ owner:'user'|'person'; name:string } }
  ) => void;
  size?: number;
  responsive?: boolean;
  className?: string;
};

// palette
const COLOR_USER = '#1d4ed8';   // blu
const COLOR_PERSON = '#f59e0b'; // arancione
const GRID = '#e5e7eb';
const GRID_STRONG = '#9ca3af';
const TEXT = '#374151';
const FILL_BAND = 'rgba(0,0,0,0)'; // bande trasparenti (solo bordi). Cambia se vuoi un leggero fill.

const isNum = (v: unknown): v is number => typeof v === 'number' && Number.isFinite(v);
const norm = (d: number) => ((d % 360) + 360) % 360;

export default function SynastryWheelPro({
  user, person, aspects,
  options, onHover, size = 560, responsive = true, className
}: SynastryWheelProProps) {
  const r = size / 2;

  // === struttura radiale ===
  // partiamo da: fascia zodiacale (spessa), poi fascia utente, poi fascia persona, poi aspect ring
  const radiiBase = {
    zodiac: r * 0.94,     // bordo esterno dei segni (etichette)
    innerGap: r * 0.44,   // raggio ESTERNO dell'aspettogramma (bordo inferiore fascia persona)
    center: r * 0.34,     // cerchio guida interno
    ...(options?.radii ?? {}),
  };

  const thickness = {
    zodiacBand:  r * 0.06,  // spessore fascia segni
    userBand:    r * 0.10,  // spessore fascia utente
    personBand:  r * 0.10,  // spessore fascia persona
  };

  // bordi fascia segni
  const RzOuter = radiiBase.zodiac;
  const RzInner = RzOuter - thickness.zodiacBand;

  // bordi fascia persona (vincolo: bordo inferiore = innerGap)
  const RpInner = radiiBase.innerGap;
  const RpOuter = RpInner + thickness.personBand;

  // bordi fascia utente (vincoli: sup=RzInner, inf=RpOuter)
  const RuOuter = RzInner;
  const RuInner = RpOuter;

  // raggio medio per i glifi
  const RuMid = (RuOuter + RuInner) / 2;
  const RpMid = (RpOuter + RpInner) / 2;

  // assi robusti
  const axesUser: Axes | undefined = useMemo(() => {
    const a = user.axes?.asc, m = user.axes?.mc;
    if (!isNum(a) || !isNum(m)) return undefined;
    return { asc: norm(a), mc: norm(m) };
  }, [user.axes?.asc, user.axes?.mc]);

  const axesPerson: Axes | undefined = useMemo(() => {
    const a = person.axes?.asc, m = person.axes?.mc;
    if (!isNum(a) || !isNum(m)) return undefined;
    return { asc: norm(a), mc: norm(m) };
  }, [person.axes?.asc, person.axes?.mc]);

  // rotazione: ASC utente a ore 9 (270Â° schermo)
  const rot = useMemo(() => norm(270 - (axesUser?.asc ?? 180)), [axesUser?.asc]);
  const applyRot = (deg: number) => norm(deg + rot + (options?.angleOffsetDeg ?? 0));

  const [hover, setHover] = useState<{ key: string; kind: 'planet'|'aspect' } | null>(null);
  const setH = (v: typeof hover) => {
    setHover(v);
    if (!onHover || !v) return;
    if (v.kind === 'planet') {
      const [owner, name] = v.key.split(':') as ['user'|'person', string];
      onHover({ type: 'planet', owner, name });
    } else {
      const [a,b,asp] = v.key.split('|');
      const [owA, nmA] = a.split(':') as ['user'|'person', string];
      const [owB, nmB] = b.split(':') as ['user'|'person', string];
      onHover({ type:'aspect', aspect: asp, from:{owner:owA,name:nmA}, to:{owner:owB,name:nmB} });
    }
  };

  // posizioni pianeti (ruotate)
  const userPos = user.points.map(p => ({ ...p, ang: applyRot(p.lon) }));
  const personPos = person.points.map(p => ({ ...p, ang: applyRot(p.lon) }));

  // collision avoidance
  const userAngles = resolveCollisions(userPos.map(p => p.ang), 8);
  const personAngles = resolveCollisions(personPos.map(p => p.ang), 8);

  const cx = r, cy = r;

  // =======================================================================
  // DRAWERS
  // =======================================================================
function drawZodiac() {
  const arcs = [];
  for (let i = 0; i < 12; i++) {
    const start = applyRot(i * 30);
    const end = applyRot((i + 1) * 30);
    const mid = applyRot(i * 30 + 15);
    const path = describeArc(cx, cy, RzOuter, start, end);
    arcs.push(
      <g key={`z${i}`}>
        {/* SOLO bordo esterno segni */}
        <path d={path} stroke={GRID} strokeWidth={1.2} fill="none" />
        {/* NIENTE bordo interno qui: sarÃ  il bordo ESTERNO fascia utente */}
        <text x={polarToXY(cx, cy, RzOuter + 8, mid).x}
              y={polarToXY(cx, cy, RzOuter + 8, mid).y}
              textAnchor="middle" dominantBaseline="middle"
              fontSize={12} fill={TEXT}>
          {signChar(([
            'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
            'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
          ][i] as ZodiacSign))}
        </text>
      </g>
    );
  }
  return <g>{arcs}</g>;
}

  // === fascia case con tacche che attraversano lo spessore ===
  function drawHouseBand(cusps: number[] | undefined, color: string, rOuter: number, rInner: number, labelsInside: boolean) {
    if (!cusps || cusps.length !== 12) return null;

    const ticks: React.ReactNode[] = [];
    const labels: React.ReactNode[] = [];

    const labelOffset = labelsInside ? -12 : 12;
    for (let i = 0; i < 12; i++) {
      const v = cusps[i];
      const next = cusps[(i + 1) % 12];
      if (!isNum(v) || !isNum(next)) continue;

      const a = applyRot(v);
      const pOut = polarToXY(cx, cy, rOuter, a);
      const pIn  = polarToXY(cx, cy, rInner, a);

      ticks.push(
        <line
          key={`tick-${color}-${i}`}
          x1={pOut.x} y1={pOut.y} x2={pIn.x} y2={pIn.y}
          stroke={color} strokeWidth={1.6} opacity={0.95}
        />
      );

      // label numero casa a metÃ  settore sulla linea mediana della fascia
      const arc = (next - v + 360) % 360;
      const mid = applyRot(v + arc / 2);
      const rMid = (rOuter + rInner) / 2;
      const lp = polarToXY(cx, cy, rMid + labelOffset, mid);
      labels.push(
        <text
          key={`hlabel-${color}-${i}`}
          x={lp.x} y={lp.y} fontSize={10}
          fill={color} textAnchor="middle" dominantBaseline="middle"
        >
          {i + 1}
        </text>
      );
    }

    return (
      <g>
        {/* due bordi della fascia */}
        <circle cx={cx} cy={cy} r={rOuter} fill={FILL_BAND} stroke={GRID_STRONG} />
        <circle cx={cx} cy={cy} r={rInner} fill="none" stroke={GRID_STRONG} />
        {ticks}
        {labels}
      </g>
    );
  }

  function drawAxes(ax: Axes | undefined, color: string) {
    if (!ax || !isNum(ax.asc) || !isNum(ax.mc)) return null;
    const asc = applyRot(ax.asc);
    const mc  = applyRot(ax.mc);

    const pAsc = polarToXY(cx, cy, RzOuter + 10, asc);
    const pDesc = polarToXY(cx, cy, RzOuter + 10, asc + 180);
    const pMc = polarToXY(cx, cy, RzOuter + 10, mc);
    const pIc = polarToXY(cx, cy, RzOuter + 10, mc + 180);

    return (
      <g>
        <line x1={pAsc.x} y1={pAsc.y} x2={pDesc.x} y2={pDesc.y} stroke={color} strokeWidth={1.6}/>
        <line x1={pMc.x} y1={pMc.y} x2={pIc.x} y2={pIc.y} stroke={color} strokeWidth={1.6}/>
        <text x={pAsc.x} y={pAsc.y} fontSize={10} fill={color} dx={-10} dy={0}>ASC</text>
        <text x={pMc.x}  y={pMc.y}  fontSize={10} fill={color} dx={0} dy={-6}>MC</text>
      </g>
    );
  }

  function drawPlanets(
    pos: Array<ChartPoint & { ang: number }>,
    color: string,
    rMid: number,
    owner: 'user'|'person'
  ) {
    const angs = pos === userPos ? userAngles : personAngles;
    const inHoverAspect = (name: string, who: 'user'|'person') => {
      if (!hover || hover.kind !== 'aspect') return false;
      const [a, b] = hover.key.split('|');
      return a === `${who}:${name}` || b === `${who}:${name}`;
    };

    return (
      <g>
        {pos.map((p, i) => {
          const ang = angs[i];
          const pt = polarToXY(cx, cy, rMid, ang);
          const activeByPlanet = hover?.kind==='planet' && hover.key === `${owner}:${p.name}`;
          const activeByAspect = inHoverAspect(p.name as string, owner);
          const active = activeByPlanet || activeByAspect;

          return (
            <g key={`${owner}:${p.name}`}
               onMouseEnter={() => setH({ kind:'planet', key:`${owner}:${p.name}` })}
               onMouseLeave={() => setH(null)}
               style={{ cursor: 'pointer' }}>
              {active && (
                <circle cx={pt.x} cy={pt.y} r={6} fill="none" stroke={color} strokeWidth={2}/>
              )}
              <text x={pt.x} y={pt.y} fontSize={14}
                    textAnchor="middle" dominantBaseline="middle"
                    fill={color} style={{ fontWeight: active ? 600 : 400 }}>
                {planetChar(p.name as PlanetName)}
              </text>
              {p.retro && (
                <text x={pt.x+9} y={pt.y-8} fontSize={9} fill={color}>R</text>
              )}
            </g>
          );
        })}
      </g>
    );
  }

  // aspettogramma confinato nel ring centrale + hover cooperativo
  function drawAspects(lines: SynastryAspect[]) {
    const clipId = 'syn-center-clip';
    return (
      <g>
        <circle cx={cx} cy={cy} r={radiiBase.center} fill="none" stroke={GRID} />
        <circle cx={cx} cy={cy} r={radiiBase.innerGap} fill="none" stroke={GRID_STRONG} />
        <defs>
          <clipPath id={clipId}>
            <circle cx={cx} cy={cy} r={radiiBase.innerGap} />
          </clipPath>
        </defs>
        <g clipPath={`url(#${clipId})`}>
          {lines.map((a, idx) => {
            const fromAng =
              (a.a.owner === 'user'
                ? userPos.find(p => p.name === a.a.name)?.ang
                : personPos.find(p => p.name === a.a.name)?.ang) ?? null;
            const toAng =
              (a.b.owner === 'user'
                ? userPos.find(p => p.name === a.b.name)?.ang
                : personPos.find(p => p.name === a.b.name)?.ang) ?? null;
            if (fromAng == null || toAng == null) return null;

            const A = polarToXY(cx, cy, radiiBase.innerGap, fromAng);
            const B = polarToXY(cx, cy, radiiBase.innerGap, toAng);

            const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
            const c1x = (A.x + mx) / 2, c1y = (A.y + my) / 2;
            const c2x = (B.x + mx) / 2, c2y = (B.y + my) / 2;

            const color =
              a.aspect === 'trine'     ? ASPECT_COLORS.trine :
              a.aspect === 'sextile'   ? ASPECT_COLORS.sextile :
              a.aspect === 'square'    ? ASPECT_COLORS.square :
              a.aspect === 'opposition'? ASPECT_COLORS.opposition :
              ASPECT_COLORS.conjunction;

            const key = `${a.a.owner}:${a.a.name}|${a.b.owner}:${a.b.name}|${a.aspect}`;
            const active =
              (hover?.kind==='aspect' && hover.key === key) ||
              (hover?.kind==='planet' && (hover.key === `${a.a.owner}:${a.a.name}` || hover.key === `${a.b.owner}:${a.b.name}`));

            return (
              <path key={idx}
                d={`M ${A.x} ${A.y} C ${c1x} ${c1y} ${c2x} ${c2y} ${B.x} ${B.y}`}
                fill="none"
                stroke={color}
                strokeOpacity={active ? 1 : 0.7}
                strokeWidth={active ? 2.2 : 1.3}
                onMouseEnter={() => setH({ kind:'aspect', key })}
                onMouseLeave={() => setH(null)}
                style={{ cursor: 'pointer' }}
              />
            );
          })}
        </g>
      </g>
    );
  }

  return (
    <div className={className}>
      <svg viewBox={`0 0 ${size} ${size}`} className={responsive ? 'h-auto w-full' : undefined}>
        {/* base */}
        <circle cx={cx} cy={cy} r={r-1} fill="white" stroke={GRID} />

        {/* fascia segni */}
        {drawZodiac()}

        {/* fascia UTENTE: bordi + tacche (bordo sup = RzInner, bordo inf = RpOuter) */}
        {drawHouseBand(user.houses, COLOR_USER, RuOuter, RuInner, false)}

        {/* fascia PERSONA: bordi + tacche (bordo sup = RuInner, bordo inf = RpInner = aspect ring) */}
        {drawHouseBand(person.houses, COLOR_PERSON, RpOuter, RpInner, true)}

        {/* assi */}
        {drawAxes(axesUser, COLOR_USER)}
        {drawAxes(axesPerson, COLOR_PERSON)}

        {/* aspettogramma */}
        {drawAspects(aspects)}

        {/* glifi dentro le fasce (raggio mediano) */}
        {drawPlanets(userPos, COLOR_USER, RuMid, 'user')}
        {drawPlanets(personPos, COLOR_PERSON, RpMid, 'person')}

        {/* legend */}
        <g>
          <circle cx={16} cy={size-24} r={5} fill={COLOR_USER} />
          <text x={28} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>User</text>
          <circle cx={76} cy={size-24} r={5} fill={COLOR_PERSON} />
          <text x={88} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>Person</text>
        </g>
      </svg>
    </div>
  );
}

```


## File: src\components\astro\TransitsWheelPro.tsx

```tsx
// FILE: src/components/astro/TransitsWheelPro.tsx
"use client";

import React, { useMemo, useState, useId } from "react";
import { polarToXY } from "@/lib/graphics/polar";
import {
  planetChar,
  signChar,
  signColor,
  aspectColor,
  type PlanetName,
  type ZodiacSign,
} from "@/lib/graphics/glyphs";

// -------------------------------
// Tipi condivisi
// -------------------------------

export type ProPoint = {
  id: string;      // "Sun" | ...
  name: string;
  lon: number;     // [0..360)
  retro?: boolean;
  sign?: string | null;
};

export type AspectType = "conjunction" | "sextile" | "square" | "trine" | "opposition";

export type InterAspect = {
  id: string;
  a: ProPoint;
  b: ProPoint;
  type: AspectType;
  exactAngle: number; // 0,60,90,120,180
  delta: number;      // distanza dall'esatto
  strength: number;   // 0..1
};

// -------------------------------
// Stilistica & Costanti
// -------------------------------

const STROKES = {
  ringThin: 0.22,
  ringMid: 0.28,
  ringBold: 0.9,
  aspects: 0.35,
  aspectsHi: 1.0,
  planetHalo: 0.35,
  planetHaloHi: 1.0,
};

const ASPECTS_MAP: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

// Orbi base
const ORBS_BASE: Record<AspectType, number> = {
  conjunction: 8,
  sextile: 4,
  square: 6,
  trine: 6,
  opposition: 8,
};

// Colori serie
const TRANSIT_GLYPH_COLOR = "#ea580c";   // orange-600
const NATAL_GLYPH_COLOR   = "#0284c7";   // sky-600
const TRANSIT_TICK_COLOR  = TRANSIT_GLYPH_COLOR;
const NATAL_TICK_COLOR    = NATAL_GLYPH_COLOR;

// Punti non planetari da escludere dallâ€™anello dei pianeti (failsafe)
const BLOCKED_POINTS = new Set([
  "ASC","AC","Asc","Ascendant","MC","Midheaven","IC","DSC","DC","Desc","Descendant","Vertex","Lilith","Fortuna","?"
]);

// -------------------------------
// Utility
// -------------------------------

function norm360(d: number) {
  return ((d % 360) + 360) % 360;
}

function angularDistance(a: number, b: number): number {
  let d = Math.abs(a - b) % 360;
  if (d > 180) d = 360 - d;
  return d;
}

function midAngle(a: number, b: number) {
  const A = norm360(a);
  const B = norm360(b);
  const delta = ((B - A + 360) % 360);
  return norm360(A + delta / 2);
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor(norm360(longitude) / 30);
  const signs: ZodiacSign[] = [
    "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
    "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"
  ];
  return signs[idx]!;
}

function PlanetGlyph({ name, size, fill = "currentColor" }: { name: string; size: number; fill?: string }) {
  const g = planetChar(name as PlanetName) ?? "â€¢";
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={name}
      fill={fill}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

function SignGlyph({ sign, size }: { sign: ZodiacSign; size: number }) {
  const g = signChar(sign);
  const c = signColor(sign);
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={sign}
      fill={c}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

// -------------------------------
// Props
// -------------------------------

export type TransitsWheelProProps = {
  today: ProPoint[];
  natal: ProPoint[];
  /** 12 cuspidi (gradi eclittici) del tema natale */
  houseCusps?: number[];
  enabledAspects?: Partial<Record<AspectType, boolean>>;
  orbOffsetDeg?: number;
  size?: number;
  className?: string;
  responsive?: boolean;
};

// -------------------------------
// Component
// -------------------------------

const CX = 260;
const CY = 260;

export default function TransitsWheelPro({
  today,
  natal,
  houseCusps,
  enabledAspects,
  orbOffsetDeg = 0,
  size = 520,
  className,
  responsive = true,
}: TransitsWheelProProps) {
  const uid = useId();

  // ===== Geometrie =====
  const R_ZOD_OUT = 252;
  const R_ZOD_IN  = 228;

  const R_NATAL   = 214;   // anello NATAL (puoi regolare)
  const R_TRANSIT = 200;   // anello TRANSITI (puoi regolare)

  // Hub aspetti + fascia numeri case
  const R_ASPECT  = 148;   // inner border fascia numeri + punto di ancoraggio aspetti
  const HOUSE_NUM_BAND_W = 20;
  const R_HOUSE_NUM_IN   = R_ASPECT;
  const R_HOUSE_NUM_OUT  = R_ASPECT + HOUSE_NUM_BAND_W;
  const R_HOUSE_NUM_MID  = (R_HOUSE_NUM_IN + R_HOUSE_NUM_OUT) / 2;
  const HOUSE_NUM_FONT   = 11;
  const HOUSE_NUM_TICK_W = 1.2;

  // Tacche verso i pianeti
  const PLANET_TICK_LEN = 18;
  const PLANET_TICK_OPACITY = 0.5;
  const PLANET_TICK_WIDTH = 1.2;

  // === Nuova fascia assi (AC/IC/DC/MC) esterna alla zodiac band ===
  const AXIS_LABEL_RADIUS   = R_ZOD_OUT + 10; // raggio su cui posare le label (fuori dalla fascia segni)
  const AXIS_TICK_OUT_LEN   = 8;              // lunghezza tacca esterna
  const AXIS_LABEL_FONT     = 11.5;
  const AXIS_COLOR          = "#111827";      // quasi nero

  // ===== Stato hover =====
  const [hoverPlanetId, setHoverPlanetId] = useState<string | null>(null);
  const [hoverAspectId, setHoverAspectId] = useState<string | null>(null);

  // ===== Filtra eventuali punti non planetari (ASC/MC...) =====
  const natalFiltered = useMemo(
    () => natal.filter((p) => !BLOCKED_POINTS.has(p.name)),
    [natal]
  );

  // ===== Pianeti su anelli + proiezione su hub =====
  const natalPlanets = useMemo(() => {
    return natalFiltered.map((p) => {
      const theta = norm360(p.lon);
      const posNat = polarToXY(CX, CY, R_NATAL, theta);
      const posAsp = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return { ...p, theta, x: posNat.x, y: posNat.y, ax: posAsp.x, ay: posAsp.y, signZ: s, band: "natal" as const };
    });
  }, [natalFiltered]);

  const transitPlanets = useMemo(() => {
    return today.map((p) => {
      const theta = norm360(p.lon);
      const posTr = polarToXY(CX, CY, R_TRANSIT, theta);
      const posAsp = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return { ...p, theta, x: posTr.x, y: posTr.y, ax: posAsp.x, ay: posAsp.y, signZ: s, band: "transit" as const };
    });
  }, [today]);

  // ===== Abilitazioni & Orbi =====
  const enabled: Record<AspectType, boolean> = useMemo(() => {
    const allTrue: Record<AspectType, boolean> = {
      conjunction: true, sextile: true, square: true, trine: true, opposition: true,
    };
    return { ...allTrue, ...(enabledAspects ?? {}) };
  }, [enabledAspects]);

  const ORBS: Record<AspectType, number> = useMemo(() => {
    const clamp = (v: number) => Math.max(0, v);
    return {
      conjunction: clamp(ORBS_BASE.conjunction + orbOffsetDeg),
      sextile:     clamp(ORBS_BASE.sextile     + orbOffsetDeg),
      square:      clamp(ORBS_BASE.square      + orbOffsetDeg),
      trine:       clamp(ORBS_BASE.trine       + orbOffsetDeg),
      opposition:  clamp(ORBS_BASE.opposition  + orbOffsetDeg),
    };
  }, [orbOffsetDeg]);

  // ===== Aspetti SOLO natal â†” transit =====
  type BestMatch = { t: AspectType; exact: number; delta: number; strength: number };
  const aspects = useMemo<InterAspect[]>(() => {
    const out: InterAspect[] = [];
    for (const a of natalFiltered) {
      for (const b of today) {
        const d = angularDistance(a.lon, b.lon);
        let best: BestMatch | undefined;
        for (const t of Object.keys(ASPECTS_MAP) as AspectType[]) {
          if (!enabled[t]) continue;
          const exact = ASPECTS_MAP[t];
          const orb = ORBS[t];
          const delta = Math.abs(d - exact);
          if (delta <= orb) {
            const strength = orb === 0 ? 0 : 1 - delta / orb;
            if (!best || delta < best.delta) best = { t, exact, delta, strength };
          }
        }
        if (best) {
          out.push({
            id: `${a.id}-${b.id}-${best.t}`,
            a, b,
            type: best.t,
            exactAngle: best.exact,
            delta: best.delta,
            strength: best.strength,
          });
        }
      }
    }
    return out;
  }, [natalFiltered, today, enabled, ORBS]);

  // ===== Hover sets =====
  const involvedAspects = useMemo(() => {
    if (hoverPlanetId) return new Set(aspects.filter(x => x.a.id === hoverPlanetId || x.b.id === hoverPlanetId).map(x => x.id));
    if (hoverAspectId) return new Set([hoverAspectId]);
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  const involvedPlanets = useMemo(() => {
    if (hoverPlanetId) {
      const ids = aspects
        .filter(x => x.a.id === hoverPlanetId || x.b.id === hoverPlanetId)
        .flatMap(x => [x.a.id, x.b.id]);
      return new Set<string>([hoverPlanetId, ...ids]);
    }
    if (hoverAspectId) {
      const a = aspects.find(x => x.id === hoverAspectId);
      if (a) return new Set<string>([a.a.id, a.b.id]);
    }
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  // ===== Zodiac band (ticks + glifi) =====
  const zodiacMarks = useMemo(() => {
    const out: {
      sign: ZodiacSign; mid: number;
      tx1: number; ty1: number; tx2: number; ty2: number;
      gx: number; gy: number;
    }[] = [];
    for (let i = 0; i < 12; i++) {
      const sign = ([
        "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
        "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces",
      ] as ZodiacSign[])[i]!;
      const start = i * 30;
      const mid = start + 15;

      const t1 = polarToXY(CX, CY, R_ZOD_OUT, start);
      const t2 = polarToXY(CX, CY, R_ZOD_IN,  start);
      const g  = polarToXY(CX, CY, (R_ZOD_OUT + R_ZOD_IN) / 2, mid);

      out.push({
        sign, mid,
        tx1: t1.x, ty1: t1.y,
        tx2: t2.x, ty2: t2.y,
        gx: g.x, gy: g.y,
      });
    }
    return out;
  }, []);

  // ===== Case natali =====
  const houseLines = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    return houseCusps.slice(0, 12).map((deg, i) => {
      const theta = norm360(deg);
      const { x, y } = polarToXY(CX, CY, R_ZOD_OUT, theta);
      const isAxis = i === 0 || i === 3 || i === 6 || i === 9; // ASC/IC/DSC/MC
      return { i, theta, x, y, isAxis };
    });
  }, [houseCusps]);

  const houseNumbers = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    const cusps = houseCusps.slice(0, 12).map(norm360);
    const out: { n: number; theta: number; x: number; y: number }[] = [];
    for (let i = 0; i < 12; i++) {
      const a = cusps[i]!;
      const b = cusps[(i + 1) % 12]!;
      const m = midAngle(a, b);
      const pos = polarToXY(CX, CY, R_HOUSE_NUM_MID, m);
      out.push({ n: i + 1, theta: m, x: pos.x, y: pos.y });
    }
    return out;
  }, [houseCusps, R_HOUSE_NUM_MID]);

  // ===== Etichette assi (AC/IC/DC/MC) esterne =====
  const axisLabels = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    const cusps = houseCusps.slice(0, 12).map(norm360);
    // Indici convenzionali: 1=ASC, 4=IC, 7=DSC, 10=MC
    const items: { key: "AC"|"IC"|"DC"|"MC"; theta: number; tx1:number;ty1:number;tx2:number;ty2:number; lx:number;ly:number }[] = [];

    const defs: { key: "AC"|"IC"|"DC"|"MC"; idx: number }[] = [
      { key: "AC", idx: 0 },
      { key: "IC", idx: 3 },
      { key: "DC", idx: 6 },
      { key: "MC", idx: 9 },
    ];

    for (const d of defs) {
      const theta = cusps[d.idx]!;
      const tickOuter = polarToXY(CX, CY, R_ZOD_OUT + AXIS_TICK_OUT_LEN, theta);
      const tickInner = polarToXY(CX, CY, R_ZOD_OUT, theta);
      const labelPos  = polarToXY(CX, CY, AXIS_LABEL_RADIUS, theta);
      items.push({
        key: d.key,
        theta,
        tx1: tickInner.x, ty1: tickInner.y,
        tx2: tickOuter.x, ty2: tickOuter.y,
        lx: labelPos.x, ly: labelPos.y,
      });
    }
    return items;
  }, [houseCusps, AXIS_LABEL_RADIUS]);

  // ===== Render =====
  return (
    <div className={className}>
      <svg
        width={responsive ? "100%" : size}
        height={responsive ? "100%" : size}
        viewBox="0 0 520 520"
        role="img"
        aria-label="Transits Pro Wheel"
      >
        {/* Fascia segni */}
        <circle cx={CX} cy={CY} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringBold} strokeWidth={2.1} />
        <circle cx={CX} cy={CY} r={R_ZOD_IN}  fill="none"  stroke="currentColor" strokeOpacity={STROKES.ringMid}  strokeWidth={1.2} />

        {/* Case (linee radiali lunghe) */}
        {houseLines.map(({ i, x, y, isAxis }) => (
          <line
            key={`house-${i}-${uid}`}
            x1={CX}
            y1={CY}
            x2={x}
            y2={y}
            stroke="#111827"
            strokeOpacity={isAxis ? 0.55 : 0.25}
            strokeWidth={isAxis ? 1.15 : 0.9}
          />
        ))}

        {/* Ticks dei 12 settori + glifi dei segni */}
        {zodiacMarks.map((z, i) => (
          <g key={`z-${i}-${uid}`}>
            <line
              x1={z.tx1} y1={z.ty1}
              x2={z.tx2} y2={z.ty2}
              stroke="currentColor"
              strokeOpacity={STROKES.ringMid}
              strokeWidth={1}
            />
            <g transform={`translate(${z.gx}, ${z.gy})`}>
              <SignGlyph sign={z.sign} size={16} />
            </g>
          </g>
        ))}

        {/* ==== Fascia numerica delle case ==== */}
        <circle cx={CX} cy={CY} r={R_HOUSE_NUM_IN} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />
        <circle cx={CX} cy={CY} r={R_HOUSE_NUM_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringMid} strokeWidth={1.0} />
        {houseLines.map(({ i, theta }) => {
          const a = polarToXY(CX, CY, R_HOUSE_NUM_OUT, theta);
          const b = polarToXY(CX, CY, R_HOUSE_NUM_IN,  theta);
          return (
            <line
              key={`hnum-tick-${i}-${uid}`}
              x1={a.x} y1={a.y}
              x2={b.x} y2={b.y}
              stroke="currentColor"
              strokeOpacity={0.45}
              strokeWidth={HOUSE_NUM_TICK_W}
            />
          );
        })}
        {houseNumbers.map((hn) => (
          <text
            key={`hnum-${hn.n}-${uid}`}
            x={hn.x}
            y={hn.y}
            fontSize={HOUSE_NUM_FONT}
            textAnchor="middle"
            dominantBaseline="middle"
            fill="currentColor"
            opacity={0.85}
            aria-label={`House ${hn.n}`}
            style={{ userSelect: "none" }}
          >
            {hn.n}
          </text>
        ))}

        {/* ==== Etichette assi esterne: AC / IC / DC / MC ==== */}
        {axisLabels.map((ax) => (
          <g key={`ax-${ax.key}-${uid}`}>
            {/* tacca che esce dalla fascia zodiacale */}
            <line
              x1={ax.tx1} y1={ax.ty1}
              x2={ax.tx2} y2={ax.ty2}
              stroke={AXIS_COLOR}
              strokeWidth={1.2}
              strokeOpacity={0.9}
            />
            {/* label esterna */}
            <text
              x={ax.lx}
              y={ax.ly}
              fontSize={AXIS_LABEL_FONT}
              textAnchor="middle"
              dominantBaseline="middle"
              fill={AXIS_COLOR}
              style={{ userSelect: "none", fontWeight: 600 }}
            >
              {ax.key}
            </text>
          </g>
        ))}

        {/* ==== Hub aspetti (coincide con inner border fascia numeri) ==== */}
        <circle cx={CX} cy={CY} r={R_ASPECT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />

        {/* Aspetti natal â†” transit */}
        {aspects.map((a) => {
          const A =
            natalPlanets.find(p => p.id === a.a.id) ??
            transitPlanets.find(p => p.id === a.a.id)!;
          const B =
            natalPlanets.find(p => p.id === a.b.id) ??
            transitPlanets.find(p => p.id === a.b.id)!;

          const isHi = involvedAspects.has(a.id);
          const c = aspectColor(a.type);
          const w = isHi ? 1.35 : 0.95;
          const op = isHi ? STROKES.aspectsHi : STROKES.aspects;

          return (
            <g key={a.id}
               onMouseEnter={() => setHoverAspectId(a.id)}
               onMouseLeave={() => setHoverAspectId(null)}>
              <line x1={A.ax} y1={A.ay} x2={B.ax} y2={B.ay} stroke={c} strokeOpacity={op} strokeWidth={w} />
              <circle cx={A.ax} cy={A.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
              <circle cx={B.ax} cy={B.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
            </g>
          );
        })}

        {/* Tacche per-pianeta â€” NATALI (azzurre) */}
        {natalPlanets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-natal-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke={NATAL_TICK_COLOR}
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Tacche per-pianeta â€” TRANSITI (arancioni) */}
        {transitPlanets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-transit-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke={TRANSIT_TICK_COLOR}
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Pianeti NATALI (glifi azzurri) */}
        {natalPlanets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const haloCol = signColor(p.signZ);
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={`nat-${p.id}`}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={haloCol}
                  strokeOpacity={STROKES.planetHaloHi}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} fill={NATAL_GLYPH_COLOR} />
            </g>
          );
        })}

        {/* Pianeti TRANSITI (glifi arancioni) */}
        {transitPlanets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const haloCol = signColor(p.signZ);
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={`tr-${p.id}`}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={haloCol}
                  strokeOpacity={STROKES.planetHaloHi}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} fill={TRANSIT_GLYPH_COLOR} />
            </g>
          );
        })}
      </svg>
    </div>
  );
}

```


## File: src\components\AuthForm.tsx

```tsx
'use client';

import { useState } from 'react';
import { createSupabaseBrowser } from '@/lib/supabaseBrowser';

export default function AuthForm() {
  const supabase = createSupabaseBrowser();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [loadingAction, setLoadingAction] = useState<'signup' | 'signin' | null>(null);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  async function doSignUp() {
    if (!email || !password) { setErr('Email and password required.'); return; }
    setLoadingAction('signup'); setErr(null); setMsg(null);
    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          // â† callback "non-API" come da struttura finale
          emailRedirectTo: `${window.location.origin}/auth/callback?next=/onboarding%23birth`,
        },
      });
      if (error) throw error;
      setMsg('Check your email to confirm your account. After confirming, youâ€™ll be redirected here.');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Sign up error');
    } finally {
      setLoadingAction(null);
    }
  }

  async function doSignIn() {
    if (!email || !password) { setErr('Email and password required.'); return; }
    setLoadingAction('signin'); setErr(null); setMsg(null);
    try {
      // 1) login client
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;

      // 2) porta i token al server per scrivere i cookie (necessari alle Server Components)
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token || !session.refresh_token) throw new Error('No session returned');

      const res = await fetch('/api/auth/set-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          access_token: session.access_token,
          refresh_token: session.refresh_token,
        }),
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`set-session failed (${res.status}): ${txt.slice(0, 120)}`);
      }
      const j = await res.json();
      if (!j.ok) throw new Error(j.error || 'Failed to set server session');

      // 3) forza una NAVIGAZIONE VERA (non solo hash) per ricaricare la Server Component
      const target = `/onboarding?ts=${Date.now()}#birth`;
      window.location.assign(target);
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Sign in error');
    } finally {
      setLoadingAction(null);
    }
  }

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <h2 className="font-medium">Create or access your account</h2>
      <div className="grid gap-2 sm:grid-cols-2">
        <input
          className="rounded border px-3 py-2 text-sm"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)} />
        <input
          className="rounded border px-3 py-2 text-sm"
          placeholder="Password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)} />
      </div>
      <div className="flex items-center gap-2">
        <button
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white hover:bg-blue-700"
          onClick={doSignUp}
          disabled={loadingAction !== null}
        >
          {loadingAction === 'signup' ? 'Signing upâ€¦' : 'Sign up'}
        </button>
        <button
          className="rounded border px-3 py-2 text-sm"
          onClick={doSignIn}
          disabled={loadingAction !== null}
        >
          {loadingAction === 'signin' ? 'Signing inâ€¦' : 'Sign in'}
        </button>
      </div>
      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}
      <p className="text-xs text-gray-500">
        Weâ€™ll store your chart and chat history securely. You can delete data anytime.
      </p>
    </div>
  );
}

```


## File: src\components\BirthForm.tsx

```tsx
// src/components/BirthForm.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type ResolveResult = {
  ok: boolean;
  query?: string;
  result?: {
    display_name: string;
    lat: number;
    lon: number;
    city: string | null;
    state: string | null;
    country: string | null;
    timezone: string | null;
    tz_offset_minutes: number | null;
  };
  error?: string;
};

type BirthInitial = {
  name?: string | null;
  date?: string | null;
  time?: string | null;
  place_name?: string | null;
  lat?: number | null;
  lon?: number | null;
  tz_name?: string | null; // opzionale; se assente, la risolviamo
};

export default function BirthForm({ initial }: { initial?: BirthInitial }) {
  const [name, setName] = useState(initial?.name ?? '');
  const [date, setDate] = useState(initial?.date ?? '');
  const [time, setTime] = useState(initial?.time ?? ''); // HH:MM
  const [placeQuery, setPlaceQuery] = useState(initial?.place_name ?? '');
  const [resolved, setResolved] = useState<ResolveResult | null>(null);

  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  // Se abbiamo giÃ  lat/lon/tz salvati, consideriamo "valida" la location
  const haveSavedPlace =
    !!initial?.place_name &&
    typeof initial?.lat === 'number' &&
    typeof initial?.lon === 'number';

  const canResolve = useMemo(() => placeQuery.trim().length >= 2, [placeQuery]);

  // Ãˆ valida la place? o Ã¨ stata risolta ora o abbiamo dati salvati
  const haveValidPlace = useMemo(() => {
    return (
      (resolved?.ok && !!resolved?.result?.timezone) ||
      (haveSavedPlace /* tz verrÃ  ricavata da resolve al bisogno */)
    );
  }, [resolved, haveSavedPlace]);

  const canSubmit = useMemo(() => {
    return (
      name.trim().length > 0 &&
      /^\d{4}-\d{2}-\d{2}$/.test(date) &&
      haveValidPlace
    );
  }, [name, date, haveValidPlace]);

  async function resolvePlace() {
    setErr(null); setMsg(null); setResolved(null);
    if (!canResolve) { setErr('Type at least 2 characters for place'); return; }
    const params = new URLSearchParams();
    params.set('q', placeQuery.trim());
    params.set('date', date || '');
    if (time) params.set('time', time);

    const r = await fetch(`/api/geo/resolve?${params.toString()}`);
    const j = (await r.json()) as ResolveResult;
    if (!j.ok || !j.result) {
      setErr(j.error || 'Place not found');
      setResolved(j);
      return;
    }
    setResolved(j);
  }

  async function submit() {
    if (!canSubmit) return;
    setBusy(true); setErr(null); setMsg(null);

    try {
      // Usa i dati "resolved" se presenti; altrimenti i salvati iniziali
      const place = resolved?.result
        ? {
            place_name: resolved.result.display_name,
            lat: resolved.result.lat,
            lon: resolved.result.lon,
            tz_name: resolved.result.timezone || 'UTC',
          }
        : {
            place_name: initial?.place_name ?? placeQuery,
            lat: initial?.lat as number,
            lon: initial?.lon as number,
            tz_name: initial?.tz_name ?? null, // se null, comunque computePoints fallback a 'UTC'
          };

      const body = {
        name,
        date,
        time: time || null,
        ...place,
      };

      const resp = await fetch('/api/chart/compute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const j = await resp.json();
      if (!resp.ok || !j.ok) {
        throw new Error(j.error || `Compute failed (${resp.status})`);
      }

      setMsg('Birth data saved.');
      // Torna alla vista riassunto (rimuoviamo il flag edit)
      window.location.assign('/onboarding#birth');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Error');
    } finally {
      setBusy(false);
    }
  }

  // Se l'utente cambia query o data/ora, invalidiamo la risoluzione precedente
  useEffect(() => { setResolved(null); }, [placeQuery, date, time]);

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <div className="grid gap-3 md:grid-cols-2">
        <div className="space-y-1">
          <label className="text-xs text-gray-600">Full name</label>
          <input
            className="w-full rounded border px-3 py-2 text-sm"
            placeholder="e.g., Alex Morgan"
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birth date</label>
          <input
            type="date"
            className="w-full rounded border px-3 py-2 text-sm"
            value={date}
            onChange={(e) => setDate(e.target.value)}
          />
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birth time (optional)</label>
          <input
            type="time"
            className="w-full rounded border px-3 py-2 text-sm"
            value={time}
            onChange={(e) => setTime(e.target.value)}
          />
          <p className="text-xs text-gray-500">
            If unknown, weâ€™ll use a solar chart (no houses/ASC).
          </p>
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birthplace</label>
          <div className="flex gap-2">
            <input
              className="flex-1 rounded border px-3 py-2 text-sm"
              placeholder="City, Country"
              value={placeQuery}
              onChange={(e) => setPlaceQuery(e.target.value)}
            />
            <button
              type="button"
              className="rounded border px-3 py-2 text-sm"
              onClick={resolvePlace}
              disabled={!canResolve}
              title="Resolve with Nominatim"
            >
              Resolve
            </button>
          </div>

          {resolved?.ok && resolved.result ? (
            <div className="text-xs text-green-700">
              Resolved: {resolved.result.display_name} ({resolved.result.timezone})
            </div>
          ) : haveSavedPlace ? (
            <div className="text-xs text-gray-600">
              Using saved place: {initial?.place_name || '(unknown)'}
            </div>
          ) : (
            <div className="text-xs text-gray-500">Use Resolve to select a valid place.</div>
          )}
        </div>
      </div>

      <div className="flex items-center gap-2">
        <button
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white disabled:opacity-50"
          onClick={submit}
          disabled={!canSubmit || busy}
        >
          {busy ? 'Savingâ€¦' : 'Save natal chart'}
        </button>
        <button
          type="button"
          className="rounded border px-3 py-2 text-sm"
          onClick={() => window.location.assign('/onboarding#birth')}
        >
          Cancel
        </button>
      </div>

      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}

      <p className="text-xs text-gray-500">
        Wellness/entertainment only; not a substitute for medical, legal, or financial advice.
      </p>
    </div>
  );
}

```


## File: src\components\BirthSection.tsx

```tsx
'use client';

import { useMemo, useState } from 'react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import BirthForm from '@/components/BirthForm';

type Birth = {
  name: string;
  date: string;
  time: string;
  place_name: string;
  lat: number | null;
  lon: number | null;
};

export default function BirthSection({ birth }: { birth: Birth }) {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  // editMode Ã¨ vero se ?edit=birth Ã¨ presente oppure se l'utente ha cliccato Edit.
  const urlWantsEdit = (searchParams.get('edit') ?? '') === 'birth';
  const [localEdit, setLocalEdit] = useState(false);
  const editMode = urlWantsEdit || localEdit || !birth?.date || !birth?.place_name;

  const goEdit = () => {
    // Mantiene hash #birth e forza ?edit=birth (navigazione client â†’ render immediato)
    const sp = new URLSearchParams(searchParams.toString());
    sp.set('edit', 'birth');
    router.replace(`${pathname}?${sp.toString()}#birth`);
    setLocalEdit(true);
  };

  const cancelEdit = () => {
    const sp = new URLSearchParams(searchParams.toString());
    sp.delete('edit');
    router.replace(`${pathname}?${sp.toString()}#birth`);
    setLocalEdit(false);
  };

  const hasSaved = useMemo(() => {
    return !!birth?.date && !!birth?.place_name;
  }, [birth]);

  if (editMode) {
    return (
      <div className="space-y-3">
        <BirthForm
          initial={{
            name: birth?.name ?? '',
            date: birth?.date ?? '',
            time: birth?.time ?? '',
            place_name: birth?.place_name ?? '',
            lat: birth?.lat ?? null,
            lon: birth?.lon ?? null,
          }}
        />
        <button
          type="button"
          onClick={cancelEdit}
          className="rounded border px-3 py-2 text-sm"
        >
          Cancel
        </button>
      </div>
    );
  }

  // Summary view + pulsante Edit SEMPRE visibile
  return (
    <div className="rounded-2xl border p-4 text-sm space-y-2">
      <div className="grid md:grid-cols-2 gap-2">
        <div><span className="text-gray-500">Name:</span> {birth?.name || 'â€”'}</div>
        <div>
          <span className="text-gray-500">Date:</span>{' '}
          {birth?.date ? birth.date : 'â€”'}{' '}
          {birth?.time ? `@ ${birth.time}` : '(solar chart)'}
        </div>
        <div className="md:col-span-2">
          <span className="text-gray-500">Place:</span> {birth?.place_name || 'â€”'}
        </div>
      </div>

      <div className="flex items-center gap-2 pt-2">
        <button
          type="button"
          onClick={goEdit}
          className="rounded border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Edit birth data
        </button>
        {!hasSaved && (
          <span className="text-xs text-red-600">Complete your birth details to compute houses/ASC.</span>
        )}
      </div>

      <p className="text-xs text-gray-500">
        Whole Sign houses if time is provided. You can edit these details anytime.
      </p>
    </div>
  );
}

```
