# Repository Knowledge Base (chunk 0006)


## File: src\lib\houses\placidus.ts

```ts
// src/lib/houses/placidus.ts
// Placidus robusto (MIT): ASC/MC via LST (GMST Meeus 12.4), MC risolto numericamente α(λ)=θ,
// cuspidi 12/11/9/8 su arco corto, opposte 6/5/3/2 per +180°, fallback Whole Sign per |lat|>66.5°.

export type PlacidusResult = {
  system: 'placidus';
  cusps: number[]; // [12] in gradi [0,360)
  asc: number;     // [0,360)
  mc: number;      // [0,360)
};

// ---------------------------- util ----------------------------
const TAU = 2 * Math.PI;
const DEG = Math.PI / 180;

const d2r = (d: number) => d * DEG;
const r2d = (r: number) => r / DEG;
const normRad = (x: number) => ((x % TAU) + TAU) % TAU;
const normDeg = (x: number) => ((x % 360) + 360) % 360;
const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));

/** differenza angolare firmata in radianti, in (-π, +π] */
function angDiff(a: number, b: number): number {
  let d = ((a - b) % TAU + TAU) % TAU;
  if (d > Math.PI) d -= TAU;
  return d;
}

/** percorri l'ARCO PIÙ CORTO da a -> b, parametro t∈[0,1] */
function stepShortest(a: number, b: number, t01: number): number {
  const d = ((b - a + Math.PI) % TAU) - Math.PI; // (-π,π]
  return normRad(a + d * t01);
}

// ----------------------- astronomia di base ----------------------

/** obliquità media (Meeus 22.2) – più che sufficiente per cuspidi/angoli */
function meanObliquityRad(jd: number): number {
  const T = (jd - 2451545.0) / 36525.0;
  const seconds = 21.448 - T * (46.8150 + T * (0.00059 - T * 0.001813));
  const eps0 = 23 + 26 / 60 + (seconds / 3600);
  return d2r(eps0);
}

/** eclittica -> equatoriale (β=0) */
function eclToEq(lambda: number, eps: number): { ra: number; dec: number } {
  const sinλ = Math.sin(lambda);
  const cosλ = Math.cos(lambda);
  const sinE = Math.sin(eps);
  const cosE = Math.cos(eps);

  const sinδ = sinλ * sinE;
  const δ = Math.asin(clamp(sinδ, -1, 1));
  const y = sinλ * cosE;
  const x = cosλ;
  const α = normRad(Math.atan2(y, x));
  return { ra: α, dec: δ };
}

/** RA(λ) per β=0 e sua derivata dα/dλ – utili per Newton */
function raOfLambda(lambda: number, eps: number): number {
  // α = atan2( sinλ cosε, cosλ )
  return normRad(Math.atan2(Math.sin(lambda) * Math.cos(eps), Math.cos(lambda)));
}
function dra_dlambda(lambda: number, eps: number): number {
  // derivata di atan2(y,x) con y=sinλ cosε, x=cosλ:
  // (x*y' - y*x')/(x^2 + y^2) = cosε / (cos^2λ + sin^2λ cos^2ε)
  const sinλ = Math.sin(lambda);
  const cosλ = Math.cos(lambda);
  const cosE = Math.cos(eps);
  const denom = cosλ * cosλ + (sinλ * cosE) * (sinλ * cosE);
  return cosE / denom;
}

/** GMST (Meeus 12.4) in radianti */
function gmstRad(jd: number): number {
  const T = (jd - 2451545.0) / 36525.0;
  const theta = 280.46061837 + 360.98564736629 * (jd - 2451545.0)
            + 0.000387933 * T * T - (T * T * T) / 38710000;
  return d2r(normDeg(theta));
}

/** LST = GMST + longitudine geografica (est +) */
function lstRad(jd: number, lonRad: number): number {
  return normRad(gmstRad(jd) + lonRad);
}

/** semi-arco (H0) per latitudine φ e declinazione δ */
function semiArcRad(phi: number, dec: number): number {
  const X = clamp(-Math.tan(phi) * Math.tan(dec), -1, 1);
  return Math.acos(X); // [0,π]
}

// ---------------------------- angoli principali ----------------------------

/** MC: risolvi numericamente α(λ)=θ (Newton + piccolo fallback) */
function mcLongitudeRad(lst: number, eps: number): number {
  // seed analitico (corretto): λ0 = atan2( sinθ, cosθ cosε )
  let lambda = normRad(Math.atan2(Math.sin(lst), Math.cos(lst) * Math.cos(eps)));

  // Newton – 6 iterazioni bastano largamente (funzione monotona)
  for (let i = 0; i < 6; i++) {
    const f = angDiff(raOfLambda(lambda, eps), lst);
    const df = dra_dlambda(lambda, eps);
    lambda = normRad(lambda - f / df);
  }

  // mini-fallback: rifinisci con due passi di bisezione sull’intorno
  const f0 = (λ: number) => angDiff(raOfLambda(λ, eps), lst);
  const width = d2r(2); // 2°
  const a = normRad(lambda - width); 
  let b = normRad(lambda + width);
  // cammina su arco corto
  for (let i = 0; i < 12; i++) {
    const m = (i + 1) / 12;
    const t = m;
    const fa = f0(stepShortest(a, b, 0));
    const fm = f0(stepShortest(a, b, t));
    if (fa * fm <= 0) { b = stepShortest(a, b, t); break; }
  }
  return lambda;
}

/** Ascendente:
 *  α_ASC = atan2( -cos θ, sin θ * cos ε + tan φ * sin ε )
 *  λ_tmp = ECL(α_ASC) restituisce il DSC; il vero ASC è λ = λ_tmp + π
 */
function ascLongitudeRad(lst: number, lat: number, eps: number): number {
  const sinT = Math.sin(lst);
  const cosT = Math.cos(lst);
  const tanφ = Math.tan(lat);
  const cosE = Math.cos(eps);
  const sinE = Math.sin(eps);

  const y = -cosT;
  const x = sinT * cosE + tanφ * sinE;
  const αasc = Math.atan2(y, x);
  const λtmp = raToLambda(normRad(αasc), eps); // mappa RA→λ in modo coerente
  return normRad(λtmp + Math.PI);
}

/** RA→λ (β=0) coerente con eclToEq: risolve α(λ)=α_target con Newton */
function raToLambda(alpha: number, eps: number): number {
  let λ = normRad(Math.atan2(Math.sin(alpha), Math.cos(alpha) * Math.cos(eps)));
  for (let i = 0; i < 5; i++) {
    const f = angDiff(raOfLambda(λ, eps), alpha);
    const df = dra_dlambda(λ, eps);
    λ = normRad(λ - f / df);
  }
  return λ;
}

// --------------------------- solver su arco corto ---------------------------

/** bisezione robusta sull'ARCO PIÙ CORTO (λA..λB), cercando fn(λ)=0 */
function solveOnShortestArc(
  λA: number,
  λB: number,
  fn: (λ: number) => number,
  maxIter = 50
): number {
  const N = 64; // campionamento per bracketing
  let a = 0, b = 1;
  let fa = fn(stepShortest(λA, λB, a));
  let got = false;

  for (let i = 1; i <= N; i++) {
    const t = i / N;
    const f = fn(stepShortest(λA, λB, t));
    if (fa * f <= 0) { a = (i - 1) / N; b = t; got = true; break; }
    fa = f;
  }
  if (!got) {
    // fallback: punto di minimo |f|
    let bestT = 0, bestAbs = Infinity;
    for (let i = 0; i <= N; i++) {
      const t = i / N;
      const val = Math.abs(fn(stepShortest(λA, λB, t)));
      if (val < bestAbs) { bestAbs = val; bestT = t; }
    }
    return stepShortest(λA, λB, bestT);
  }

  for (let i = 0; i < maxIter; i++) {
    const m = (a + b) / 2;
    const fm = fn(stepShortest(λA, λB, m));
    if (fa * fm <= 0) {
      b = m;
    } else {
      a = m; fa = fm;
    }
  }
  return stepShortest(λA, λB, (a + b) / 2);
}

// --------------------------- cuspidi Placidus ---------------------------

/** Q1 (ASC→MC), H<0 : α = θ + k·H0  → case 12 (k=2/3), 11 (k=1/3) */
function cuspQ1_between_ASC_MC(
  k: number, θ: number, φ: number, ε: number, λasc: number, λmc: number
): number {
  const f = (λ: number) => {
    const { ra, dec } = eclToEq(λ, ε);
    const H0 = semiArcRad(φ, dec);
    const target = θ + k * H0;        // H negativo: α = θ + k·H0
    return angDiff(ra, target);
  };
  return solveOnShortestArc(λasc, λmc, f);
}

/** Q2 (MC→DSC), H>0 : α = θ - k·H0  → case 9 (k=1/3), 8 (k=2/3) */
function cuspQ2_between_MC_DSC(
  k: number, θ: number, φ: number, ε: number, λmc: number, λdsc: number
): number {
  const f = (λ: number) => {
    const { ra, dec } = eclToEq(λ, ε);
    const H0 = semiArcRad(φ, dec);
    const target = θ - k * H0;        // H positivo: α = θ - k·H0
    return angDiff(ra, target);
  };
  return solveOnShortestArc(λmc, λdsc, f);
}

/** Calcola le cuspidi Placidus. */
export function computePlacidusCusps(
  jdUT: number,
  latDeg: number,
  lonDeg: number,
  _tzMinutes?: number   // mantenuto per compat; non serve al calcolo
): PlacidusResult {
  void _tzMinutes;
  const φ = d2r(latDeg);
  const λgeo = d2r(lonDeg);
  const ε = meanObliquityRad(jdUT);

  // Fallback per lat estreme
  if (Math.abs(latDeg) > 66.5) {
    const θ = lstRad(jdUT, λgeo);
    const λascWS = ascLongitudeRad(θ, φ, ε);
    const λmcWS  = mcLongitudeRad(θ, ε);
    const ascDeg = normDeg(r2d(λascWS));
    const cuspsWS = Array.from({ length: 12 }, (_, i) => normDeg(ascDeg + i * 30));
    return { system: 'placidus', cusps: cuspsWS, asc: ascDeg, mc: normDeg(r2d(λmcWS)) };
  }

  // LST e angoli principali
  const θ = lstRad(jdUT, λgeo);
  const λmc = mcLongitudeRad(θ, ε);           // ora risolto numericamente
  const λasc = ascLongitudeRad(θ, φ, ε);
  const λdsc = normRad(λasc + Math.PI);
  const λic  = normRad(λmc + Math.PI);

  // Cuspidi temporali
  const λ12 = cuspQ1_between_ASC_MC(2 / 3, θ, φ, ε, λasc, λmc);
  const λ11 = cuspQ1_between_ASC_MC(1 / 3, θ, φ, ε, λasc, λmc);
  const λ9  = cuspQ2_between_MC_DSC(1 / 3,  θ, φ, ε, λmc, λdsc);
  const λ8  = cuspQ2_between_MC_DSC(2 / 3,  θ, φ, ε, λmc, λdsc);

  // Opposte
  const λ6 = normRad(λ12 + Math.PI);
  const λ5 = normRad(λ11 + Math.PI);
  const λ3 = normRad(λ9  + Math.PI);
  const λ2 = normRad(λ8  + Math.PI);

  // Ordine 1..12
  const cuspsRad = [λasc, λ2, λ3, λic, λ5, λ6, λdsc, λ8, λ9, λmc, λ11, λ12];
  const cusps = cuspsRad.map(v => normDeg(r2d(v)));

  return { system: 'placidus', cusps, asc: normDeg(r2d(λasc)), mc: normDeg(r2d(λmc)) };
}

/** Assegna la casa (1..12) ad una longitudine λ data la lista di cuspidi 1..12 */
export function assignHouses(longitudeDeg: number, cusps: number[]): number {
  const λ = normDeg(longitudeDeg);
  if (!Array.isArray(cusps) || cusps.length !== 12) return 1;

  // Ordine geometrico CW a partire dalla cuspide 1
  const ordered: number[] = [0];
  for (let step = 0; step < 11; step++) {
    const i = ordered[ordered.length - 1];
    let bestJ = i, bestΔ = 361;
    for (let k = 0; k < 12; k++) {
      if (k === i) continue;
      const d = normDeg(cusps[k] - cusps[i]); // CW in gradi
      if (d > 0 && d < bestΔ) { bestΔ = d; bestJ = k; }
    }
    ordered.push(bestJ);
  }

  // Trova il settore CW [start..end) che contiene λ
  for (let j = 0; j < 12; j++) {
    const i = ordered[j];
    const n = ordered[(j + 1) % 12];
    const start = cusps[i];
    const end = cusps[n];
    const arc = normDeg(end - start);
    const dλ = normDeg(λ - start);
    if (dλ >= 0 && dλ < arc) return j + 1;
  }
  return 12;
}

```


## File: src\lib\houses\runtime.ts

```ts
// src/lib/houses/runtime.ts
import { computeHouses } from '@/lib/astro';

export type HouseSystem = 'whole' | 'placidus';

export function jdFromUTC(dateUTC: Date): number {
  // JD = 2440587.5 + msUTC/86400000
  return 2440587.5 + dateUTC.getTime() / 86400000;
}

/**
 * Calcola runtime le cuspidi case per una data UTC e coordinate geografiche.
 * Nessuna persistenza su DB.
 */
export function computeHousesForDateUTC(params: {
  system: HouseSystem;
  dateUTC: Date;          // data/ora in UTC
  latDeg: number;
  lonDeg: number;
}): { cusps: number[]; asc: number; mc: number; system: HouseSystem; fallbackApplied: boolean } {
  const { system, dateUTC, latDeg, lonDeg } = params;
  const jd = jdFromUTC(dateUTC);
  // tzMinutes non serve al calcolo case (si usa JD UT); lo forniamo per compatibilità con la firma
  const res = computeHouses(system, { jd, latDeg, lonDeg, tzMinutes: 0 });

  // Se Placidus e latitudine estrema, la nostra implementazione fa fallback a Whole Sign:
  const fallbackApplied = system === 'placidus' && Math.abs(latDeg) > 66.5;

  return {
    cusps: res.cusps,
    asc: res.asc,
    mc: res.mc,
    system,
    fallbackApplied,
  };
}

// append to: src/lib/houses/runtime.ts
import { DateTime } from 'luxon';

export async function computePersonHousesForUserSystem(params: {
  person: {
    birth_date: string;           // YYYY-MM-DD
    birth_time?: string | null;   // HH:MM
    tz_offset_minutes?: number | null;
    lat: number;
    lon: number;
  };
  userHouseSystem: HouseSystem;   // 'whole' | 'placidus'
}) {
  const { person, userHouseSystem } = params;
  if (!person?.birth_date || person.lat == null || person.lon == null) {
    return { system: userHouseSystem, cusps: undefined, asc: undefined, mc: undefined, fallbackApplied: false };
  }
  const hhmm = person.birth_time ?? '12:00';
  const off = person.tz_offset_minutes ?? 0;

  const local = DateTime.fromISO(`${person.birth_date}T${hhmm}:00`, { zone: 'UTC' }).toJSDate();
  // correggo l'UTC applicando l'offset (minuti) memorizzato
  const dateUTC = new Date(local.getTime() - off * 60_000);

  const res = computeHousesForDateUTC({
    system: userHouseSystem,
    dateUTC,
    latDeg: person.lat,
    lonDeg: person.lon,
  });
  return res;
}

```


## File: src\lib\houses\whole.ts

```ts
// src/lib/houses/whole.ts
// Cuspidi Whole Sign a partire dall'ASC e MC (entrambi gradi eclittici).

import { normalizeAngle } from './common';

export type WholeResult = {
  system: 'whole';
  cusps: number[]; // 12 valori: I..XII
  asc: number;
  mc: number;
  fallbackApplied?: boolean;
};

/** Cuspidi Whole Sign: cusp I = inizio del segno dell'ASC, poi ogni 30°. */
export function computeWholeCuspsFromAsc(ascDeg: number, mcDeg: number): WholeResult {
  const ascSignStart = Math.floor(normalizeAngle(ascDeg) / 30) * 30;
  const cusps = Array.from({ length: 12 }, (_, i) => normalizeAngle(ascSignStart + i * 30));
  return {
    system: 'whole',
    cusps,
    asc: normalizeAngle(ascDeg),
    mc: normalizeAngle(mcDeg),
  };
}

```


## File: src\lib\openai.ts

```ts
// src/lib/openai.ts
type ChatRole = 'system' | 'user' | 'assistant';

export type ChatMessage = { role: ChatRole; content: string };

function getModel(envName: 'OPENAI_MODEL_CHAT' | 'OPENAI_MODEL_REFINER', fallback: string): string {
  const m = process.env[envName];
  return (m && m.trim().length > 0) ? m : fallback;
}

export async function chatComplete(messages: ChatMessage[], useRefiner = false): Promise<string> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error('Missing OPENAI_API_KEY');
  }

  const model = useRefiner
    ? getModel('OPENAI_MODEL_REFINER', 'gpt-4o-mini')
    : getModel('OPENAI_MODEL_CHAT', 'gpt-4o-mini');

  const body = {
    model,
    messages,
    temperature: 0.8,
    top_p: 1,
  };

  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(`OpenAI error ${res.status}: ${txt}`);
  }
  const data: unknown = await res.json();
  // type guard minimale
  const msg = (data as { choices?: Array<{ message?: { content?: string } }> })?.choices?.[0]?.message?.content;
  if (typeof msg !== 'string' || msg.length === 0) {
    throw new Error('OpenAI returned empty message');
  }
  return msg.trim();
}

```


## File: src\lib\planets\runtime.ts

```ts
// src/lib/planets/runtime.ts
import { Body, AstroTime, GeoVector, Ecliptic } from 'astronomy-engine';

export type RuntimePointName =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';

export type RuntimePoint = {
  name: RuntimePointName;
  longitude: number; // gradi 0..360
  sign: string;      // "Aries", ...
  retro: boolean;
};

const BODY_MAP: { name: RuntimePointName; body: Body }[] = [
  { name: 'Sun',     body: Body.Sun },
  { name: 'Moon',    body: Body.Moon },
  { name: 'Mercury', body: Body.Mercury },
  { name: 'Venus',   body: Body.Venus },
  { name: 'Mars',    body: Body.Mars },
  { name: 'Jupiter', body: Body.Jupiter },
  { name: 'Saturn',  body: Body.Saturn },
  { name: 'Uranus',  body: Body.Uranus },
  { name: 'Neptune', body: Body.Neptune },
  { name: 'Pluto',   body: Body.Pluto },
];

function normDeg(x: number): number { return ((x % 360) + 360) % 360; }

function signedDeltaDeg(a: number, b: number): number {
  // ritorna a-b in (-180, +180]
  let d = a - b;
  if (d > 180) d -= 360;
  if (d <= -180) d += 360;
  return d;
}

function signFromLongitude(lon: number): string {
  const SIGNS = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  const idx = Math.floor(normDeg(lon) / 30) % 12;
  return SIGNS[idx];
}

/** Calcola i pianeti per una certa data UTC (geocentric, ecliptic of-date). */
export function computeDailyPlanets(dateUTC: Date): RuntimePoint[] {
  const tNow  = new AstroTime(dateUTC);
  const tPrev = new AstroTime(new Date(dateUTC.getTime() - 86400000)); // -1 giorno

  return BODY_MAP.map(({ name, body }): RuntimePoint => {
    const vNow  = GeoVector(body, tNow, /*aberration*/ true);
    const eNow  = Ecliptic(vNow); // {elon, elat, dist}
    const lonNow = normDeg(eNow.elon);

    const vPrev  = GeoVector(body, tPrev, true);
    const ePrev  = Ecliptic(vPrev);
    const lonPrev = normDeg(ePrev.elon);

    const retro = signedDeltaDeg(lonNow, lonPrev) < 0;

    return {
      name,
      longitude: lonNow,
      sign: signFromLongitude(lonNow),
      retro,
    };
  });
}

export function computePlanetsAtUTC(dateUTC: Date): RuntimePoint[] {
  return computeDailyPlanets(dateUTC);
}

// --- add aliases/types for consumers ---
export type RuntimePlanet = { name: string; longitude: number; retro?: boolean };
```


## File: src\lib\supabase.ts

```ts
import { createClient } from '@supabase/supabase-js'


const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!


export const supabase = createClient(supabaseUrl, supabaseAnonKey)
```


## File: src\lib\supabaseAdmin.ts

```ts
import { createClient } from '@supabase/supabase-js';


const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;


export const supabaseAdmin = createClient(url, serviceKey, {
auth: { autoRefreshToken: false, persistSession: false }
});
```


## File: src\lib\supabaseBrowser.ts

```ts
// src/lib/supabaseBrowser.ts
import { createClient } from '@supabase/supabase-js';

export function createSupabaseBrowser() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
  return createClient(url, anon, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
  });
}

```


## File: src\lib\supabaseServer.ts

```ts
// src/lib/supabaseServer.ts
import { cookies } from 'next/headers';
import { createServerClient, type CookieOptions } from '@supabase/ssr';

function getSupabaseUrlAndKey() {
  const url =
    process.env.NEXT_PUBLIC_SUPABASE_URL ||
    process.env.SUPABASE_URL ||
    '';
  const anon =
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||
    process.env.SUPABASE_ANON_KEY ||
    '';
  if (!url || !anon) {
    throw new Error(
      "Your project's URL and Key are required to create a Supabase client!\n" +
      'Set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in .env.local'
    );
  }
  return { url, anon };
}

/** Da usare in Server Components (RSC): NESSUNA mutazione cookie */
export function createSupabaseServerComponentClient() {
  const cookieStore = cookies();
  const { url, anon } = getSupabaseUrlAndKey();

  return createServerClient(url, anon, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      // set/remove NON disponibili in RSC: no-op per evitare errori
      set() {},
      remove() {},
    },
  });
}

/** Da usare SOLO in Route Handlers / Server Actions: può mutare cookie */
export function createSupabaseServerRouteClient() {
  const cookieStore = cookies();
  const { url, anon } = getSupabaseUrlAndKey();

  return createServerClient(url, anon, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      set(name: string, value: string, options: CookieOptions) {
        cookieStore.set({ name, value, ...options });
      },
      remove(name: string, options: CookieOptions) {
        cookieStore.set({ name, value: '', ...options });
      },
    },
  });
}

```


## File: src\lib\synastry.ts

```ts
// src/lib/synastry.ts
import { normalizeDeg, type AspectType, type PointName } from '@/lib/astro';

export type NatalPointLite = { name: PointName; longitude: number };

export type SynAspect = {
  a_point: PointName;
  b_point: PointName;
  aspect: AspectType;
  orb: number;   // degrees
  score: number; // 0..1
};

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang'; // ASC/MC
}

function maxOrb(p1: PointName, p2: PointName): number {
  const c1 = classOfPoint(p1);
  const c2 = classOfPoint(p2);
  if (c1 === 'lum' || c2 === 'lum') return 6;
  if (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function pointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeSynastryAspects(a: NatalPointLite[], b: NatalPointLite[]): SynAspect[] {
  const res: SynAspect[] = [];
  const aspects: AspectType[] = ['conjunction','sextile','square','trine','opposition'];
  for (const A of a) {
    for (const B of b) {
      const d = minAngle(A.longitude, B.longitude);
      let best: { asp: AspectType; diff: number } | null = null;
      for (const asp of aspects) {
        const diff = Math.abs(d - ASPECT_DEGREES[asp]);
        if (!best || diff < best.diff) best = { asp, diff };
      }
      if (!best) continue;
      const max = maxOrb(A.name, B.name);
      if (best.diff <= max) {
        const score = aspectWeight(best.asp) * pointWeight(A.name) * pointWeight(B.name);
        res.push({
          a_point: A.name,
          b_point: B.name,
          aspect: best.asp,
          orb: +best.diff.toFixed(2),
          score: +score.toFixed(3),
        });
      }
    }
  }
  res.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return res;
}

export function formatSynastryContext(top: SynAspect[], labelA: string, labelB: string): string {
  const lines = top.map(s =>
    `${labelA}:${s.a_point} ${s.aspect} ${labelB}:${s.b_point} (orb ${s.orb}°, score ${Math.round(s.score*100)})`
  );
  return `CONTEXT_SYNASTRY\n${lines.join('\n')}`;
}

```


## File: src\lib\synastry\aspects.ts

```ts
// src/lib/synastry/aspects.ts
import { wrapDeg } from '@/lib/graphics/polar';
import type { PlanetName } from '@/lib/graphics/glyphs';

export type AspectName =
  | 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile'
  | 'quincunx' | 'semi-sextile';

export type ChartPoint = {
  name: PlanetName | 'ASC' | 'MC';
  lon: number;        // 0..360
  retro?: boolean;
};

export type SynastryAspect = {
  a: { owner: 'user' | 'person'; name: ChartPoint['name']; lon: number };
  b: { owner: 'user' | 'person'; name: ChartPoint['name']; lon: number };
  aspect: AspectName;
  exact: number;      // 0,60,90,120,150,180
  orb: number;        // |delta| in gradi
  applying: boolean;  // stima (runtime)
  score: number;      // 0..1
};

const ASPECT_DEG: Record<AspectName, number> = {
  conjunction: 0, sextile: 60, square: 90, trine: 120,
  quincunx: 150, opposition: 180, 'semi-sextile': 30,
};

// orbi massimi (luminari > personali/angoli > sociali > lenti)
function classOf(p: ChartPoint['name']) {
  if (p === 'Sun' || p === 'Moon') return 'lum';
  if (p === 'Mercury' || p === 'Venus' || p === 'Mars') return 'pers';
  if (p === 'Jupiter' || p === 'Saturn') return 'soc';
  if (p === 'Uranus' || p === 'Neptune' || p === 'Pluto') return 'out';
  return 'ang';
}
function maxOrb(p1: ChartPoint['name'], p2: ChartPoint['name'], a: AspectName): number {
  const c1 = classOf(p1), c2 = classOf(p2);
  const base =
    (c1 === 'lum' || c2 === 'lum') ? 8 :
    (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') ? 6 :
    4;
  // aspetti minori: orb leggermente ridotto
  if (a === 'quincunx' || a === 'semi-sextile') return Math.max(2, base - 2);
  return base;
}

function minAngle(a: number, b: number): number {
  const raw = Math.abs(wrapDeg(a - b));
  return raw > 180 ? 360 - raw : raw;
}

// stima velocità giornaliera media (deg/giorno) per applicare applying/separating
const MEAN_SPEED: Partial<Record<PlanetName | 'ASC' | 'MC', number>> = {
  Sun: 0.9856, Moon: 13.176, Mercury: 1.2, Venus: 1.2, Mars: 0.5,
  Jupiter: 0.083, Saturn: 0.033, Uranus: 0.012, Neptune: 0.006, Pluto: 0.004,
  ASC: 0, MC: 0,
};
function isApplying(a: ChartPoint, b: ChartPoint, aspectExact: number): boolean {
  // prende il "più veloce" come riferimento
  const va = MEAN_SPEED[a.name as PlanetName] ?? 0;
  const vb = MEAN_SPEED[b.name as PlanetName] ?? 0;
  const fast = va >= vb ? a : b;
  // Se il veloce è "prima" dell'esatto muovendosi in avanti → applying
  // target = long dell'altro +/- aspectExact (quello più vicino)
  const target1 = wrapDeg((b.lon + aspectExact));
  const target2 = wrapDeg((b.lon - aspectExact));
  const d1 = minAngle(fast.lon, target1);
  const d2 = minAngle(fast.lon, target2);
  const target = d1 <= d2 ? target1 : target2;
  const delta = wrapDeg(target - fast.lon); // quanto manca muovendosi avanti
  return delta < 180; // se "davanti" nel senso diretto → applica
}

function aspectWeight(a: AspectName): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.78;
    case 'quincunx':    return 0.55;
    case 'semi-sextile':return 0.50;
  }
}
function pointWeight(p: ChartPoint['name']): number {
  switch (classOf(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export type ComputeOpts = {
  includeMinor?: boolean;
  topN?: number;
};

export function computeSynastryAspects(
  userPoints: ChartPoint[],
  personPoints: ChartPoint[],
  opts: ComputeOpts = {}
): SynastryAspect[] {
  const aspects: AspectName[] = opts.includeMinor
    ? ['conjunction','semi-sextile','sextile','square','trine','quincunx','opposition']
    : ['conjunction','sextile','square','trine','opposition'];

  const res: SynastryAspect[] = [];
  for (const ua of userPoints) {
    for (const pb of personPoints) {
      const d = minAngle(ua.lon, pb.lon);

      // individua l'aspetto più vicino
      let best: { a: AspectName; exact: number; diff: number } | null = null;
      for (const a of aspects) {
        const exact = ASPECT_DEG[a];
        const diff = Math.abs(d - exact);
        if (!best || diff < best.diff) best = { a, exact, diff };
      }
      if (!best) continue;

      const orbMax = maxOrb(ua.name, pb.name, best.a);
      if (best.diff <= orbMax) {
        const applying = isApplying(ua, pb, best.exact);
        const score =
          aspectWeight(best.a) * pointWeight(ua.name) * pointWeight(pb.name) * (1 - best.diff / orbMax);

        res.push({
          a: { owner: 'user', name: ua.name, lon: ua.lon },
          b: { owner: 'person', name: pb.name, lon: pb.lon },
          aspect: best.a,
          exact: best.exact,
          orb: Number(best.diff.toFixed(2)),
          applying,
          score: Number(score.toFixed(3)),
        });
      }
    }
  }

  res.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return typeof opts.topN === 'number' ? res.slice(0, opts.topN) : res;
}

// Helper per chatbot: stringa sintetica
export function formatSynastryContext(rows: SynastryAspect[], top = 10): string {
  const lines = (rows.slice(0, top)).map(r =>
    `${r.a.name}(${r.a.owner[0]}) ${r.aspect} ${r.b.name}(${r.b.owner[0]}) orb ${r.orb}° score ${r.score}`
  );
  return lines.length ? `CONTEXT_SYNASTRY\n${lines.join('\n')}` : '';
}

```


## File: src\lib\time.ts

```ts
// src/lib/time.ts
import { DateTime } from 'luxon';

export function getDefaultTZ(): string {
  return process.env.DEFAULT_TZ || 'UTC';
}

export function todayISOInTZ(tz?: string): string {
  const zone = tz || getDefaultTZ();
  return DateTime.now().setZone(zone).toFormat('yyyy-LL-dd'); // YYYY-MM-DD
}

export function nowInfo(tz?: string) {
  const zone = tz || getDefaultTZ();
  const dt = DateTime.now().setZone(zone);
  return {
    tz: zone,
    now_iso: dt.toISO(),
    now_human: dt.toFormat('cccc, dd LLL yyyy HH:mm'),
    utc_offset_minutes: dt.offset, // es. +120 per CEST
  };
}

```


## File: src\lib\time\resolveTz.ts

```ts
// src/lib/time/resolveTz.ts
// Helper server-side: dato (lat, lon, data locale, ora locale) risolve la timezone IANA
// e calcola l'offset (in minuti) valido in quel momento (gestisce automaticamente il DST).
//
// Dipendenze: luxon, tz-lookup
//   npm i tz-lookup
//
// Uso tipico:
//   const { tz_name, offset_minutes } = resolveTimezoneForLocalMoment(lat, lon, "1988-01-31", "12:34");

import { DateTime } from 'luxon';
import tzlookup from 'tz-lookup';

export type ResolvedTz = {
  tz_name: string;         // es. "Europe/Rome"
  offset_minutes: number;  // minuti da UTC, es. 60 o 120 a seconda del DST
};

export function resolveTimezoneForLocalMoment(
  lat: number,
  lon: number,
  dateISO: string,  // "YYYY-MM-DD"
  timeHHMM: string  // "HH:MM" (ora locale)
): ResolvedTz {
  // 1) timezone IANA dal punto geografico
  const tz_name = tzlookup(lat, lon);

  // 2) offset specifico di QUELLA data/ora locale (DST incluso)
  //    Luxon usa i dati tzdb della IANA per calcolare l'offset corretto.
  const dtLocal = DateTime.fromISO(`${dateISO}T${timeHHMM}`, { zone: tz_name });
  const offset_minutes = dtLocal.offset; // minuti (int)

  return { tz_name, offset_minutes };
}

```


## File: src\lib\transitContext.ts

```ts
// src/lib/transitContext.ts
import {
  computeTransitEventsForDay,
  type TransitEventCalc,
  type TransitLongitude, // deve essere esportato da '@/lib/transits'
} from '@/lib/transits';

export interface ComposeTransitContextArgs {
  user_id: string;
  dateUTC: string; // ISO, es. "2025-09-30"
  natalPoints: {
    id: string;     // "Sun", "ASC", ecc. (gli angoli verranno filtrati)
    name: string;   // nome del punto
    lonDeg: number; // [0..360)
  }[];
}

/** Ricavo il tipo del nome richiesto da TransitLongitude (es. BodyName) senza importarlo esplicitamente */
type TLName = TransitLongitude['name'];

/** Lista chiusa di corpi ammessi per i transiti (esclude ASC/MC). Aggiungi qui eventuali altri (Chiron, TrueNode, ecc.) */
const BODY_NAMES = [
  'Sun','Moon','Mercury','Venus','Mars','Jupiter','Saturn','Uranus','Neptune','Pluto',
] as const satisfies readonly TLName[];

/** Type guard: da string a TLName */
function isTLName(x: string): x is TLName {
  return (BODY_NAMES as readonly string[]).includes(x);
}

/** Wrapper che forza l'overload con TransitLongitude[] */
type ComputeWithTL = (userId: string, natal: TransitLongitude[], dateUTC: string) => Promise<TransitEventCalc[]>;
const computeWithTL = computeTransitEventsForDay as unknown as ComputeWithTL;

export async function composeTransitContext(
  { user_id, dateUTC, natalPoints }: ComposeTransitContextArgs
): Promise<{ events: TransitEventCalc[]; note: string }> {

  // Costruisco TransitLongitude[] perfettamente tipato (name: TLName)
  const natalTL: TransitLongitude[] = natalPoints
    .filter(p => isTLName(p.name))          // filtra fuori ASC/MC e punti non planetari
    .map(p => ({
      name: p.name as TLName,               // ora è compatibile
      longitude: p.lonDeg,
    }));

  // Chiamo la funzione core usando esplicitamente l’overload tipizzato con TL[]
  const events = await computeWithTL(user_id, natalTL, dateUTC);

  return {
    events,
    note: `Context computed at runtime for ${dateUTC} (no DB persistence).`,
  };
}
```


## File: src\lib\transits.ts

```ts
// src/lib/transits.ts
import * as Astronomy from 'astronomy-engine';
import {
  type BodyName,
  type PointName,
  type AspectType,
  normalizeDeg,
} from '@/lib/astro';

export type TransitLongitude = {
  name: BodyName;
  longitude: number; // 0..360
};

export type NatalPointLite = {
  name: PointName;
  longitude: number;
};

export type TransitEventCalc = {
  date: string;         // YYYY-MM-DD (UTC day)
  t_planet: BodyName;   // transiting planet
  n_point: PointName;   // natal planet/angle
  aspect: AspectType;   // conj/sxt/sqr/trn/opp
  orb: number;          // degrees (0..maxOrb)
  score: number;        // 0..1
};

const TRANSIT_PLANETS: BodyName[] = [
  'Sun', 'Moon', 'Mercury', 'Venus', 'Mars',
  'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto',
];

const BODY_ENUM: Record<BodyName, Astronomy.Body> = {
  Sun: Astronomy.Body.Sun,
  Moon: Astronomy.Body.Moon,
  Mercury: Astronomy.Body.Mercury,
  Venus: Astronomy.Body.Venus,
  Mars: Astronomy.Body.Mars,
  Jupiter: Astronomy.Body.Jupiter,
  Saturn: Astronomy.Body.Saturn,
  Uranus: Astronomy.Body.Uranus,
  Neptune: Astronomy.Body.Neptune,
  Pluto: Astronomy.Body.Pluto,
};

function rad(d: number): number { return (d * Math.PI) / 180; }
function deg(r: number): number { return (r * 180) / Math.PI; }

const OBLIQUITY = (23.4392911 * Math.PI) / 180;

function eclipticFromEquatorial(eq: Astronomy.EquatorialCoordinates): { elon: number } {
  // RA in ore → gradi
  const raDeg = eq.ra * 15;
  const decDeg = eq.dec;
  const ra = rad(raDeg);
  const dec = rad(decDeg);
  const sinE = Math.sin(OBLIQUITY);
  const cosE = Math.cos(OBLIQUITY);
  const sinRa = Math.sin(ra);
  const cosRa = Math.cos(ra);
  const y = sinRa * cosE + Math.tan(dec) * sinE;
  const x = cosRa;
  const elon = Math.atan2(y, x);
  return { elon: normalizeDeg(deg(elon)) };
}

function geocentricEclLongitude(body: Astronomy.Body, when: Date): number {
  const vec = Astronomy.GeoVector(body, when, true);
  const eq  = Astronomy.EquatorFromVector(vec);
  return eclipticFromEquatorial(eq).elon;
}

export function utNoon(dateIso: string): Date {
  const [y, m, d] = dateIso.split('-').map((s) => Number(s));
  return new Date(Date.UTC(y, (m - 1), d, 12, 0, 0)); // 12:00 UTC
}

export function computeTransitingLongitudes(dateIso: string): TransitLongitude[] {
  const when = utNoon(dateIso);
  return TRANSIT_PLANETS.map((p) => ({
    name: p,
    longitude: geocentricEclLongitude(BODY_ENUM[p], when),
  }));
}

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang';
}

// MVP guideline orbs: 6° luminari, 5° personali/angoli, 3° lenti
export function maxOrbForPair(transiting: BodyName, natal: PointName): number {
  const cT = classOfPoint(transiting);
  const cN = classOfPoint(natal);
  if (cT === 'lum' || cN === 'lum') return 6;
  if (cT === 'pers' || cN === 'pers' || cN === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function transitPlanetWeight(p: BodyName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 0.85;  // per non far dominare la Luna
    case 'pers': return 0.90;
    case 'soc': return 0.95;
    case 'out': return 1.00;  // lenti più “pesanti”
    case 'ang': return 0.95;
  }
}

function natalPointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeTransitEventsForDay(
  dateIso: string,
  transits: TransitLongitude[],
  natalPoints: NatalPointLite[]
): TransitEventCalc[] {
  const events: TransitEventCalc[] = [];
  const aspects: AspectType[] = ['conjunction', 'sextile', 'square', 'trine', 'opposition'];

  for (const t of transits) {
    for (const n of natalPoints) {
      const d = minAngle(t.longitude, n.longitude);
      // aspetto più vicino
      let best: { a: AspectType; diff: number } | null = null;
      for (const a of aspects) {
        const ad = ASPECT_DEGREES[a];
        const diff = Math.abs(d - ad);
        if (best === null || diff < best.diff) best = { a, diff };
      }
      if (!best) continue;

      const maxOrb = maxOrbForPair(t.name, n.name);
      if (best.diff <= maxOrb) {
        const score =
          aspectWeight(best.a) *
          transitPlanetWeight(t.name) *
          natalPointWeight(n.name);

        events.push({
          date: dateIso,
          t_planet: t.name,
          n_point: n.name,
          aspect: best.a,
          orb: Number(best.diff.toFixed(2)),
          score: Number(score.toFixed(3)),
        });
      }
    }
  }

  // ordina per score desc, poi orb asc
  events.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return events;
}

```


## File: src\lib\transits\adjacency.ts

```ts
// src/lib/transits/adjacency.ts
/* Pure helpers per aspetti/hover. Nessuna dipendenza dal DB. */

export type AspectType = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

export interface AspectEdge {
  id: string;        // es: "t:Uranus__n:Sun__trine"
  aId: string;       // es: "t:Uranus"
  bId: string;       // es: "n:Sun"
  type: AspectType;
  orbDeg: number;    // valore assoluto (>= 0)
}

export interface Adjacency {
  P: Map<string, Set<string>>;         // planetId -> set(planetId collegati)
  E: Map<string, [string, string]>;    // edgeId   -> [aId, bId]
}

/** Normalizza un angolo in [0,360) */
export function norm360(deg: number): number {
  let x = deg % 360;
  if (x < 0) x += 360;
  return x;
}

/** Distanza angolare minima in [0,180] tra due direzioni in gradi */
export function angularSeparation(a: number, b: number): number {
  const d = Math.abs(norm360(a) - norm360(b)) % 360;
  return d > 180 ? 360 - d : d;
}

/** Restituisce l'angolo teorico dell'aspetto (0, 60, 90, 120, 180) */
export function aspectExactAngle(t: AspectType): number {
  switch (t) {
    case 'conjunction': return 0;
    case 'sextile':     return 60;
    case 'square':      return 90;
    case 'trine':       return 120;
    case 'opposition':  return 180;
  }
}

/** true se la separazione è entro l'orb (inclusivo) rispetto al target dell'aspetto */
export function isAspectMatch(sepDeg: number, type: AspectType, maxOrbDeg: number): boolean {
  const target = aspectExactAngle(type);
  const diff = Math.abs(sepDeg - target);
  return diff <= maxOrbDeg;
}

/** Crea la mappa di adiacenza per highlight veloci e deterministici */
export function buildAdjacencyMap(aspects: AspectEdge[]): Adjacency {
  const P = new Map<string, Set<string>>();
  const E = new Map<string, [string, string]>();
  for (const x of aspects) {
    if (!P.has(x.aId)) P.set(x.aId, new Set());
    if (!P.has(x.bId)) P.set(x.bId, new Set());
    P.get(x.aId)!.add(x.bId);
    P.get(x.bId)!.add(x.aId);
    E.set(x.id, [x.aId, x.bId]);
  }
  return { P, E };
}
```


## File: src\lib\utils.ts

```ts
// FILE: src/lib/utils.ts
export function cn(...values: Array<string | false | null | undefined>): string {
  return values.filter(Boolean).join(" ");
}

```


## File: src\types\tz-lookup.d.ts

```ts
﻿declare module 'tz-lookup' {
  export default function tzLookup(lat: number, lon: number): string;
}

```


## File: supabase\migrations\0001_init.sql

```sql
-- Enable useful extensions
id bigserial primary key,
session_id uuid not null references public.chat_sessions(id) on delete cascade,
role text not null check (role in ('user','assistant','system')),
content text not null,
created_at timestamptz not null default now()
);
create index if not exists idx_chat_messages_session on public.chat_messages(session_id);


-- RLS
alter table public.users enable row level security;
alter table public.birth_data enable row level security;
alter table public.chart_points enable row level security;
alter table public.natal_aspects enable row level security;
alter table public.transit_events enable row level security;
alter table public.interpretations enable row level security;
alter table public.chat_sessions enable row level security;
alter table public.chat_messages enable row level security;


-- policies: users (owner read/update)
create policy users_select_own on public.users
for select using (id = auth.uid());
create policy users_update_own on public.users
for update using (id = auth.uid()) with check (id = auth.uid());
-- no insert/delete by clients


-- policies: tables with user_id (owner-only full access)
create policy bd_rw_own on public.birth_data
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cp_rw_own on public.chart_points
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy na_rw_own on public.natal_aspects
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy te_rw_own on public.transit_events
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cs_rw_own on public.chat_sessions
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cm_read_by_session on public.chat_messages
for select using (exists (
select 1 from public.chat_sessions s
where s.id = chat_messages.session_id and s.user_id = auth.uid()
));
create policy cm_write_by_session on public.chat_messages
for insert with check (exists (
select 1 from public.chat_sessions s
where s.id = chat_messages.session_id and s.user_id = auth.uid()
));


-- interpretations: readable by anyone, writable only with service role
create policy interp_public_read on public.interpretations
for select using (true);
-- (no insert/update/delete policy for anon/auth; use service role key in server routes)
```


## File: supabase\migrations\0002_people_synastry.sql

```sql
-- 0002_people_synastry.sql
-- Tabelle per persone (contatti) e relativi dati astrologici


create table if not exists public.people (
id uuid primary key default gen_random_uuid(),
user_id uuid not null references public.users(id) on delete cascade,
label text not null, -- es. "papà", "collega 1"
birth_date date not null,
birth_time text, -- HH:MM opzionale
birth_tz_name text, -- es. Europe/Rome
birth_tz_offset_minutes int, -- comodo per storicizzare
birth_place_name text,
birth_lat double precision,
birth_lon double precision,
current_place_name text, -- opzionale: dove si trova ora
current_lat double precision,
current_lon double precision,
current_tz_name text,
created_at timestamptz not null default now(),
updated_at timestamptz not null default now()
);


create table if not exists public.people_chart_points (
id bigserial primary key,
person_id uuid not null references public.people(id) on delete cascade,
name text not null, -- Sun, Moon, Mercury, ... ASC, MC
longitude double precision not null,
sign text not null,
house int,
retro boolean default false
);


create table if not exists public.people_natal_aspects (
id bigserial primary key,
person_id uuid not null references public.people(id) on delete cascade,
p1 text not null,
p2 text not null,
aspect text not null, -- conjunction|sextile|square|trine|opposition
orb double precision not null,
strength int not null
);


-- RLS
alter table public.people enable row level security;
alter table public.people_chart_points enable row level security;
alter table public.people_natal_aspects enable row level security;


create policy people_rw_own on public.people
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy ppl_points_rw_own on public.people_chart_points
for all using (person_id in (select id from public.people where user_id = auth.uid()))
with check (person_id in (select id from public.people where user_id = auth.uid()));


create policy ppl_aspects_rw_own on public.people_natal_aspects
for all using (person_id in (select id from public.people where user_id = auth.uid()))
with check (person_id in (select id from public.people where user_id = auth.uid()));
```


## File: supabase\migrations\2025-09-17_add_user_prefs.sql

```sql
-- 2025-09-17_add_user_prefs.sql
create table if not exists public.user_prefs (
  user_id uuid primary key references public.users(id) on delete cascade,
  current_place_name text,
  current_lat double precision,
  current_lon double precision,
  current_tz_name text,
  focus jsonb default '[]'::jsonb, -- es. ["work","relationships"]
  updated_at timestamptz default now()
);

alter table public.user_prefs enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_prefs' and policyname='user_prefs_select_own'
  ) then
    create policy user_prefs_select_own
      on public.user_prefs for select
      using (auth.uid() = user_id);
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_prefs' and policyname='user_prefs_upsert_own'
  ) then
    create policy user_prefs_upsert_own
      on public.user_prefs for insert with check (auth.uid() = user_id);
    create policy user_prefs_update_own
      on public.user_prefs for update using (auth.uid() = user_id);
  end if;
end$$;

```


## File: supabase\seed\interpretations_seed.sql

```sql
-- Minimal seed: 48 schede (12 Sun in sign, 12 Moon in house, 12 Mercury in house, 12 transits examples)


-- SUN in SIGNS (12)
insert into public.interpretations (type, key, title, summary, tips) values
('planet_in_sign','sun_in_aries','Sun in Aries','Vitality aims at initiative and direct action. You thrive when you start things and move first.','["Begin a small challenge today","Act before overthinking","Channel energy into exercise"]'),
('planet_in_sign','sun_in_taurus','Sun in Taurus','Steady growth, comfort and tangible results. You build slowly but surely.','["Commit to one practical step","Declutter one small area","Cook a grounding meal"]'),
('planet_in_sign','sun_in_gemini','Sun in Gemini','Curiosity, variety and communication fuel you. Learning keeps you alive.','["Write a short note or post","Call someone and share ideas","Test a new tool for 10 minutes"]'),
('planet_in_sign','sun_in_cancer','Sun in Cancer','Care, memory and emotional safety guide your drive. Home base matters.','["Tend to a personal space","Cook or share comfort food","Reach out to a trusted friend"]'),
('planet_in_sign','sun_in_leo','Sun in Leo','Creative expression and heart‑led courage. Being seen lights you up.','["Showcase a small work","Offer genuine praise","Add play to one task"]'),
('planet_in_sign','sun_in_virgo','Sun in Virgo','Refinement, service and useful details. You improve systems.','["Tidy a workflow (10 min)","Ship a small fix","List top 3 priorities"]'),
('planet_in_sign','sun_in_libra','Sun in Libra','Balance, aesthetics and fair exchange. You shine with partners.','["Invite feedback kindly","Beautify a corner","Broker a win‑win"]'),
('planet_in_sign','sun_in_scorpio','Sun in Scorpio','Depth, focus and transformation. You renew by going beneath the surface.','["Protect quiet focus time","Release one draining habit","Journal a fear → next step"]'),
('planet_in_sign','sun_in_sagittarius','Sun in Sagittarius','Meaning, exploration and optimism. Aim the arrow beyond the usual.','["Read 5 pages on a big idea","Take a longer walk","Plan a micro‑adventure"]'),
('planet_in_sign','sun_in_capricorn','Sun in Capricorn','Structure, mastery and long‑term goals. You build what lasts.','["Define one metric","Block 25 minutes deep work","Say no to a distraction"]'),
('planet_in_sign','sun_in_aquarius','Sun in Aquarius','Originality, networks and future thinking. You thrive on systems and people.','["Share a helpful resource","Automate a tiny task","DM someone you admire"]'),
('planet_in_sign','sun_in_pisces','Sun in Pisces','Imagination, empathy and flow. You sense connections others miss.','["5 minutes of breathwork","Add music to a task","Sketch a dream idea"]');


-- MOON in HOUSES (12)
insert into public.interpretations (type, key, title, summary, tips) values
('planet_in_house','moon_house_1','Moon in House I','Feelings show on the surface; moods start the day.','["Name your mood","Keep morning simple","Hydrate early"]'),
('planet_in_house','moon_house_2','Moon in House II','Emotional security links to resources and values.','["Check one expense","Cook at home","List 3 non‑negotiables"]'),
('planet_in_house','moon_house_3','Moon in House III','Daily exchanges shape mood; siblings/neighbors matter.','["Send a kind message","Walk your block","Read 10 minutes"]'),
('planet_in_house','moon_house_4','Moon in House IV','Home and roots restore you.','["Tidy a room corner","Ask about family story","Rest earlier"]'),
('planet_in_house','moon_house_5','Moon in House V','Play, romance and creativity feed the heart.','["Do a 10‑min hobby","Write a compliment","Dance to one song"]'),
('planet_in_house','moon_house_6','Moon in House VI','Routines and service stabilize emotions.','["Prep a simple meal","Stretch 5 minutes","Finish a small chore"]'),
('planet_in_house','moon_house_7','Moon in House VII','Partners and mirroring moods teach balance.','["Listen without fixing","Plan a shared micro‑ritual","Express one need"]'),
('planet_in_house','moon_house_8','Moon in House VIII','Shared resources and deep bonds stir feelings.','["Review one subscription","Journal a fear→fact","Safeguard a password"]'),
('planet_in_house','moon_house_9','Moon in House IX','Beliefs and far horizons lift spirits.','["Learn a worldview snippet","Explore a map","Say yes to a new idea"]'),
('planet_in_house','moon_house_10','Moon in House X','Visibility and role affect mood.','["Define today’s win","Polish a profile line","Celebrate a micro‑result"]'),
('planet_in_house','moon_house_11','Moon in House XI','Friends and causes nurture you.','["Post a helpful tip","Thank a collaborator","Join a community thread"]'),
('planet_in_house','moon_house_12','Moon in House XII','Solitude and inner life soothe.','["Mute notifications 20m","Write a worry→action","Rest without screens"]');


-- MERCURY in HOUSES (12)
insert into public.interpretations (type, key, title, summary, tips) values
('planet_in_house','mercury_house_1','Mercury in House I','Quick mind; you lead with words and ideas.','["Draft a 2‑sentence bio","Outline before writing","Ask one smart question"]'),
('planet_in_house','mercury_house_2','Mercury in House II','Thinking about value, skills and income.','["Note one marketable skill","Track a micro‑expense","Pitch a tiny service"]'),
('planet_in_house','mercury_house_3','Mercury in House III','Curious messenger; short trips, siblings, notes.','["Try a new note method","Walk & record a thought","Reply to one email well"]'),
('planet_in_house','mercury_house_4','Mercury in House IV','Family stories and home logistics.','["Label a box","Map a home task","Call a relative"]'),
('planet_in_house','mercury_house_5','Mercury in House V','Creative mind and witty play.','["Brainstorm 10 ideas","Write a limerick","Explain a concept simply"]'),
('planet_in_house','mercury_house_6','Mercury in House VI','Process thinker; systems and health routines.','["Template a checklist","Rename files clearly","Schedule admin block"]'),
('planet_in_house','mercury_house_7','Mercury in House VII','Dialog and negotiation skills.','["Mirror back what you heard","Draft a simple contract","Clarify expectations"]'),
('planet_in_house','mercury_house_8','Mercury in House VIII','Research mind; shared finances, psychology.','["Read a summary on a taboo topic","Review a shared bill","Use a password manager"]'),
('planet_in_house','mercury_house_9','Mercury in House IX','Philosophy, teaching and publishing.','["Write a thread outline","Teach one idea to a friend","Skim a research abstract"]'),
('planet_in_house','mercury_house_10','Mercury in House X','Career communication and strategy.','["Update a headline","Draft next-step email","Define success metric"]'),
('planet_in_house','mercury_house_11','Mercury in House XI','Networks, groups and future plans.','["Map 3 contacts","Share a resource","Set a quarterly theme"]'),
('planet_in_house','mercury_house_12','Mercury in House XII','Inner dialogue, analysis in quiet.','["Morning pages 5 min","Name a limiting story","Plan a rest ritual"]');


-- TRANSIT → NATAL (12 examples)
insert into public.interpretations (type, key, title, summary, tips) values
('transit_to_nat','tr_sun_conj_moon','Transit Sun conjunct natal Moon','Daily spotlight meets feelings: clarity about needs.','["Name the top need today","Share it gently","Protect energy early"]'),
('transit_to_nat','tr_venus_trine_sun','Transit Venus trine natal Sun','Ease in connections and taste; pleasant flow for expression.','["Plan a social coffee","Tweak a design detail","Offer appreciation"]'),
('transit_to_nat','tr_mars_square_moon','Transit Mars square natal Moon','Irritability possible; act, don’t react.','["Move your body 10 min","Count to 10 before replying","Channel into a task"]'),
('transit_to_nat','tr_mercury_sextile_mc','Transit Mercury sextile natal MC','Useful news for career/role; small wins via message.','["Send a concise update","Polish one slide","Follow up on a lead"]'),
('transit_to_nat','tr_jupiter_trine_asc','Transit Jupiter trine natal ASC','Confidence and support expand; helpful allies appear.','["Ask for intro","Schedule growth task","Celebrate a small luck"]'),
('transit_to_nat','tr_saturn_opposition_sun','Transit Saturn opposite natal Sun','Reality check and responsibility; long‑term focus.','["Define a boundary","Commit to a schedule","Remove one distraction"]'),
('transit_to_nat','tr_uranus_square_venus','Transit Uranus square natal Venus','Surprises in taste/relationships; update patterns.','["Try a fresh style","Plan a novelty date","Unsubscribe from clutter"]'),
('transit_to_nat','tr_neptune_trine_moon','Transit Neptune trine natal Moon','Soft imagination and empathy; rest supports insight.','["Short meditation","Art playlist","Dream journal note"]'),
('transit_to_nat','tr_pluto_conj_mc','Transit Pluto conjunct natal MC','Powerful career transformation; go deep and strategic.','["Audit your goals","Protect reputation","Find a mentor"]'),
('transit_to_nat','tr_mars_sextile_mercury','Transit Mars sextile natal Mercury','Quick action + clear words; ship small decisions.','["Timebox a task","Send decisive email","Avoid doomscrolling"]'),
('transit_to_nat','tr_sun_square_saturn','Transit Sun square natal Saturn','Friction shows limits → structure helps.','["Break task into 3","Ask for clarity","Rest on time"]'),
('transit_to_nat','tr_venus_opposition_mars','Transit Venus opposite natal Mars','Attraction vs. assertion dynamics; balance charm and drive.','["Plan a fair compromise","Compliment + ask","Cool down before reacting"]');
```


## File: tailwind.config.ts

```ts
import type { Config } from 'tailwindcss'


const config: Config = {
content: [
'./src/pages/**/*.{js,ts,jsx,tsx,mdx}',
'./src/components/**/*.{js,ts,jsx,tsx,mdx}',
'./src/app/**/*.{js,ts,jsx,tsx,mdx}',
],
theme: {
extend: {
colors: {
brand: {
50: '#eef6ff',
100: '#d9ebff',
200: '#b7d8ff',
300: '#8bbfff',
400: '#5ea2ff',
500: '#3a86ff',
600: '#2367db',
700: '#1a4faa',
800: '#173f87',
900: '#142f66'
}
}
}
},
plugins: []
}


export default config
```


## File: tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es2020",
    "lib": [
      "dom",
      "dom.iterable",
      "es2020"
    ],
    "allowJs": false,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "incremental": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "next-env.d.ts",
    ".next/types/**/*.ts"
, "next.config.msj"  ],
  "exclude": [
    "node_modules"
  ]
}

```
