# Repository Knowledge Base (chunk 0005)


## File: src\components\ChartWheel.tsx

```tsx
// src/components/ChartWheel.tsx
// Wheel stile AstroDienst con case Placidus ordinate realmente in senso orario (CW)
// partendo dalla cuspide I. Numeri al midpoint dell’arco corretto.

import React, { useMemo } from 'react';

type Point = {
  name: string;
  longitude: number; // [0,360)
  sign?: string | null;
  house?: number | null;
  retro?: boolean | null;
};

type Props = {
  points: Point[];
  houseCusps?: number[];                // 12 cuspidi I..XII
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';     // default: by-asc (ASC a sinistra)
  direction?: 'cw' | 'ccw';             // default: 'cw' (come AstroDienst)
  size?: number;
  className?: string;
  showZodiacRing?: boolean;
  showHouseNumbers?: boolean;
};

const d2r = (d: number) => (d * Math.PI) / 180;
const norm = (x: number) => ((x % 360) + 360) % 360;

const SIGN_GLYPH = ['♈︎','♉︎','♊︎','♋︎','♌︎','♍︎','♎︎','♏︎','♐︎','♑︎','♒︎','♓︎'];
const SIGN_NAMES = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];

const POINT_GLYPH: Record<string,string> = {
  Sun: '☉', Moon: '☾', Mercury: '☿', Venus: '♀', Mars: '♂',
  Jupiter: '♃', Saturn: '♄', Uranus: '♅', Neptune: '♆', Pluto: '♇',
  'True Node': '☊', 'Mean Node': '☊', Node: '☊', 'South Node': '☋',
  Chiron: '⚷'
};

/** Proiezione λ → angolo SVG applicando direzione e rotazione. */
function projectAngleDeg(lambda: number, rotation: number, direction: 'cw' | 'ccw'): number {
  // SVG: 0° a destra, angoli crescono CCW.
  // - 'cw'  : angle = rotation - λ  (zodiaco visivamente orario)
  // - 'ccw' : angle = rotation + λ
  return direction === 'cw' ? norm(rotation - lambda) : norm(rotation + lambda);
}

/** Delta muovendosi CW nello spazio schermo (angoli proiettati). */
function deltaScreenCW(aStart: number, aEnd: number): number {
  return norm(aStart - aEnd); // [0,360)
}

/** Path SVG per un arco da aStart→aEnd nel verso CW o CCW. */
function arcPathDir(
  cx: number,
  cy: number,
  r: number,
  aStartDeg: number,
  aEndDeg: number,
  dir: 'cw' | 'ccw'
): string {
  const aStart = d2r(aStartDeg);
  let delta: number, endDeg: number, sweepFlag: 0 | 1;

  if (dir === 'ccw') {
    delta = norm(aEndDeg - aStartDeg);
    endDeg = aStartDeg + delta;
    sweepFlag = 1; // CCW
  } else {
    delta = norm(aStartDeg - aEndDeg);
    endDeg = aStartDeg - delta;
    sweepFlag = 0; // CW
  }

  const aEnd = d2r(norm(endDeg));
  const x1 = cx + Math.cos(aStart) * r;
  const y1 = cy + Math.sin(aStart) * r;
  const x2 = cx + Math.cos(aEnd) * r;
  const y2 = cy + Math.sin(aEnd) * r;
  const largeArc = delta > 180 ? 1 : 0;

  return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${x2} ${y2}`;
}

export default function ChartWheel({
  points,
  houseCusps,
  mcDeg,
  orientation = 'by-asc',
  direction = 'cw',
  size = 560,
  className,
  showZodiacRing = true,
  showHouseNumbers = true
}: Props) {
  const r = size / 2;
  const cx = r, cy = r;

  // Layer radii (rays fino al cerchio più interno, per spicchi netti)
  const R_OUTER = r - 8;
  const R_ZOD_OUT = r - 30;
  const R_ZOD_IN  = r - 64;
  const R_PLANETS = r - 108;
  const R_HOUSE_ARC = r - 146;
  const R_HOUSE_NUM = r - 168;
  const R_HOUSE_RAY = r - 200;
  const R_INNER = r - 200;

  const cusps = Array.isArray(houseCusps) && houseCusps.length === 12 ? houseCusps.map(norm) : null;
  const mcFromPoints = useMemo(() => points.find(p => p.name === 'MC')?.longitude ?? 0, [points]);
  const mc = typeof mcDeg === 'number' ? mcDeg : mcFromPoints;

  // Rotazione globale (ASC a sinistra, oppure MC in alto)
  const rotation = useMemo(() => {
    const dirSign = direction === 'cw' ? -1 : +1;
    if (orientation === 'by-asc' && cusps) return norm(180 - dirSign * cusps[0]);
    if (orientation === 'by-mc')          return norm( 90 - dirSign * norm(mc));
    return norm(90);
  }, [orientation, direction, cusps, mc]);

  // Anelli base
  const base = (
    <>
      <circle cx={cx} cy={cy} r={R_OUTER} fill="none" stroke="currentColor" strokeOpacity={0.25}/>
      <circle cx={cx} cy={cy} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={0.2}/>
      <circle cx={cx} cy={cy} r={R_ZOD_IN}  fill="none" stroke="currentColor" strokeOpacity={0.2}/>
      <circle cx={cx} cy={cy} r={R_INNER}   fill="none" stroke="currentColor" strokeOpacity={0.25}/>
    </>
  );

  // Zodiaco
  const zodiac = showZodiacRing ? (
    <>
      {Array.from({ length: 12 }, (_, i) => {
        const deg = i * 30;
        const A = d2r(projectAngleDeg(deg, rotation, direction));
        const x1 = cx + Math.cos(A) * R_ZOD_OUT;
        const y1 = cy + Math.sin(A) * R_ZOD_OUT;
        const x2 = cx + Math.cos(A) * R_ZOD_IN;
        const y2 = cy + Math.sin(A) * R_ZOD_IN;
        return <line key={`z-split-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke="currentColor" strokeOpacity={0.35}/>;
      })}
      {Array.from({ length: 12 }, (_, i) => {
        const mid = i * 30 + 15;
        const A = d2r(projectAngleDeg(mid, rotation, direction));
        const lx = cx + Math.cos(A) * ((R_ZOD_OUT + R_ZOD_IN) / 2);
        const ly = cy + Math.sin(A) * ((R_ZOD_OUT + R_ZOD_IN) / 2);
        return (
          <text
            key={`z-glyph-${i}`}
            x={lx} y={ly}
            textAnchor="middle" dominantBaseline="central"
            fontSize={14} fill="currentColor" opacity={0.9}
            aria-label={SIGN_NAMES[i]}
          >
            {SIGN_GLYPH[i]}
          </text>
        );
      })}
    </>
  ) : null;

  // --- CASE ---

  // Raggi sulle cuspidi, fino al cerchio interno
  const houseRays = cusps?.map((deg, i) => {
    const A = d2r(projectAngleDeg(deg, rotation, direction));
    const x1 = cx + Math.cos(A) * R_ZOD_IN;
    const y1 = cy + Math.sin(A) * R_ZOD_IN;
    const x2 = cx + Math.cos(A) * R_HOUSE_RAY;
    const y2 = cy + Math.sin(A) * R_HOUSE_RAY;
    const thick = (i === 0 || i === 9) ? 2 : 1;
    return <line key={`h-ray-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke="currentColor" strokeWidth={thick} />;
  }) ?? null;

  let houseArcs: JSX.Element[] | null = null;
  let houseNums: JSX.Element[] | null = null;

  if (cusps) {
    // Angoli proiettati delle 12 cuspidi
    const A: number[] = cusps.map(c => projectAngleDeg(c, rotation, direction));
    const N = 12;

    // Per ogni cuspide i, trova l'indice j della SUCCESSIVA adiacente in CW
    const nextCW: number[] = new Array(N).fill(0);
    for (let i = 0; i < N; i++) {
      let best = 360, bestJ = i;
      for (let k = 0; k < N; k++) {
        if (k === i) continue;
        const d = deltaScreenCW(A[i], A[k]);
        if (d > 0 && d < best) { best = d; bestJ = k; }
      }
      nextCW[i] = bestJ;
    }

    // Cammina davvero da cuspide I (indice 0) seguendo nextCW in CW → ordine geometrico
    const order: number[] = [];
    const seen = new Array(N).fill(false);
    let cur = 0;
    for (let step = 0; step < N; step++) {
      order.push(cur);
      seen[cur] = true;
      const nxt = nextCW[cur];
      if (seen[nxt]) {
        // (degenere) se chiude un ciclo prima di 12, riempi con gli indici mancanti ordinati per angolo CW
        if (order.length < N) {
          const rest = [...Array(N).keys()].filter(ix => !seen[ix]);
          // ordina i rimanenti in senso CW rispetto all’ultimo angolo
          rest.sort((i, j) => deltaScreenCW(A[cur], A[i]) - deltaScreenCW(A[cur], A[j]));
          order.push(...rest);
        }
        break;
      }
      cur = nxt;
    }
    if (order.length < N) {
      // fallback di sicurezza (non dovrebbe servire)
      const idx = [...Array(N).keys()];
      idx.sort((i, j) => deltaScreenCW(A[0], A[i]) - deltaScreenCW(A[0], A[j]));
      for (const k of idx) if (!order.includes(k)) order.push(k);
    }

    // Disegna archi Casa j: order[j] → order[j+1] (CW) e numero al midpoint di quell’arco
    houseArcs = order.map((idx, j) => {
      const start = A[idx];
      const end   = A[order[(j + 1) % N]];
      const path  = arcPathDir(cx, cy, R_HOUSE_ARC, start, end, 'cw');
      return (
        <path
          key={`h-arc-${j}`}
          d={path}
          fill="none"
          stroke="currentColor"
          strokeOpacity={0.28}
        />
      );
    });

    if (showHouseNumbers) {
      houseNums = order.map((idx, j) => {
        const start = A[idx];
        const end   = A[order[(j + 1) % N]];
        const delta = norm(start - end); // CW
        const midDeg = norm(start - delta / 2);
        const mid = d2r(midDeg);
        const lx = cx + Math.cos(mid) * R_HOUSE_NUM;
        const ly = cy + Math.sin(mid) * R_HOUSE_NUM;
        return (
          <text
            key={`h-num-${j}`}
            x={lx} y={ly}
            textAnchor="middle" dominantBaseline="central"
            fontSize={12} fill="currentColor" opacity={0.9}
          >
            {j + 1}
          </text>
        );
      });
    }
  }

  // Angoli (etichette sulle loro cuspidi)
  const angleLabels = cusps ? (() => {
    const idx = { AC: 0, MC: 9, DC: 6, IC: 3 }; // I, X, VII, IV
    return (Object.entries(idx) as Array<[keyof typeof idx, number]>).map(([label, i]) => {
      const A = d2r(projectAngleDeg(cusps[i], rotation, direction));
      const lx = cx + Math.cos(A) * (R_ZOD_OUT + 8);
      const ly = cy + Math.sin(A) * (R_ZOD_OUT + 8);
      return (
        <text key={`ang-${label}`} x={lx} y={ly} textAnchor="middle" dominantBaseline="central" fontSize={12}>
          {label}
        </text>
      );
    });
  })() : null;

  // Pianeti (senza angoli): tacchetta blu verso zodiaco
  const planetDots = points
    .filter(p => p.name !== 'ASC' && p.name !== 'MC' && p.name !== 'IC' && p.name !== 'DSC')
    .map((p) => {
      const lam = norm(p.longitude);
      const A = d2r(projectAngleDeg(lam, rotation, direction));
      const x = cx + Math.cos(A) * R_PLANETS;
      const y = cy + Math.sin(A) * R_PLANETS;

      const tx1 = cx + Math.cos(A) * (R_ZOD_IN + 4);
      const ty1 = cy + Math.sin(A) * (R_ZOD_IN + 4);
      const tx2 = cx + Math.cos(A) * (R_ZOD_IN + 12);
      const ty2 = cy + Math.sin(A) * (R_ZOD_IN + 12);

      const glyph = POINT_GLYPH[p.name] ?? p.name.slice(0, 1).toUpperCase();

      return (
        <g key={`pt-${p.name}-${lam.toFixed(2)}`}>
          <line x1={tx1} y1={ty1} x2={tx2} y2={ty2} stroke="#3b82f6" strokeWidth={1}/>
          <circle cx={x} cy={y} r={3} fill="currentColor" />
          <text
            x={x} y={y}
            dx={8} dy={-4}
            fontSize={11}
            textAnchor="start" dominantBaseline="central"
            fill="currentColor"
          >
            {glyph}{p.retro ? ' ℞' : ''}
          </text>
        </g>
      );
    });

  return (
    <svg width={size} height={size} className={className} role="img" aria-label="Astrology Chart Wheel">
      {base}
      {zodiac}
      {/* Case: archi (ampiezza), raggi (cuspidi) e numeri (midpoint CW in ordine 1..12) */}
      {houseArcs}
      {houseRays}
      {houseNums}
      {planetDots}
      {angleLabels}
    </svg>
  );
}

```


## File: src\components\ChatUI.tsx

```tsx
'use client';

import React, { useMemo, useRef, useState } from 'react';
import { systemChat } from '@/ai/systemPrompts';

type Msg = { role: 'system' | 'user' | 'assistant'; content: string };

type Props = {
  /** Contesto da /api/compat/[id] (CONTEXT_*, PEER_SUMMARY, ecc.) */
  initialContext?: string;
  /** Se vuoi passare un system prompt già unito, questo ha priorità */
  systemPrompt?: string;
  /** Endpoint della chat (default: /api/chat) */
  endpoint?: string;
};

/* ---------- Type guards & helpers (no any) ---------- */
function isRecord(o: unknown): o is Record<string, unknown> {
  return typeof o === 'object' && o !== null;
}
function isTextHolder(o: unknown): o is { text: string } {
  return isRecord(o) && typeof o.text === 'string';
}
function get(obj: unknown, path: Array<string | number>): unknown {
  let cur: unknown = obj;
  for (const key of path) {
    if (!isRecord(cur) && !Array.isArray(cur)) return undefined;
    if (typeof key === 'number') {
      if (!Array.isArray(cur) || key < 0 || key >= cur.length) return undefined;
      cur = cur[key];
    } else {
      const rec = cur as Record<string, unknown>;
      if (!(key in rec)) return undefined;
      cur = rec[key];
    }
  }
  return cur;
}

/** Estrae testo da stringhe o array di blocchi con {text} (OpenAI/Anthropic-like) */
function extractFromContentField(content: unknown): string {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) {
    const parts = content
      .map((c) => (typeof c === 'string' ? c : isTextHolder(c) ? c.text : ''))
      .filter(Boolean);
    return parts.join('');
  }
  if (isTextHolder(content)) return content.text;
  return '';
}

/** Estrae il testo dai formati JSON più comuni (aggiunge anche supporto a { answer: "..." }) */
function extractTextFromJSON(json: unknown): string {
  if (!isRecord(json)) return '';

  // Diretti (incluso 'answer')
  const direct =
    get(json, ['answer']) ??            // <-- supporto al tuo backend
    get(json, ['reply']) ??
    get(json, ['content']) ??
    get(json, ['message']) ??
    get(json, ['text']) ??
    get(json, ['output_text']) ??
    get(json, ['result', 'text']) ??
    get(json, ['data', 0, 'text']) ??
    get(json, ['generations', 0, 'text']);
  const directStr = extractFromContentField(direct);
  if (directStr) return directStr;

  // OpenAI chat (non stream)
  const msgContent = get(json, ['choices', 0, 'message', 'content']);
  const msgStr = extractFromContentField(msgContent);
  if (msgStr) return msgStr;

  // Delta anche senza stream
  const deltaContent = get(json, ['choices', 0, 'delta', 'content']);
  const deltaStr = extractFromContentField(deltaContent);
  if (deltaStr) return deltaStr;

  // Anthropic-like
  const anthropicStr = extractFromContentField(get(json, ['content']));
  if (anthropicStr) return anthropicStr;

  return '';
}

/** Normalizza il testo per l’utente: niente **grassetti**, niente \n raw, bullet carini */
function normalizeOutput(text: string): string {
  let t = text;

  // Se accidentalmente è stato passato un JSON in stringa, prova a leggerlo
  if (t.trim().startsWith('{') && t.includes('"answer"')) {
    try {
      const parsed = JSON.parse(t) as unknown;
      const fromJson = extractTextFromJSON(parsed);
      if (fromJson) t = fromJson;
    } catch {
      // ignore
    }
  }

  // Unifica newline e rimuovi escape visivi
  t = t.replace(/\r\n/g, '\n');
  t = t.replace(/\\n/g, '\n').replace(/\\t/g, '    ');

  // Rimuovi markdown base
  t = t.replace(/\*\*(.*?)\*\*/g, '$1'); // **bold** -> bold
  t = t.replace(/\*(.*?)\*/g, '$1');     // *italic* -> italic (semplice)

  // Bullet list più leggibili
  t = t.replace(/^\s*-\s+/gm, '• ');

  // Collassa e rifinisci
  t = t.replace(/\n{3,}/g, '\n\n').trim();
  return t;
}
/* ---------------------------------------------------- */

export default function ChatUI({
  initialContext = '',
  systemPrompt,
  endpoint = '/api/chat',
}: Props) {
  // 1) Costruisci il messaggio di sistema unendo regole + contesto
  const finalSystem = useMemo(() => {
    if (systemPrompt && systemPrompt.trim()) return systemPrompt.trim();
    const blocks: string[] = [];
    if (systemChat) blocks.push(systemChat.trim());
    if (initialContext) blocks.push(initialContext.trim());
    return blocks.join('\n\n').trim();
  }, [systemPrompt, initialContext]);

  // Stato messaggi: includi il system come primo messaggio (non mostrato)
  const [messages, setMessages] = useState<Msg[]>(
    finalSystem ? [{ role: 'system', content: finalSystem }] : []
  );
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const streamingRef = useRef(false);

  function pushUserMessage(text: string) {
    setMessages(prev => [...prev, { role: 'user', content: text }]);
  }
  function startAssistantMessage() {
    setMessages(prev => [...prev, { role: 'assistant', content: '' }]);
  }
  function appendToAssistant(chunk: string) {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (!last || last.role !== 'assistant') return out;
      last.content = (last.content || '') + chunk;
      return out;
    });
  }
  function setAssistant(text: string) {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (!last || last.role !== 'assistant') out.push({ role: 'assistant', content: text });
      else last.content = text;
      return out;
    });
  }
  function normalizeLastAssistant() {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (last && last.role === 'assistant') {
        last.content = normalizeOutput(last.content || '');
      }
      return out;
    });
  }

  // SSE (OpenAI style)
  async function readSSE(res: Response) {
    const reader = res.body?.getReader();
    if (!reader) { setAssistant('Errore: stream non disponibile.'); return; }
    streamingRef.current = true;
    startAssistantMessage();

    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      const lines = buffer.split(/\r?\n/);
      buffer = lines.pop() || '';

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || !trimmed.startsWith('data:')) continue;
        const data = trimmed.slice(5).trim();
        if (data === '[DONE]') { streamingRef.current = false; normalizeLastAssistant(); return; }
        try {
          const parsed: unknown = JSON.parse(data);
          const piece =
            extractFromContentField(get(parsed, ['choices', 0, 'delta', 'content'])) ||
            extractFromContentField(get(parsed, ['choices', 0, 'message', 'content'])) ||
            extractFromContentField(get(parsed, ['content'])) ||
            '';
          if (piece) appendToAssistant(piece);
        } catch {
          if (data) appendToAssistant(data + '\n');
        }
      }
    }
    streamingRef.current = false;
    normalizeLastAssistant();
  }

  // ——— Send ———
  async function send() {
    const text = input.trim();
    if (!text || loading) return;
    setLoading(true);

    pushUserMessage(text);
    setInput('');

    try {
      const payload = {
        messages: [...messages, { role: 'user', content: text } as Msg],
        system: finalSystem,
        prompt: finalSystem ? `${finalSystem}\n\n${text}` : text,
        question: text,
      };

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'accept': 'text/event-stream, application/json, text/plain',
        },
        body: JSON.stringify(payload),
      });

      const ctype = res.headers.get('content-type') || '';

      // Caso 1: SSE
      if (ctype.includes('text/event-stream')) {
        await readSSE(res);
        setLoading(false);
        return;
      }

      // Caso 2: JSON (leggiamo anche raw per fallback)
      if (ctype.includes('application/json')) {
        const raw = await res.clone().text().catch(() => '');
        let assistantText = '';
        try {
          const j: unknown = await res.json();
          assistantText = extractTextFromJSON(j);
        } catch {
          assistantText = '';
        }
        if (!assistantText && raw) {
          // alcuni back-end mandano JSON con content-type sbagliato nella clone
          try {
            const maybe: unknown = JSON.parse(raw);
            assistantText = extractTextFromJSON(maybe);
          } catch {
            assistantText = raw;
          }
        }
        setAssistant(assistantText ? normalizeOutput(assistantText) : 'Non ho ricevuto un contenuto utilizzabile dal modello.');
        setLoading(false);
        return;
      }

      // Caso 3: testo semplice (o content-type non affidabile)
      const textBody = await res.text();
      const clean = (textBody || '').trim();
      // Prova a interpretarlo come JSON con answer; altrimenti normalizza testo
      let final = '';
      if (clean.startsWith('{')) {
        try {
          const maybe: unknown = JSON.parse(clean);
          final = extractTextFromJSON(maybe);
        } catch {
          final = clean;
        }
      } else {
        final = clean;
      }
      setAssistant(final ? normalizeOutput(final) : 'Non ho ricevuto una risposta valida dal modello.');
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Errore di rete';
      setAssistant(`Errore: ${msg}`);
    } finally {
      setLoading(false);
    }
  }

  function onKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void send();
    }
  }

  return (
    <div className="flex h-full flex-col">
      {/* Messaggi (non mostro il system) */}
      <div className="flex-1 overflow-y-auto space-y-3 pr-2">
        {messages
          .filter(m => m.role !== 'system')
          .map((m, i) => (
            <div
              key={i}
              className={
                m.role === 'user'
                  ? 'ml-auto max-w-[80%] rounded-2xl border px-3 py-2 bg-gray-50'
                  : 'mr-auto max-w-[80%] rounded-2xl border px-3 py-2'
              }
            >
              <div className="whitespace-pre-wrap text-[0.95rem] leading-relaxed">
                {m.content}
              </div>
            </div>
          ))}
      </div>

      {/* Input */}
      <div className="mt-3 flex gap-2">
        <input
          className="flex-1 rounded-lg border px-3 py-2"
          placeholder='Es. "qual è il segno di questa persona?"'
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={onKeyDown}
          disabled={loading}
        />
        <button
          className="rounded-lg border px-4 py-2 disabled:opacity-50"
          onClick={send}
          disabled={loading || !input.trim()}
        >
          {loading ? (streamingRef.current ? 'Ricevo…' : 'Invio…') : 'Invia'}
        </button>
      </div>

      <p className="mt-2 text-xs text-gray-500">
        La chat mostra solo testo pulito: niente JSON, niente markdown rumoroso.
      </p>
    </div>
  );
}

```


## File: src\components\CurrentLocationForm.tsx

```tsx
// src/components/CurrentLocationForm.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type ResolvePayload = {
  display_name: string;
  lat: number;
  lon: number;
  city: string | null;
  state: string | null;
  country: string | null;
  timezone: string | null;
  tz_offset_minutes: number | null;
};

type ResolveResult = {
  ok: boolean;
  query?: string;
  result?: ResolvePayload;
  error?: string;
};

export type CurrentLocationInitial = {
  place_name?: string | null;
  lat?: number | null;
  lon?: number | null;
  tz_name?: string | null;
};

export default function CurrentLocationForm(props: { initial?: CurrentLocationInitial }) {
  const { initial } = props;

  const [query, setQuery] = useState<string>(initial?.place_name ?? '');
  const [resolved, setResolved] = useState<ResolveResult | null>(null);

  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  const haveSaved =
    typeof initial?.lat === 'number' &&
    typeof initial?.lon === 'number' &&
    !!initial?.place_name;

  const canResolve = useMemo(() => query.trim().length >= 2, [query]);

  useEffect(() => {
    setResolved(null);
    setMsg(null);
    setErr(null);
  }, [query]);

  async function resolvePlace() {
    if (!canResolve) return;
    setBusy(true);
    setMsg(null);
    setErr(null);
    try {
      const r = await fetch(`/api/geo/resolve?q=${encodeURIComponent(query.trim())}`);
      const j = (await r.json()) as ResolveResult;
      if (!j.ok || !j.result) throw new Error(j.error || 'Place not found');
      setResolved(j);
      setMsg(`Resolved: ${j.result.display_name} ${j.result.timezone ? `(${j.result.timezone})` : ''}`);
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Resolve error');
    } finally {
      setBusy(false);
    }
  }

  const canSave = useMemo(() => {
    if (resolved?.ok && resolved.result) return true;
    return haveSaved;
  }, [resolved, haveSaved]);

  async function savePrefs() {
    if (!canSave) return;
    setBusy(true);
    setMsg(null);
    setErr(null);
    try {
      // usa i dati risolti se presenti, altrimenti quelli salvati
      const payload = resolved?.result
        ? {
            place_name: resolved.result.display_name,
            lat: resolved.result.lat,
            lon: resolved.result.lon,
            tz_name: resolved.result.timezone ?? null,
          }
        : {
            place_name: initial?.place_name ?? '',
            lat: (initial?.lat ?? null) as number | null,
            lon: (initial?.lon ?? null) as number | null,
            tz_name: initial?.tz_name ?? null,
          };

      const resp = await fetch('/api/user/prefs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const j = (await resp.json()) as { ok?: boolean; error?: string };
      if (!resp.ok || !j.ok) throw new Error(j.error || `Save failed (${resp.status})`);

      setMsg('Current location saved.');
      // opzionale: vai al dashboard
      // window.location.assign('/dashboard');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Save error');
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <div className="space-y-1">
        <label className="text-xs text-gray-600">Current city (for transits)</label>
        <div className="flex gap-2">
          <input
            className="flex-1 rounded border px-3 py-2 text-sm"
            placeholder="City, Country"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
          />
          <button
            type="button"
            className="rounded border px-3 py-2 text-sm"
            onClick={resolvePlace}
            disabled={!canResolve || busy}
            title="Resolve with Nominatim"
          >
            {busy ? 'Resolving…' : 'Resolve'}
          </button>
        </div>

        {resolved?.ok && resolved.result ? (
          <div className="text-xs text-green-700">
            Resolved: {resolved.result.display_name}{' '}
            {resolved.result.timezone ? `(${resolved.result.timezone})` : ''}
          </div>
        ) : haveSaved ? (
          <div className="text-xs text-gray-600">
            Using saved place: {initial?.place_name}
            {initial?.tz_name ? ` (${initial.tz_name})` : ''}
          </div>
        ) : (
          <div className="text-xs text-gray-500">Use Resolve to select a valid place.</div>
        )}
      </div>

      <div className="flex items-center gap-2">
        <button
          type="button"
          onClick={savePrefs}
          disabled={!canSave || busy}
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white disabled:opacity-50"
        >
          {busy ? 'Saving…' : 'Save current location'}
        </button>
      </div>

      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}

      <p className="text-xs text-gray-500">
        Wellness/entertainment only; not a substitute for medical, legal, or financial advice.
      </p>
    </div>
  );
}

```


## File: src\components\HouseSystemSwitcher.tsx

```tsx
// src/components/HouseSystemSwitcher.tsx
'use client';

import { useState, useTransition } from 'react';
import { useRouter } from 'next/navigation';

type HouseSystem = 'placidus' | 'whole';

type Props = {
  current: HouseSystem;
  size?: 'sm' | 'md';
  className?: string;
};

export default function HouseSystemSwitcher({ current, size = 'md', className }: Props) {
  const [pending, startTransition] = useTransition();
  const [local, setLocal] = useState<HouseSystem>(current);
  const router = useRouter();

  const sizeClass = size === 'sm' ? 'px-2 py-1 text-xs' : 'px-3 py-1.5 text-sm';

  const btnBase =
    `rounded-md border ${sizeClass} transition-colors disabled:opacity-60 disabled:cursor-not-allowed`;
  const btnActive = 'bg-blue-600 text-white border-blue-600';
  const btnIdle = 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50';

  async function apply(system: HouseSystem) {
    if (system === local || pending) return;
    setLocal(system);

    try {
      const res = await fetch(`/api/chart/compute?system=${system}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ source: 'HouseSystemSwitcher' }),
        cache: 'no-store',
      });
      const json = await res.json().catch(() => ({}));
      if (!res.ok) {
        console.error('compute error', res.status, json);
        alert('Errore nel ricalcolo. Riprova.');
        return;
      }
      if (json?.fallbackApplied) {
        alert('Placidus non disponibile alla latitudine indicata: attivato il fallback Whole Sign.');
      }
    } catch (err) {
      console.error(err);
      alert('Errore di rete durante il ricalcolo.');
    } finally {
      startTransition(() => {
        router.refresh();
      });
    }
  }

  return (
    <div className={`inline-flex items-center gap-2 ${className ?? ''}`}>
      <span className="text-xs text-gray-500">House system:</span>
      <div className="inline-flex gap-1" aria-busy={pending}>
        <button
          type="button"
          className={`${btnBase} ${local === 'whole' ? btnActive : btnIdle}`}
          onClick={() => apply('whole')}
          disabled={pending}
          aria-pressed={local === 'whole'}
        >
          Whole
        </button>
        <button
          type="button"
          className={`${btnBase} ${local === 'placidus' ? btnActive : btnIdle}`}
          onClick={() => apply('placidus')}
          disabled={pending}
          aria-pressed={local === 'placidus'}
        >
          Placidus
        </button>
      </div>
    </div>
  );
}

```


## File: src\components\MonthTransitsList.tsx

```tsx
'use client';

import React, { MouseEvent, useRef } from 'react';

type AspectKey = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

type TransitHit = {
  date: string;
  t_planet: string;
  n_point: string;
  aspect: AspectKey;
  orb: number;
  score: number;
};

type DayBucket = { date: string; items: TransitHit[] };

function symbolForAspect(a: AspectKey): string {
  switch (a) {
    case 'conjunction': return '☌';
    case 'sextile':     return '✶';
    case 'square':      return '□';
    case 'trine':       return '△';
    case 'opposition':  return '☍';
  }
}

function fmtGoogleStamp(iso: string) {
  const d = new Date(iso);
  const pad = (n: number) => String(n).padStart(2, '0');
  return (
    d.getUTCFullYear().toString() +
    pad(d.getUTCMonth() + 1) +
    pad(d.getUTCDate()) +
    'T' +
    pad(d.getUTCHours()) +
    pad(d.getUTCMinutes()) +
    pad(d.getUTCSeconds()) +
    'Z'
  );
}

export default function MonthTransitsList({
  ym,
  days,
}: {
  ym: string;
  days: DayBucket[];
}) {
  const scrollRef = useRef<HTMLDivElement>(null);

  const goToDay = (e: MouseEvent<HTMLAnchorElement>, date: string) => {
    e.preventDefault();
    const container = scrollRef.current;
    if (!container) return;
    const el = container.querySelector<HTMLElement>(`section[data-date="${date}"]`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
  };

  return (
    <div className="rounded-2xl border p-4">
      {/* Indice "vai al giorno" compatto */}
      <nav className="mb-3 flex flex-wrap gap-2 text-xs">
        {days.map((d) => (
          <a
            key={d.date}
            href={`#${d.date}`}
            onClick={(e) => goToDay(e, d.date)}
            className="rounded-lg border px-2 py-1 hover:bg-gray-50"
            title={`Vai al ${d.date}`}
          >
            {d.date.slice(-2)}
          </a>
        ))}
      </nav>

      {/* Scroller interno che contiene TUTTI i transiti */}
      <div
        ref={scrollRef}
        className="h-[75vh] overflow-y-auto pr-2 space-y-5"
        aria-label={`Transiti di ${ym}`}
      >
        {days.map(({ date, items }) => (
          <section
            key={date}
            data-date={date}
            className="rounded-2xl border p-4 scroll-mt-24 bg-white"
          >
            <div className="mb-3 flex items-center justify-between">
              <h2 className="text-base font-semibold">{date}</h2>
              <a
                href={`#${date}`}
                onClick={(e) => goToDay(e, date)}
                className="text-xs text-gray-600 hover:underline"
              >
                Vai al giorno
              </a>
            </div>

            <ul className="space-y-3">
              {items.map((t, idx) => {
                const startISO = `${date}T09:00:00Z`; // orario placeholder
                const endISO = `${date}T10:00:00Z`;
                const gStart = fmtGoogleStamp(startISO);
                const gEnd = fmtGoogleStamp(endISO);

                const title = `${t.t_planet} ${t.aspect} ${t.n_point}`;
                const description = `Orb ${t.orb}°, score ${Math.round(
                  t.score
                )}. Generated by Natal + Transits + Chat (wellbeing/entertainment).`;

                const gcal = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(
                  title
                )}&dates=${gStart}/${gEnd}&details=${encodeURIComponent(description)}`;
                const ics = `/api/calendar/ics?title=${encodeURIComponent(
                  title
                )}&description=${encodeURIComponent(
                  description
                )}&start=${encodeURIComponent(startISO)}&duration=60`;

                return (
                  <li
                    key={`${date}-${t.t_planet}-${t.n_point}-${idx}`}
                    className="rounded-xl border p-3"
                  >
                    <div className="flex items-center justify-between">
                      <div className="font-medium">
                        {t.t_planet} {symbolForAspect(t.aspect)} {t.n_point}
                      </div>
                      <div className="text-xs text-gray-500">
                        orb {t.orb.toFixed(1)}° • score {Math.round(t.score)}
                      </div>
                    </div>

                    <div className="mt-2 flex items-center gap-2">
                      <a
                        href={gcal}
                        target="_blank"
                        rel="noreferrer"
                        className="rounded-lg border px-2 py-1 text-xs hover:bg-gray-50"
                      >
                        Google Calendar
                      </a>
                      <a
                        href={ics}
                        className="rounded-lg border px-2 py-1 text-xs hover:bg-gray-50"
                      >
                        Download .ics
                      </a>
                    </div>
                  </li>
                );
              })}
            </ul>
          </section>
        ))}
      </div>
    </div>
  );
}

```


## File: src\components\MoonPhaseCard.tsx

```tsx
// src/components/MoonPhaseCard.tsx
'use client';

import React from 'react';

export default function MoonPhaseCard({
  dateISO,
  tzName,
  moonSign,
  phaseName,
  illumination, // 0..1
  emoji,        // 🌑🌒🌓🌔🌕🌖🌗🌘
}: {
  dateISO: string;
  tzName: string;
  moonSign: string;
  phaseName: string;
  illumination: number;
  emoji: string;
}) {
  const pct = Math.round(illumination * 100);

  return (
    <div className="rounded-2xl border p-4 bg-white">
      <div className="mb-3 text-sm font-medium">
        Lunar calendar · {dateISO} ({tzName})
      </div>

      <div className="flex items-center gap-4">
        <div className="flex h-24 w-24 items-center justify-center rounded-xl border text-4xl bg-gray-50">
          {emoji}
        </div>

        <div className="text-sm">
          <div className="text-lg font-semibold mb-1">Moon in {moonSign}</div>
          <div className="text-gray-700">{phaseName}</div>
          <div className="text-gray-500">{pct}% illuminated</div>
        </div>
      </div>

      <p className="mt-3 text-xs text-gray-500">
        Wellbeing/entertainment. The Moon sign and phase are calculated for the selected date/time.
      </p>
    </div>
  );
}

```


## File: src\components\PeopleList.tsx

```tsx
// FILE: src/components/PeopleList.tsx
import Link from "next/link";
import { createSupabaseServerComponentClient } from "@/lib/supabaseServer";

/**
 * Elenco persone salvate dall'utente corrente.
 * Allineato allo schema reale della tabella "people":
 *  - label (nome/alias), created_at, (niente display_name).
 * Fonte: db-schema.json (tabella people). :contentReference[oaicite:1]{index=1}
 */
export default async function PeopleList() {
  const supabase = createSupabaseServerComponentClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return (
      <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
        Accedi per vedere le persone salvate.
      </div>
    );
  }

  const { data, error } = await supabase
    .from("people")
    .select("id, label, created_at")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false })
    .limit(50);

  if (error) {
    return (
      <div className="rounded-lg border border-rose-300 bg-rose-50 p-3 text-sm text-rose-800">
        Errore nel caricare la lista persone.<br />
        <span className="text-xs opacity-80">Dettagli: {error.message}</span>
      </div>
    );
  }

  if (!data || data.length === 0) {
    return (
      <div className="rounded-lg border border-gray-200 bg-gray-50 p-3 text-sm text-gray-600">
        Nessuna persona salvata. Usa il form a sinistra per aggiungerne una.
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 gap-3 sm:grid-cols-2">
      {data.map((p) => (
        <Link
          key={p.id}
          href={`/lab/people-pro/${p.id}`}
          className="rounded-lg border border-gray-200 bg-white p-3 shadow-sm transition hover:shadow"
        >
          <div className="text-sm font-medium">{p.label || p.id}</div>
          <div className="mt-1 text-xs text-gray-500">ID: {p.id}</div>
        </Link>
      ))}
    </div>
  );
}

```


## File: src\components\PeoplePanel.tsx

```tsx
// src/components/PeoplePanel.tsx
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';

export type HouseSystem = 'placidus' | 'whole';

export type PersonFormState = {
  id?: string;
  label?: string | null;
  birth_date?: string | null;              // 'YYYY-MM-DD'
  birth_time?: string | null;              // 'HH:MM' | null
  birth_tz_offset_minutes?: number | null; // (non usato qui)
  birth_lat?: number | null;
  birth_lon?: number | null;
};

type PeoplePanelProps = {
  houseSystem?: HouseSystem;               // opzionale: default 'placidus'
  defaultPerson?: PersonFormState | null;
};

type CreateResp = { ok?: boolean; id?: string; error?: string };
type CuspsResp =
  | { ok: true; count: number; system: HouseSystem; approx: string | null }
  | { error: string; stage?: string };

export default function PeoplePanel({ houseSystem = 'placidus', defaultPerson }: PeoplePanelProps) {
  const router = useRouter();

  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [okMsg, setOkMsg] = useState<string | null>(null);

  const [form, setForm] = useState<PersonFormState>({
    id: defaultPerson?.id,
    label: defaultPerson?.label ?? '',
    birth_date: defaultPerson?.birth_date ?? '',
    birth_time: defaultPerson?.birth_time ?? '',
    birth_tz_offset_minutes: defaultPerson?.birth_tz_offset_minutes ?? 0,
    birth_lat: defaultPerson?.birth_lat ?? 0,
    birth_lon: defaultPerson?.birth_lon ?? 0,
  });

  const set = <K extends keyof PersonFormState>(k: K, v: PersonFormState[K]) =>
    setForm((s) => ({ ...s, [k]: v }));

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setSaving(true);
    setError(null);
    setOkMsg(null);

    try {
      // 1) Crea persona + semina punti/aspetti (riempie people_chart_points)
      const res = await fetch('/api/people', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          label: form.label || '',
          date: form.birth_date || '',
          time: form.birth_time || null,
          lat: form.birth_lat != null ? Number(form.birth_lat) : null,
          lon: form.birth_lon != null ? Number(form.birth_lon) : null,
        }),
      });
      const js = (await res.json()) as CreateResp;
      if (!res.ok || !js.ok || !js.id) {
        throw new Error(js.error || `HTTP ${res.status}`);
      }
      const personId = js.id;
      setForm((s) => ({ ...s, id: personId }));

      // 2) Cuspidi (con fallback solare; se manca ASC e manca Sun in tabella lo approssima)
      const cuRes = await fetch('/api/people/house-cusps/upsert?solar=1', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ person_id: personId, system: houseSystem }),
      });
      const cuJson = (await cuRes.json()) as CuspsResp;
      if (!cuRes.ok || 'error' in cuJson) {
        throw new Error(('error' in cuJson ? cuJson.error : `HTTP ${cuRes.status}`));
      }

      const ok = cuJson as Extract<CuspsResp, { ok: true }>;
      setOkMsg(`Cuspidi salvate: ${ok.count} (${ok.system}${ok.approx ? ', ' + ok.approx : ''})`);

      // 3) Redirect alla pagina sinastria
      router.push(`/lab/people-pro/${personId}`);
    } catch (err) {
      setError((err as Error)?.message ?? 'Errore inatteso');
    } finally {
      setSaving(false);
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-3">
      <div className="grid grid-cols-2 gap-3">
        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Nome/Etichetta</span>
          <input
            type="text"
            value={form.label ?? ''}
            onChange={(e) => set('label', e.target.value)}
            className="rounded border px-2 py-1"
            placeholder="Es. Mario Rossi"
          />
        </label>

        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Data (YYYY-MM-DD)</span>
          <input
            type="date"
            value={form.birth_date ?? ''}
            onChange={(e) => set('birth_date', e.target.value)}
            className="rounded border px-2 py-1"
          />
        </label>

        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Ora (HH:MM, opzionale)</span>
          <input
            type="time"
            value={form.birth_time ?? ''}
            onChange={(e) => set('birth_time', e.target.value)}
            className="rounded border px-2 py-1"
          />
        </label>

        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Latitudine</span>
          <input
            type="number"
            step="0.000001"
            value={form.birth_lat ?? 0}
            onChange={(e) => set('birth_lat', Number(e.target.value))}
            className="rounded border px-2 py-1"
            placeholder="es. 45.4642"
          />
        </label>

        <label className="flex flex-col gap-1">
          <span className="text-sm text-gray-600">Longitudine</span>
          <input
            type="number"
            step="0.000001"
            value={form.birth_lon ?? 0}
            onChange={(e) => set('birth_lon', Number(e.target.value))}
            className="rounded border px-2 py-1"
            placeholder="es. 9.1900"
          />
        </label>
      </div>

      <div className="flex items-center gap-2">
        <button
          type="submit"
          disabled={saving}
          className="rounded bg-black px-3 py-1.5 text-white text-sm disabled:opacity-50"
        >
          {saving ? 'Salvataggio…' : 'Salva persona'}
        </button>
        {okMsg && <span className="text-sm text-emerald-700">{okMsg}</span>}
        {error && <span className="text-sm text-rose-700">{error}</span>}
      </div>
    </form>
  );
}
```


## File: src\components\PersonForm.tsx

```tsx
'use client';
import React, { useState } from 'react';

type GeoApiItem = { name?: string; display_name?: string; lat: number; lon: number };
type GeoItem = { name: string; lat: number; lon: number };

function toGeoItem(r: GeoApiItem): GeoItem {
  return {
    name: r.name || r.display_name || 'loc',
    lat: Number(r.lat),
    lon: Number(r.lon),
  };
}

export default function PersonForm({ onCreated }: { onCreated?: (id: string) => void }) {
  const [label, setLabel] = useState('');
  const [date, setDate] = useState('');
  const [time, setTime] = useState('');
  const [place, setPlace] = useState('');
  const [lat, setLat] = useState<string>('');
  const [lon, setLon] = useState<string>('');
  const [searching, setSearching] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [results, setResults] = useState<GeoItem[]>([]);

  async function searchPlace() {
    if (!place.trim()) return;
    setSearching(true);
    try {
      const res = await fetch(`/api/geo/resolve?q=${encodeURIComponent(place)}&lang=it&limit=5`);
      const j: { items?: GeoApiItem[] } = await res.json();
      const items = Array.isArray(j?.items) ? j.items.map(toGeoItem) : [];
      setResults(items);
    } finally { setSearching(false); }
  }

  async function submit() {
    if (!label.trim() || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      alert('Inserisci etichetta e data (YYYY-MM-DD)');
      return;
    }
    setSubmitting(true);
    try {
      const res = await fetch('/api/people', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          label, date,
          time: time.trim() || null,
          place_name: place.trim() || null,
          lat: lat ? Number(lat) : null,
          lon: lon ? Number(lon) : null,
        }),
      });
      const j: { ok?: boolean; id?: string; error?: string } = await res.json();
      if (!res.ok || !j?.ok || !j.id) throw new Error(j?.error || 'Errore');
      // reset
      setLabel(''); setDate(''); setTime(''); setPlace(''); setLat(''); setLon(''); setResults([]);
      onCreated?.(j.id);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Errore';
      alert(message);
    } finally { setSubmitting(false); }
  }

  return (
    <div className="space-y-3">
      <div>
        <label className="block text-xs text-gray-500">Etichetta</label>
        <input className="w-full rounded border p-2" value={label}
               onChange={e=>setLabel(e.target.value)} placeholder="es. papà / collega 1 / amica 2" />
      </div>

      <div className="grid grid-cols-2 gap-3">
        <div>
          <label className="block text-xs text-gray-500">Data di nascita</label>
          <input type="date" className="w-full rounded border p-2" value={date}
                 onChange={e=>setDate(e.target.value)} />
        </div>
        <div>
          <label className="block text-xs text-gray-500">Ora (opzionale)</label>
          <input type="time" className="w-full rounded border p-2" value={time}
                 onChange={e=>setTime(e.target.value)} />
        </div>
      </div>

      <div>
        <label className="block text-xs text-gray-500">Luogo di nascita (facoltativo)</label>
        <div className="flex gap-2">
          <input className="flex-1 rounded border p-2" value={place}
                 onChange={e=>setPlace(e.target.value)} placeholder="città, paese" />
          <button type="button" className="rounded border px-3" onClick={searchPlace} disabled={searching}>
            {searching? '...' : 'Cerca'}
          </button>
        </div>
        {results.length>0 && (
          <div className="mt-2 space-y-1 text-sm">
            {results.map((r,i)=> (
              <button key={i}
                      className="block w-full text-left rounded border p-2 hover:bg-gray-50"
                      onClick={()=>{
                        setPlace(r.name);
                        setLat(String(r.lat));
                        setLon(String(r.lon));
                        setResults([]);
                      }}>
                {r.name} <span className="text-gray-500">({r.lat.toFixed(3)}, {r.lon.toFixed(3)})</span>
              </button>
            ))}
          </div>
        )}
      </div>

      <div className="grid grid-cols-2 gap-3">
        <div>
          <label className="block text-xs text-gray-500">Lat (facoltativa)</label>
          <input className="w-full rounded border p-2" value={lat} onChange={e=>setLat(e.target.value)} />
        </div>
        <div>
          <label className="block text-xs text-gray-500">Lon (facoltativa)</label>
          <input className="w-full rounded border p-2" value={lon} onChange={e=>setLon(e.target.value)} />
        </div>
      </div>

      <button type="button" className="rounded-lg border px-4 py-2" onClick={submit} disabled={submitting}>
        {submitting? 'Salvo…' : 'Aggiungi persona'}
      </button>
      <p className="text-xs text-gray-500">Se non inserisci il luogo, useremo la posizione attuale dell’utente per i calcoli “oggi”.</p>
    </div>
  );
}

```


## File: src\components\SignOutButton.tsx

```tsx
'use client';

export default function SignOutButton() {
  async function signOut() {
    await fetch('/api/auth/signout', { method: 'POST' });
    window.location.href = '/';
  }
  return (
    <button className="rounded border px-3 py-1 text-sm" onClick={signOut}>
      Sign out
    </button>
  );
}

```


## File: src\components\sinastriatest.tsx

```tsx

```


## File: src\components\SkyWheel.tsx

```tsx
// src/components/SkyWheel.tsx
'use client';

import React from 'react';

export type SkyPoint = {
  name: string;        // Sun..Pluto, ASC, MC
  longitude: number;   // 0..360
  sign: string;
  house: number | null;
  retro: boolean;
};

const GLYPH: Record<string, string> = {
  Sun: '☉',
  Moon: '☾',
  Mercury: '☿',
  Venus: '♀',
  Mars: '♂',
  Jupiter: '♃',
  Saturn: '♄',
  Uranus: '♅',
  Neptune: '♆',
  Pluto: '♇',
  ASC: 'ASC',
  MC: 'MC',
};

const SIGNS = [
  'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
  'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
];

export default function SkyWheel({
  title,
  points,
}: {
  title: string;
  points: SkyPoint[];
}) {
  // dimensioni
  const size = 320;
  const r = size / 2;

  return (
    <div className="rounded-2xl border p-4 bg-white">
      <div className="mb-3 text-sm font-medium">{title}</div>
      <div
        className="relative mx-auto"
        style={{ width: size, height: size }}
        aria-label={title}
      >
        {/* cerchio esterno */}
        <div
          className="absolute inset-0 rounded-full border"
          aria-hidden="true"
        />
        {/* tacche segni (12) */}
        {Array.from({ length: 12 }).map((_, i) => {
          const angle = (i * 30) - 90; // 0° a destra → ruotiamo per avere 0° in alto
          return (
            <div
              key={i}
              className="absolute left-1/2 top-1/2 origin-left"
              style={{
                transform: `rotate(${angle}deg) translateX(${r - 12}px)`,
                width: 12,
                height: 2,
                background: '#e5e7eb',
              }}
              aria-hidden="true"
            />
          );
        })}
        {/* etichette segni */}
        {SIGNS.map((s, i) => {
          const angle = (i * 30) - 90;
          const rr = r - 28;
          return (
            <div
              key={s}
              className="absolute left-1/2 top-1/2 text-[10px] text-gray-600"
              style={{
                transform: `rotate(${angle}deg) translateX(${rr}px) rotate(${-angle}deg)`,
                transformOrigin: '0 0',
              }}
              aria-hidden="true"
            >
              {s}
            </div>
          );
        })}
        {/* pianeti/punti */}
        {points.map((p, idx) => {
          const a = p.longitude - 90; // portiamo 0° in alto
          const rr = r - 56;
          const label = GLYPH[p.name] ?? p.name;
          return (
            <div
              key={`${p.name}-${idx}`}
              className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-xs"
              style={{
                transform: `rotate(${a}deg) translate(${rr}px) rotate(${-a}deg)`,
              }}
              title={`${p.name} ${p.sign}${p.house ? ` · H${p.house}` : ''}${p.retro ? ' (R)' : ''}`}
            >
              <span className="inline-flex items-center gap-1 rounded-lg border px-2 py-0.5 bg-white">
                <span>{label}</span>
                <span className="text-[10px] text-gray-500">
                  {p.sign}{p.house ? `·${p.house}` : ''}{p.retro ? 'R' : ''}
                </span>
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
}

```


## File: src\components\TransitsPanel.tsx

```tsx
// src/components/TransitsPanel.tsx
'use client';

import { useMemo, useState } from 'react';
import dynamic from 'next/dynamic';
import { computeDailyPlanets, type RuntimePoint } from '@/lib/planets/runtime';
import { assignHouses } from '@/lib/houses/placidus';

type NatalPoint = { name: string; longitude: number; sign?: string };
type HouseSystem = 'placidus' | 'whole';

type Props = {
  system: HouseSystem;
  natalCusps: number[];     // 12 cuspidi in gradi 0..360
  natalAsc?: number | null; // opzionale
  natalMc?: number | null;  // opzionale
  natalPoints: NatalPoint[]; // posizioni natali per calcolo aspetti
};

type ChartPoint = {
  name: string;
  longitude: number;
  sign: string;
  house: number | null;
  retro?: boolean | null;
};

const ChartWheel = dynamic<{
  points: ChartPoint[];
  houseCusps?: number[];
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';
  showHouseNumbers?: boolean;
  showZodiacRing?: boolean;
  size?: number;
  className?: string;
}>(() => import('@/components/ChartWheel'), { ssr: false });

function normDeg(x: number): number { return ((x % 360) + 360) % 360; }
function sepDeg(a: number, b: number): number {
  // distanza angolare 0..180
  let d = Math.abs(normDeg(a) - normDeg(b));
  if (d > 180) d = 360 - d;
  return d;
}

type AspectDef = { name: string; angle: number; orb: number; weight: number };
const ASPECTS: AspectDef[] = [
  { name: 'Conjunction', angle: 0,   orb: 6, weight: 5 },
  { name: 'Opposition',  angle: 180, orb: 6, weight: 4 },
  { name: 'Square',      angle: 90,  orb: 5, weight: 4 },
  { name: 'Trine',       angle: 120, orb: 4, weight: 3 },
  { name: 'Sextile',     angle: 60,  orb: 3, weight: 2 },
];

function bestAspect(tLon: number, nLon: number) {
  const s = sepDeg(tLon, nLon);
  let best: { aspect: AspectDef; orb: number; score: number } | null = null;
  for (const a of ASPECTS) {
    const orb = Math.abs(s - a.angle);
    if (orb <= a.orb) {
      const score = a.weight * (1 - orb / a.orb); // 0..weight
      if (!best || score > best.score) best = { aspect: a, orb, score };
    }
  }
  return best;
}

export default function TransitsPanel({ system, natalCusps, natalMc, natalPoints }: Props) {
  // inizializzo il date picker all'oggi (UTC)
  const todayISO = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
  const [dateISO, setDateISO] = useState<string>(todayISO);

  const dateUTC = useMemo(() => new Date(`${dateISO}T00:00:00Z`), [dateISO]);

  // Pianeti in transito per la data selezionata
  const transitPlanets: RuntimePoint[] = useMemo(
    () => computeDailyPlanets(dateUTC),
    [dateUTC]
  );

  // Assegno la casa in base alle cuspidi NATALI selezionate
  const pointsForWheel: ChartPoint[] = useMemo(
    () =>
      transitPlanets.map(p => ({
        name: p.name,
        longitude: p.longitude,
        sign: p.sign,
        house: assignHouses(p.longitude, natalCusps),
        retro: false, // evito il simbolo ℞/Px nella ruota dei transiti
      })),
    [transitPlanets, natalCusps]
  );

  // “Top 3” transiti del giorno contro i punti natali
  const top3 = useMemo(() => {
    type Hit = { score: number; orb: number; aspect: string; tName: string; nName: string };
    const hits: Hit[] = [];
    for (const t of transitPlanets) {
      for (const n of natalPoints) {
        const match = bestAspect(t.longitude, n.longitude);
        if (match) {
          hits.push({
            score: Number(match.score.toFixed(3)),
            orb: Number(match.orb.toFixed(2)),
            aspect: match.aspect.name,
            tName: t.name,
            nName: n.name,
          });
        }
      }
    }
    return hits.sort((a, b) => b.score - a.score).slice(0, 3);
  }, [transitPlanets, natalPoints]);

  return (
    <div className="space-y-4">
      {/* 1) Date picker */}
      <div>
        <label className="block text-sm font-medium mb-1">Seleziona data</label>
        <input
          type="date"
          className="border rounded-md px-3 py-2 text-sm"
          value={dateISO}
          onChange={(e) => setDateISO(e.target.value)}
        />
      </div>

      {/* 2) Ruota: pianeti in transito sulle case natali */}
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="font-semibold">
            Transits — {system === 'placidus' ? 'Placidus' : 'Whole Sign'}
          </h3>
          <span className="text-xs text-gray-500">{dateISO} (UTC)</span>
        </div>

        <ChartWheel
          points={pointsForWheel}
          houseCusps={natalCusps}
          mcDeg={natalMc ?? natalCusps[9]}
          orientation="by-asc"
          showZodiacRing
          showHouseNumbers
          size={520}
        />
      </div>

      {/* 3) Top 3 transiti */}
      <div className="rounded-2xl border p-4">
        <h3 className="font-semibold mb-2">Top 3 transiti del giorno</h3>
        {top3.length === 0 ? (
          <p className="text-sm text-gray-600">Nessun aspetto rilevante entro gli orbi standard.</p>
        ) : (
          <ul className="space-y-2 text-sm">
            {top3.map((h, i) => (
              <li key={i} className="flex items-center justify-between">
                <span>
                  <span className="font-medium">{h.tName}</span> {h.aspect}{' '}
                  <span className="font-medium">{h.nName}</span>
                  <span className="text-gray-500"> (orb {h.orb}°)</span>
                </span>
                <span className="text-xs px-2 py-0.5 rounded bg-gray-100">score {h.score}</span>
              </li>
            ))}
          </ul>
        )}
        <p className="mt-2 text-xs text-gray-500">
          Ranking basato su pesi: Conj 5, Opp/Sq 4, Tr 3, Sx 2; ridotto linearmente con l’orb.
        </p>
      </div>
    </div>
  );
}

```


## File: src\components\TransitsToday.tsx

```tsx
// src/components/TransitsToday.tsx
import React from 'react';
import { headers, cookies } from 'next/headers';

type TransitItem = {
  date: string;
  t_planet: string;
  n_point: string;
  aspect: string;   // 'conjunction' | 'sextile' | ...
  orb: number;
  score: number;
};

function todayISO(): string {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}

function ymOfToday(): string {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  return `${yyyy}-${mm}`;
}

function symbolForAspect(a: string): string {
  switch (a) {
    case 'conjunction': return '☌';
    case 'sextile':     return '✶';
    case 'square':      return '□';
    case 'trine':       return '△';
    case 'opposition':  return '☍';
    default:            return a;
  }
}

export default async function TransitsToday() {
  const date = todayISO();
  const ym = ymOfToday();

  // Costruiamo un URL assoluto basandoci sugli header della richiesta
  const h = headers();
  const host = h.get('x-forwarded-host') ?? h.get('host') ?? 'localhost:3000';
  const proto = h.get('x-forwarded-proto') ?? 'http';
  const baseUrl = `${proto}://${host}`;

  const res = await fetch(`${baseUrl}/api/transits?date=${date}`, {
    cache: 'no-store',
    headers: { cookie: cookies().toString() }, // mantiene la sessione → niente 401
  });

  if (!res.ok) {
    return (
      <div className="space-y-3">
        <div className="text-sm text-red-700">Errore nel calcolo dei transiti ({res.status}).</div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi mese
        </a>
      </div>
    );
  }

  const data = (await res.json()) as { ok?: boolean; top?: TransitItem[]; error?: string };

  if (!data.ok || !data.top || data.top.length === 0) {
    return (
      <div className="space-y-3">
        <div className="text-sm text-gray-600">Nessun transito rilevante per oggi.</div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi mese
        </a>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <span className="text-sm text-gray-700">Stai vedendo i</span>
        <span className="text-xs rounded-full bg-gray-100 px-2 py-1 text-gray-700">Top 5</span>
      </div>

      <ul className="space-y-3">
        {data.top.map((t, idx) => (
          <li key={`${t.t_planet}-${t.n_point}-${idx}`} className="rounded-xl border p-3">
            <div className="flex items-center justify-between">
              <div className="font-medium">
                {t.t_planet} {symbolForAspect(t.aspect)} {t.n_point}
              </div>
              <div className="text-xs text-gray-500">
                orb {t.orb.toFixed(1)}° • score {Math.round(t.score)}
              </div>
            </div>
            <div className="text-xs text-gray-600">Date: {t.date}</div>
          </li>
        ))}
      </ul>

      <div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi tutti i transiti del mese
        </a>
      </div>
    </div>
  );
}

```


## File: src\lib\aspects.ts

```ts
// FILE: src/lib/aspects.ts
import { z } from "zod";

export type PointName =
  | "Sun" | "Moon" | "Mercury" | "Venus" | "Mars"
  | "Jupiter" | "Saturn" | "Uranus" | "Neptune" | "Pluto"
  | "Asc" | "Mc" | "NNode" | "SNode";

export type AspectKey = "conj" | "sext" | "sq" | "tri" | "opp";
export type Aspect = { key: AspectKey; deg: number; label: string };

export const ASPECTS: Record<AspectKey, Aspect> = {
  conj: { key: "conj", deg: 0, label: "Conjunction" },
  sext: { key: "sext", deg: 60, label: "Sextile" },
  sq:   { key: "sq",   deg: 90, label: "Square" },
  tri:  { key: "tri",  deg: 120, label: "Trine" },
  opp:  { key: "opp",  deg: 180, label: "Opposition" },
};

const BASE_ORB: Record<AspectKey, number> = {
  conj: 8, sext: 4, sq: 6, tri: 6, opp: 8,
};

function isLuminary(p: PointName): boolean {
  return p === "Sun" || p === "Moon";
}

export function maxOrbForPair(a: PointName, b: PointName, aspect: AspectKey): number {
  const lumBonus = (isLuminary(a) || isLuminary(b)) ? 2 : 0;
  const anglePenalty = (a === "Asc" || a === "Mc" || b === "Asc" || b === "Mc") ? -1 : 0;
  return Math.max(1, BASE_ORB[aspect] + lumBonus + anglePenalty);
}

export function acuteDelta(a: number, b: number): number {
  let d = Math.abs(a - b) % 360;
  if (d > 180) d = 360 - d;
  return d;
}

export type AspectHit = { aspect: Aspect; orb: number; ok: boolean };

export function closestAspectDelta(delta: number): AspectHit {
  let best: AspectHit = { aspect: ASPECTS.conj, orb: Math.abs(delta - 0), ok: false };
  for (const a of Object.values(ASPECTS)) {
    const orb = Math.abs(delta - a.deg);
    if (orb < best.orb) best = { aspect: a, orb, ok: false };
  }
  return best;
}

export const PointSchema = z.object({
  name: z.string(),
  longitude: z.number().min(0).max(360),
  retro: z.boolean().optional(),
});
export type Point = z.infer<typeof PointSchema>;

```


## File: src\lib\astro.ts

```ts
// src/lib/astro.ts
import { DateTime } from 'luxon';
import * as Astronomy from 'astronomy-engine';

export type BodyName =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';

export type AngleName = 'ASC' | 'MC';
export type PointName = BodyName | AngleName;

export type Point = {
  name: PointName;
  longitude: number;       // 0..360 eclittica geocentrica
  sign: string;            // Aries..Pisces
  house: number | null;    // 1..12 se noto, altrimenti null
  retro: boolean;          // pianeti; ASC/MC=false
};

export type AspectType =
  | 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

export type NatalAspect = {
  p1: PointName;
  p2: PointName;
  aspect: AspectType;
  orb: number;        // scarto dall’esatto in °
  strength: number;   // 0..100 circa
};

const OBLIQUITY = (23.4392911 * Math.PI) / 180; // rad, J2000 (ok per MVP)

const SIGN_NAMES = [
  'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
  'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
] as const;

export function normalizeDeg(x: number): number {
  let d = x % 360;
  if (d < 0) d += 360;
  return d;
}

function rad(d: number): number { return (d * Math.PI) / 180; }
function deg(r: number): number { return (r * 180) / Math.PI; }

export function signFromLongitude(lon: number): string {
  const i = Math.floor(normalizeDeg(lon) / 30) % 12;
  return SIGN_NAMES[i];
}

function eclipticFromEquatorial(eq: Astronomy.EquatorialCoordinates): { elon: number; elat: number } {
  // conversione esplicita (oppure si può usare Astronomy.Ecliptic(eq))
  const ra = eq.ra * 15; // ore → gradi
  const dec = eq.dec;    // gradi
  const raRad = rad(ra);
  const decRad = rad(dec);
  const sinE = Math.sin(OBLIQUITY);
  const cosE = Math.cos(OBLIQUITY);
  const sinDec = Math.sin(decRad);
  const cosDec = Math.cos(decRad);
  const sinRa = Math.sin(raRad);
  const cosRa = Math.cos(raRad);
  const elat = Math.asin(sinDec * cosE - cosDec * sinE * sinRa);
  const y = sinRa * cosE + Math.tan(decRad) * sinE;
  const x = cosRa;
  const elon = Math.atan2(y, x);
  return { elon: normalizeDeg(deg(elon)), elat: deg(elat) };
}

/**
 * Longitudine eclittica geocentrica “of date” senza passare un Observer:
 * usiamo GeoVector (geocentrico) → EquatorFromVector → conversione a eclittiche.
 */
function geocentricEclipticLongitude(body: Astronomy.Body, date: Date): number {
  // true = ofDate vector (correzioni appropriate per l’epoca)
  const vec = Astronomy.GeoVector(body, date, true);
  const eq = Astronomy.EquatorFromVector(vec); // RA/Dec
  const ecl = eclipticFromEquatorial(eq);
  return ecl.elon;
}

function isRetrograde(body: Astronomy.Body, date: Date): boolean {
  const prev = new Date(date.getTime() - 24 * 3600 * 1000);
  const lonNow = geocentricEclipticLongitude(body, date);
  const lonPrev = geocentricEclipticLongitude(body, prev);
  let diff = normalizeDeg(lonNow - lonPrev);
  if (diff > 180) diff -= 360; // -180..+180
  return diff < 0;
}

function localSiderealAngle(date: Date, lonDeg: number): number {
  const gstHours = Astronomy.SiderealTime(date); // ore
  return rad(normalizeDeg(gstHours * 15 + lonDeg)); // rad
}

function ascendantLongitude(date: Date, latDeg: number, lonDeg: number): number {
  const phi = rad(latDeg);
  const sinPhi = Math.sin(phi);
  const cosPhi = Math.cos(phi);
  const theta = localSiderealAngle(date, lonDeg);

  let bestLam = 0;
  let bestScore = 1e12;

  // Più fine ⇒ più preciso sul SEGNO (0.1° ok per MVP)
  const step = 0.1;

  for (let lam = 0; lam < 360; lam += step) {
    const l = rad(lam);

    // β=0 → RA/Dec sull'eclittica
    const sinLam = Math.sin(l);
    const cosLam = Math.cos(l);
    const sinDec = Math.sin(OBLIQUITY) * sinLam;
    const dec = Math.asin(sinDec);
    const ra = Math.atan2(sinLam * Math.cos(OBLIQUITY), cosLam);

    // Angolo orario
    let H = theta - ra;
    H = Math.atan2(Math.sin(H), Math.cos(H)); // normalizza -π..π

    // Alt/Az (convenz. astronomica: 0°=Sud, 90°=Ovest, 180°=Nord, 270°=Est)
    const alt = Math.asin(sinPhi * Math.sin(dec) + cosPhi * Math.cos(dec) * Math.cos(H));
    const az = Math.atan2(
      Math.sin(H),
      Math.cos(H) * sinPhi - Math.tan(dec) * Math.cos(phi)
    );
    const azDeg = normalizeDeg(deg(az));
    const absAlt = Math.abs(deg(alt));

    // Distanza angolare dall'Est (270°), considerando il wrap
    const distEast = Math.min(Math.abs(azDeg - 270), Math.abs(azDeg + 90)); // 270° ≡ -90°

    // Score: vogliamo alt≈0 (orizzonte) E vicino a Est (270°)
    const score = absAlt + 0.05 * distEast;

    if (score < bestScore) {
      bestScore = score;
      bestLam = lam;
    }
  }

  return bestLam; // è già l'Ascendente (scelto a Est)
}


function midheavenLongitude(date: Date, lonDeg: number): number {
  const theta = localSiderealAngle(date, lonDeg);
  const num = Math.sin(theta);
  const den = Math.cos(OBLIQUITY) * Math.cos(theta);
  const lam = Math.atan2(num, den);
  return normalizeDeg(deg(lam));
}

export function computePoints(
  tzName: string | null,
  dateISO: string,            // YYYY-MM-DD
  timeHHMM: string | null,    // HH:MM locale (null => 12:00)
  lat: number | null,
  lon: number | null
): { points: Point[]; houses: boolean; timestampUTC: Date } {
  const localTime = timeHHMM ?? '12:00';
  const dtLocal = DateTime.fromISO(`${dateISO}T${localTime}`, { zone: tzName ?? 'UTC' });
  const dtUtc = dtLocal.toUTC();
  const when = dtUtc.toJSDate();

  const bodies: { name: BodyName; body: Astronomy.Body }[] = [
    { name: 'Sun', body: Astronomy.Body.Sun },
    { name: 'Moon', body: Astronomy.Body.Moon },
    { name: 'Mercury', body: Astronomy.Body.Mercury },
    { name: 'Venus', body: Astronomy.Body.Venus },
    { name: 'Mars', body: Astronomy.Body.Mars },
    { name: 'Jupiter', body: Astronomy.Body.Jupiter },
    { name: 'Saturn', body: Astronomy.Body.Saturn },
    { name: 'Uranus', body: Astronomy.Body.Uranus },
    { name: 'Neptune', body: Astronomy.Body.Neptune },
    { name: 'Pluto', body: Astronomy.Body.Pluto }
  ];

  const planetPoints: Point[] = bodies.map(({ name, body }) => {
    const lonEcl = geocentricEclipticLongitude(body, when);
    const retro = isRetrograde(body, when);
    return {
      name,
      longitude: lonEcl,
      sign: signFromLongitude(lonEcl),
      house: null,
      retro
    };
  });

  let asc: Point | null = null;
  let mc: Point | null = null;
  let haveHouses = false;

  if (timeHHMM && lat != null && lon != null) {
    const λasc = ascendantLongitude(when, lat, lon);
    const λmc  = midheavenLongitude(when, lon);
    const ascSign = signFromLongitude(λasc);

    asc = { name: 'ASC', longitude: λasc, sign: ascSign, house: 1, retro: false };
    mc  = { name: 'MC',  longitude: λmc,  sign: signFromLongitude(λmc), house: null, retro: false };

    const ascIndex = Math.floor(normalizeDeg(λasc) / 30);
    for (const p of planetPoints) {
      const pIndex = Math.floor(normalizeDeg(p.longitude) / 30);
      const diff = (pIndex - ascIndex + 12) % 12;
      p.house = diff + 1;
    }
    haveHouses = true;
  }

  const allPoints = asc && mc ? [...planetPoints, asc, mc] : planetPoints;
  return { points: allPoints, houses: haveHouses, timestampUTC: when };
}

// ──────────────────────────────── Aspetti ────────────────────────────────────

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang';
}

function orbMax(p1: PointName, p2: PointName): number {
  const c1 = classOfPoint(p1);
  const c2 = classOfPoint(p2);
  if (c1 === 'lum' || c2 === 'lum') return 6;
  if (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function pointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeNatalAspects(points: Point[]): NatalAspect[] {
  const res: NatalAspect[] = [];
  const targets: AspectType[] = ['conjunction', 'sextile', 'square', 'trine', 'opposition'];

  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      const A = points[i];
      const B = points[j];
      const d = minAngle(A.longitude, B.longitude);

      let best: { type: AspectType; diff: number } | null = null;
      for (const t of targets) {
        const target = ASPECT_DEGREES[t];
        const diff = Math.abs(d - target);
        if (best === null || diff < best.diff) best = { type: t, diff };
      }
      if (!best) continue;

      const maxOrb = orbMax(A.name, B.name);
      if (best.diff <= maxOrb) {
        const aw = aspectWeight(best.type);
        const pw = pointWeight(A.name) * pointWeight(B.name);
        const tightness = 1 - best.diff / maxOrb;
        const strength = Math.round(100 * aw * pw * (0.6 + 0.4 * tightness));
        res.push({
          p1: A.name,
          p2: B.name,
          aspect: best.type,
          orb: parseFloat(best.diff.toFixed(2)),
          strength
        });
      }
    }
  }
  return res;
}

// ──────────────────────────────── House systems factory ──────────────────────
import { computePlacidusCusps, assignHouses as assignHousesPlacidus } from '@/lib/houses/placidus';
import { computeWholeCuspsFromAsc } from '@/lib/houses/whole';
import { normalizeAngle as _norm } from '@/lib/houses/common';

export type HouseSystem = 'whole' | 'placidus';

/**
 * Calcola cuspidi/ASC/MC per il sistema scelto (Whole o Placidus).
 * Inputs:
 * - jd: Julian Day UT
 * - latDeg/lonDeg: coordinate geografiche (E+, W-)
 * - tzMinutes: non usato per il calcolo (coerenza firma)
 */
export function computeHouses(
  system: HouseSystem,
  args: { jd: number; latDeg: number; lonDeg: number; tzMinutes: number }
):
  | { system: 'whole'; cusps: number[]; asc: number; mc: number; fallbackApplied?: boolean }
  | { system: 'placidus'; cusps: number[]; asc: number; mc: number; fallbackApplied?: boolean } {
  const { jd, latDeg, lonDeg } = args;

  // Per ASC/MC “whole” possiamo riutilizzare le funzioni esistenti basate su Date;
  // ricostruiamo Date UTC da JD per coerenza con il resto del file.
  const when = new Date((jd - 2440587.5) * 86400000);

  if (system === 'placidus') {
    // Placidus calcola già ASC/MC e le 12 cuspidi
    return computePlacidusCusps(jd, latDeg, lonDeg);
  }

  // WHOLE SIGN:
  const ascDeg = ascendantLongitude(when, latDeg, lonDeg);
  const mcDeg = midheavenLongitude(when, lonDeg);
  return computeWholeCuspsFromAsc(ascDeg, mcDeg);
}

/**
 * Assegna il numero di casa (1..12) ad un punto dato un set di cuspidi.
 * Attenzione: per Placidus usiamo la funzione robusta del modulo Placidus (wrap-safe).
 * Per Whole, le cuspidi sono equispaziate; la regola è identica.
 */
export function assignHousesGeneric(longitudeDeg: number, cusps: number[]): number {
  return assignHousesPlacidus(_norm(longitudeDeg), cusps);
}


```


## File: src\lib\composer.ts

```ts
// src/lib/composer.ts
import { supabaseAdmin } from '@/lib/supabaseAdmin';
import { chatComplete } from '@/lib/openai';
import {
  type PointName,
  type AspectType,
} from '@/lib/astro';
import {
  computeTransitingLongitudes,
  computeTransitEventsForDay,
  type TransitEventCalc,
} from '@/lib/transits';
import { systemRefiner, fewShot_planet, fewShot_transit } from '@/ai/systemPrompts';

type Focus = 'work' | 'relationships' | 'energy';
type Lang = 'en' | 'it' | 'es' | 'pt';

type NatalPoint = { name: PointName; longitude: number; house: number | null; sign: string };
type InterpretationRow = { id: number; type: string; key: string; title: string | null; summary: string | null; tips: string | null };

function ensureUserId(user_id?: string): string {
  const env = process.env.DEV_USER_ID;
  const uid = (user_id && user_id.length > 0) ? user_id : env;
  if (!uid) throw new Error('Missing user_id or DEV_USER_ID');
  return uid;
}

function aiBypassOn(): boolean {
  return String(process.env.AI_BYPASS).toLowerCase() === 'true' || !process.env.OPENAI_API_KEY;
}

// ———————————————— Helpers DB ————————————————

async function loadNatalPoints(user_id: string): Promise<NatalPoint[]> {
  const { data, error } = await supabaseAdmin
    .from('chart_points')
    .select('name, longitude, house, sign')
    .eq('user_id', user_id);
  if (error) throw new Error(`chart_points.select: ${error.message}`);
  return (data ?? []).map(r => ({
    name: r.name as PointName,
    longitude: r.longitude as number,
    house: r.house as number | null,
    sign: String(r.sign),
  }));
}

async function loadInterpretations(keys: string[], types: string[]): Promise<InterpretationRow[]> {
  const { data, error } = await supabaseAdmin
    .from('interpretations')
    .select('id, type, key, title, summary, tips')
    .in('type', types)
    .in('key', keys);
  if (error) throw new Error(`interpretations.select: ${error.message}`);
  return data ?? [];
}

// ———————————————— Composer Natal ————————————————

export async function composeNatalSkeleton(user_id?: string) {
  const uid = ensureUserId(user_id);
  const points = await loadNatalPoints(uid);

  const keys: string[] = [];
  for (const p of points) {
    if (p.name === 'ASC' || p.name === 'MC') continue;
    keys.push(`${p.name}_${p.sign}`, `${p.name}@${p.sign}`);
    if (p.house) keys.push(`${p.name}_${p.house}`, `${p.name}@${p.house}`);
  }

  const rows = await loadInterpretations(keys, ['planet_in_sign', 'planet_in_house']);

  const bullets: string[] = [];
  const actions: string[] = [];

  for (const p of points) {
    if (p.name === 'ASC' || p.name === 'MC') continue;
    const signCard = rows.find(r => r.key === `${p.name}_${p.sign}` || r.key === `${p.name}@${p.sign}`);
    const houseCard = p.house ? rows.find(r => r.key === `${p.name}_${p.house}` || r.key === `${p.name}@${p.house}`) : undefined;

    const title = `${p.name} in ${p.sign}${p.house ? ` (House ${p.house})` : ''}`;
    const sum = [signCard?.summary, houseCard?.summary].filter(Boolean).join(' ');
    bullets.push(`• ${title}: ${sum || 'natural strengths you can apply with patience and flexibility.'}`);

    const tipsMerge = [signCard?.tips, houseCard?.tips].filter(Boolean).join(' ');
    if (tipsMerge) {
      const split = tipsMerge.split(/[\n•\-]+/).map(s => s.trim()).filter(s => s.length > 0);
      actions.push(...split.slice(0, 2));
    }
  }

  if (actions.length === 0) {
    actions.push('Write 3 lines about what energizes you today.');
    actions.push('Tidy one small area for 5 minutes.');
  }

  return { bullets, actions: actions.slice(0, 6) };
}

function buildNatalEN(skeleton: { bullets: string[]; actions: string[] }, focus: Focus[]): string {
  const f = focus.length ? focus.join(', ') : 'general';
  return [
    `Here’s a gentle read of your natal chart themes (focus: ${f}).`,
    '',
    ...skeleton.bullets,
    '',
    'Try today:',
    ...skeleton.actions.map(a => `• ${a}`),
    '',
    'Disclaimer: For wellness/entertainment only. Not medical, legal, or financial advice.'
  ].join('\n');
}

export async function refineNatalText(skeleton: { bullets: string[]; actions: string[] }, focus: Focus[], lang: Lang = 'en') {
  if (aiBypassOn()) {
    // Bypass: ritorna EN semplice
    const textEN = buildNatalEN(skeleton, focus);
    return lang === 'en' ? textEN : textEN; // in bypass manteniamo EN
  }

  const userMsg = [
    `User focus: ${focus.join(', ') || 'general'}.`,
    'Skeleton:',
    ...skeleton.bullets,
    'Micro-actions:',
    ...skeleton.actions.map(a => `- ${a}`)
  ].join('\n');

  const contentEN = await chatComplete(
    [
      { role: 'system', content: systemRefiner },
      { role: 'user', content: fewShot_planet.user },
      { role: 'assistant', content: fewShot_planet.assistant },
      { role: 'user', content: userMsg },
    ],
    true
  );

  if (lang === 'en') return contentEN;

  const langLabel = lang === 'it' ? 'Italian' : lang === 'es' ? 'Spanish' : 'Portuguese';
  const translated = await chatComplete(
    [
      { role: 'system', content: 'Translate to the requested language preserving tone and bullet structure. Keep it concise.' },
      { role: 'user', content: `Language: ${langLabel}\n\n${contentEN}` }
    ],
    true
  );
  return translated;
}

// ———————————————— Composer Transits ————————————————

export async function composeTransitsSkeleton(user_id?: string, dateIso?: string, limit = 5) {
  const uid = ensureUserId(user_id);
  const date = dateIso ?? new Date().toISOString().slice(0, 10);

  const points = await loadNatalPoints(uid);
  const natalLite = points.map(p => ({ name: p.name, longitude: p.longitude }));

  const longs = computeTransitingLongitudes(date);
  const events = computeTransitEventsForDay(date, longs, natalLite);
  const top = events.slice(0, limit);

  const keys: string[] = [];
  for (const e of top) {
    keys.push(`${e.t_planet}_${e.aspect}_${e.n_point}`, `${e.t_planet}@${e.n_point}@${e.aspect}`);
  }
  const rows = await loadInterpretations(keys, ['transit_to_nat']);

  const bullets: string[] = [];
  const actions: string[] = [];

  for (const e of top) {
    const title = `${e.t_planet} ${labelAspect(e.aspect)} ${e.n_point} (orb ${e.orb}°)`;
    const card = rows.find(r =>
      r.key === `${e.t_planet}_${e.aspect}_${e.n_point}` ||
      r.key === `${e.t_planet}@${e.n_point}@${e.aspect}`
    );
    bullets.push(`• ${title}: ${card?.summary || 'energy pattern you can use with awareness.'}`);

    if (card?.tips) {
      const split = card.tips.split(/[\n•\-]+/).map(s => s.trim()).filter(s => s.length > 0);
      actions.push(...split.slice(0, 2));
    }
  }

  if (actions.length === 0) {
    actions.push('2 minutes of slow breathing (inhale 4, exhale 6).');
    actions.push('Write one line about your intention today.');
  }

  return { date, bullets, actions, top };
}

function buildTransitsEN(skeleton: { date: string; bullets: string[]; actions: string[] }, focus: Focus[]): string {
  const f = focus.length ? focus.join(', ') : 'general';
  return [
    `Transits for ${skeleton.date} (focus: ${f}).`,
    '',
    ...skeleton.bullets,
    '',
    'Try today:',
    ...skeleton.actions.map(a => `• ${a}`),
    '',
    'Disclaimer: For wellness/entertainment only. Not medical, legal, or financial advice.'
  ].join('\n');
}

export async function refineTransitText(
  skeleton: { date: string; bullets: string[]; actions: string[]; top: TransitEventCalc[] },
  focus: Focus[],
  lang: Lang = 'en'
) {
  if (aiBypassOn()) {
    const textEN = buildTransitsEN(skeleton, focus);
    return lang === 'en' ? textEN : textEN; // in bypass manteniamo EN
  }

  const userMsg = [
    `Date: ${skeleton.date}`,
    `User focus: ${focus.join(', ') || 'general'}.`,
    'Transit bullets:',
    ...skeleton.bullets,
    'Micro-actions:',
    ...skeleton.actions.map(a => `- ${a}`)
  ].join('\n');

  const contentEN = await chatComplete(
    [
      { role: 'system', content: systemRefiner },
      { role: 'user', content: fewShot_transit.user },
      { role: 'assistant', content: fewShot_transit.assistant },
      { role: 'user', content: userMsg },
    ],
    true
  );

  if (lang === 'en') return contentEN;

  const langLabel = lang === 'it' ? 'Italian' : lang === 'es' ? 'Spanish' : 'Portuguese';
  const translated = await chatComplete(
    [
      { role: 'system', content: 'Translate to the requested language preserving tone and bullet structure. Keep it concise.' },
      { role: 'user', content: `Language: ${langLabel}\n\n${contentEN}` }
    ],
    true
  );
  return translated;
}

// ———————————————— Utils ————————————————

function labelAspect(a: AspectType): string {
  switch (a) {
    case 'conjunction': return 'conjunct';
    case 'sextile':     return 'sextile to';
    case 'square':      return 'square to';
    case 'trine':       return 'trine to';
    case 'opposition':  return 'opposition to';
  }
}

```


## File: src\lib\geo.ts

```ts
// src/lib/geo.ts
import { DateTime } from 'luxon';
import tzLookup from 'tz-lookup';

export type GeoSearchItem = {
  place_id: string;
  display_name: string;
  name?: string;
  lat: number;
  lon: number;
  type?: string;
  class?: string;
  address?: {
    city?: string;
    town?: string;
    village?: string;
    state?: string;
    country?: string;
    country_code?: string;
  };
};

type CacheEntry<T> = { value: T; expires: number };

const ONE_HOUR = 60 * 60 * 1000;
const CACHE_TTL_MS = ONE_HOUR;
const RATE_LIMIT_MS = 1100;

declare global {
  // eslint-disable-next-line no-var
  var __geoCache: Map<string, CacheEntry<unknown>> | undefined;
  // eslint-disable-next-line no-var
  var __lastNominatimFetch: number | undefined;
}

if (!globalThis.__geoCache) globalThis.__geoCache = new Map<string, CacheEntry<unknown>>();
if (typeof globalThis.__lastNominatimFetch !== 'number') globalThis.__lastNominatimFetch = 0;

const cache = globalThis.__geoCache as Map<string, CacheEntry<unknown>>;

function setCache<T>(key: string, value: T, ttlMs = CACHE_TTL_MS): void {
  cache.set(key, { value, expires: Date.now() + ttlMs });
}

function getCache<T>(key: string): T | null {
  const hit = cache.get(key);
  if (!hit) return null;
  if (hit.expires <= Date.now()) {
    cache.delete(key);
    return null;
  }
  return hit.value as T;
}

async function respectRateLimit(): Promise<void> {
  const last = globalThis.__lastNominatimFetch ?? 0;
  const since = Date.now() - last;
  if (since < RATE_LIMIT_MS) {
    await new Promise((r) => setTimeout(r, RATE_LIMIT_MS - since));
  }
}

function toStringSafe(v: unknown): string {
  return typeof v === 'string' ? v : String(v ?? '');
}

function toNumberSafe(v: unknown): number {
  const n = Number(v);
  if (Number.isFinite(n)) return n;
  const s = toStringSafe(v);
  const pf = parseFloat(s);
  return Number.isFinite(pf) ? pf : NaN;
}

export async function nominatimSearch(q: string, limit = 5): Promise<GeoSearchItem[]> {
  const base = process.env.GEOCODING_BASE_URL || 'https://nominatim.openstreetmap.org';
  const email = process.env.GEOCODING_EMAIL;
  const key = `nominatim:${q}:${limit}`;

  const cached = getCache<GeoSearchItem[]>(key);
  if (cached) return cached;

  await respectRateLimit();

  const url = new URL(`${base}/search`);
  url.searchParams.set('format', 'jsonv2');
  url.searchParams.set('q', q);
  url.searchParams.set('addressdetails', '1');
  url.searchParams.set('limit', String(limit));
  if (email) url.searchParams.set('email', email);

  const res = await fetch(url.toString(), {
    headers: { 'User-Agent': `NatalTransitsChat/0.1 (${email || 'no-email-provided'})` },
  });
  globalThis.__lastNominatimFetch = Date.now();

  if (!res.ok) throw new Error(`Nominatim error ${res.status}`);

  const data: unknown = await res.json();
  if (!Array.isArray(data)) throw new Error('Unexpected Nominatim response (not an array)');

  const items: GeoSearchItem[] = data.map((r: unknown) => {
    const rr = (r ?? {}) as Record<string, unknown>;
    const addr = (rr.address ?? {}) as Record<string, unknown>;
    return {
      place_id: toStringSafe(rr.place_id),
      display_name: toStringSafe(rr.display_name),
      name: rr.name === undefined ? undefined : toStringSafe(rr.name),
      lat: toNumberSafe(rr.lat),
      lon: toNumberSafe(rr.lon),
      type: rr.type === undefined ? undefined : toStringSafe(rr.type),
      class: rr.class === undefined ? undefined : toStringSafe(rr.class),
      address: {
        city:
          addr.city !== undefined
            ? toStringSafe(addr.city)
            : addr.town !== undefined
            ? toStringSafe(addr.town)
            : addr.village !== undefined
            ? toStringSafe(addr.village)
            : undefined,
        state: addr.state === undefined ? undefined : toStringSafe(addr.state),
        country: addr.country === undefined ? undefined : toStringSafe(addr.country),
        country_code: addr.country_code === undefined ? undefined : toStringSafe(addr.country_code),
      },
    };
  });

  setCache(key, items);
  return items;
}

export function tzNameFromLatLon(lat: number, lon: number): string | null {
  try {
    const z = tzLookup(lat, lon);
    return typeof z === 'string' && z.length > 0 ? z : null;
  } catch {
    return null;
  }
}

/**
 * Offset in minuti da UTC per una data/ora locale.
 * @param isoDate YYYY-MM-DD
 * @param hhmm HH:MM (24h)
 * @param tzName es. "Europe/Rome"
 */
export function tzOffsetMinutes(isoDate: string, hhmm: string, tzName: string): number | null {
  if (!isoDate || !hhmm || !tzName) return null;
  const dt = DateTime.fromISO(`${isoDate}T${hhmm}`, { zone: tzName });
  return dt.isValid ? dt.offset : null;
}

```


## File: src\lib\graphics\glyphs.ts

```ts
// src/lib/graphics/glyphs.ts
// Glyph helpers: segni e pianeti
// - via Unicode char (consigliato) -> planetChar, signChar, signCharSafe
// - placeholder path (fallback)    -> planetGlyph, signGlyph
// - colori (wrapper)               -> signColor, aspectColor

import { SIGN_COLORS, ASPECT_COLORS, type ZodiacSign, type Aspect } from './tokens';

export type PlanetName =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto'
  | 'Asc' | 'Mc';

// ---------------------------
// Unicode characters
// ---------------------------
const PLANET_CHARS: Record<PlanetName, string> = {
  Sun: '☉', Moon: '☾', Mercury: '☿', Venus: '♀', Mars: '♂',
  Jupiter: '♃', Saturn: '♄', Uranus: '♅', Neptune: '♆', Pluto: '♇',
  Asc: '↑', Mc: 'T',
};

const SIGN_CHARS: Record<ZodiacSign, string> = {
  Aries: '♈', Taurus: '♉', Gemini: '♊', Cancer: '♋', Leo: '♌', Virgo: '♍',
  Libra: '♎', Scorpio: '♏', Sagittarius: '♐', Capricorn: '♑', Aquarius: '♒', Pisces: '♓',
};

export function planetChar(name: PlanetName): string {
  return PLANET_CHARS[name] ?? '?';
}
export function signChar(sign: ZodiacSign): string {
  return SIGN_CHARS[sign] ?? '?';
}

// --- Normalizzazione nomi segno (IT/EN) ---
const IT_TO_EN: Record<string, ZodiacSign> = {
  ariete: 'Aries',
  toro: 'Taurus',
  gemelli: 'Gemini',
  cancro: 'Cancer',
  leone: 'Leo',
  vergine: 'Virgo',
  bilancia: 'Libra',
  scorpione: 'Scorpio',
  sagittario: 'Sagittarius',
  capricorno: 'Capricorn',
  acquario: 'Aquarius',
  pesci: 'Pisces',
};
const EN_ALL: Record<string, ZodiacSign> = {
  aries: 'Aries', taurus: 'Taurus', gemini: 'Gemini', cancer: 'Cancer',
  leo: 'Leo', virgo: 'Virgo', libra: 'Libra', scorpio: 'Scorpio',
  sagittarius: 'Sagittarius', capricorn: 'Capricorn', aquarius: 'Aquarius', pisces: 'Pisces',
};

export function normalizeZodiacSign(input: string): ZodiacSign | null {
  if (!input) return null;
  const k = input.trim().toLowerCase();
  return EN_ALL[k] ?? IT_TO_EN[k] ?? null;
}

/** Accetta sia EN che IT; se non riconosciuto -> '?' */
export function signCharSafe(input: string): string {
  const z = normalizeZodiacSign(input);
  return z ? SIGN_CHARS[z] : '?';
}

// ---------------------------
// Placeholder SVG paths (fallback)
// ---------------------------
export function planetGlyph(name: PlanetName): string {
  switch (name) {
    case 'Sun': return 'M0,-10 A10,10 0 1,0 0,10 A10,10 0 1,0 0,-10 Z';
    case 'Moon': return 'M6,0 A6,6 0 1,1 -6,0 A10,10 0 1,0 6,0 Z';
    case 'Mercury': return 'M0,-8 L6,8 L-6,8 Z';
    case 'Venus': return 'M0,-8 L8,0 L0,8 L-8,0 Z';
    case 'Mars': return 'M-6,-6 L6,6 M6,-6 L-6,6';
    case 'Jupiter': return 'M0,-8 L0,8 M-8,0 L8,0';
    case 'Saturn': return 'M-8,0 L8,0';
    case 'Uranus': return 'M0,-8 L0,8';
    case 'Neptune': return 'M-6,-6 L6,6';
    case 'Pluto': return 'M-6,6 L6,-6';
    case 'Asc': return 'M0,-10 L0,10';
    case 'Mc': return 'M-8,0 L8,0';
    default: return '';
  }
}
export function signGlyph(sign: ZodiacSign): string {
  switch (sign) {
    case 'Aries': return 'M-6,-8 L0,8 L6,-8';
    case 'Taurus': return 'M-6,0 A6,6 0 1,0 6,0 A6,6 0 1,0 -6,0 Z';
    default: return 'M-6,-6 L6,6';
  }
}

// ---------------------------
// Colori (wrapper)
// ---------------------------
export function signColor(sign: ZodiacSign): string {
  return SIGN_COLORS[sign];
}
export function aspectColor(aspect: Aspect): string {
  return ASPECT_COLORS[aspect];
}

// Tipi utili
export type { ZodiacSign, Aspect } from './tokens';

```


## File: src\lib\graphics\polar.ts

```ts
// src/lib/graphics/polar.ts
/**
 * Utility matematiche e layout polari per le ruote astrologiche Pro.
 * Pure funzioni senza dipendenze esterne.
 */

export interface XY {
  x: number;
  y: number;
}

/** Converte gradi in radianti */
export function deg2rad(deg: number): number {
  return (deg * Math.PI) / 180;
}

/** Converte radianti in gradi (0..360) */
export function rad2deg(rad: number): number {
  const d = (rad * 180) / Math.PI;
  return ((d % 360) + 360) % 360;
}

/** Normalizza un angolo in gradi a [0,360) */
export function wrapDeg(deg: number): number {
  return ((deg % 360) + 360) % 360;
}

/**
 * Conversione unica per coordinate/polari SVG:
 *  - 0° punta in alto (ore 12)
 *  - angoli crescono in senso orario
 *  => θ_svg = deg - 90
 */
function toSvgRad(angleDeg: number): number {
  return deg2rad(angleDeg - 90);
}

/** Coordinate XY da centro (cx,cy), raggio r e angolo in gradi */
export function polarToXY(cx: number, cy: number, r: number, angleDeg: number): XY {
  const a = toSvgRad(angleDeg);
  return {
    x: cx + r * Math.cos(a),
    y: cy + r * Math.sin(a),
  };
}

/**
 * Costruisce un arco SVG tra due angoli (in gradi).
 * Usa la stessa convenzione angolare di polarToXY.
 * Il path viene tracciato in senso orario se endDeg > startDeg (mod 360).
 */
export function describeArc(cx: number, cy: number, r: number, startDeg: number, endDeg: number): string {
  const start = polarToXY(cx, cy, r, startDeg);
  const end = polarToXY(cx, cy, r, endDeg);

  // ampiezza (in [0,360))
  const sweep = wrapDeg(endDeg - startDeg);
  const largeArcFlag = sweep > 180 ? 1 : 0;

  // sweep-flag: 1 = orario (coerente con la nostra convenzione)
  const sweepFlag = 1;

  return `M ${start.x} ${start.y} A ${r} ${r} 0 ${largeArcFlag} ${sweepFlag} ${end.x} ${end.y}`;
}

/**
 * Collision avoidance semplice:
 * - riceve una lista di angoli target (deg)
 * - restituisce gli angoli aggiustati con spaziatura minima,
 *   **preservando l'ordine originale** dell'input.
 * - gestisce anche il wrap-around 360°.
 */
export function resolveCollisions(anglesDeg: number[], minSepDeg = 8): number[] {
  const n = anglesDeg.length;
  if (n < 2) return anglesDeg.slice();

  // 1) normalizza e aggancia indici originali
  const items = anglesDeg.map((a, idx) => ({ idx, a: wrapDeg(a) }));

  // 2) ordina per angolo
  items.sort((u, v) => u.a - v.a);

  // 3) separazione progressiva in avanti
  for (let i = 1; i < n; i++) {
    if (items[i].a - items[i - 1].a < minSepDeg) {
      items[i].a = items[i - 1].a + minSepDeg;
    }
  }

  // 4) gestisci il gap tra l’ultimo e il primo (wrap 360°)
  const gap = (items[0].a + 360) - items[n - 1].a;
  if (gap < minSepDeg) {
    // spingi in giù il primo sotto 0, poi normalizza
    items[0].a = items[n - 1].a + minSepDeg - 360;
    // e riallinea in avanti se necessario
    for (let i = 1; i < n; i++) {
      if (items[i].a - items[i - 1].a < minSepDeg) {
        items[i].a = items[i - 1].a + minSepDeg;
      }
    }
  }

  // 5) rimappa all’ordine d’ingresso
  const out = new Array<number>(n);
  for (const it of items) out[it.idx] = wrapDeg(it.a);
  return out;
}

/**
 * Leader line (dal punto interno a etichetta esterna)
 */
export function leaderLine(
  cx: number,
  cy: number,
  innerR: number,
  outerR: number,
  angleDeg: number
): string {
  const p1 = polarToXY(cx, cy, innerR, angleDeg);
  const p2 = polarToXY(cx, cy, outerR, angleDeg);
  return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
}

/** Esempio d'uso (commentato):
 *
 * const center = { x: 260, y: 260 };
 * const pt = polarToXY(center.x, center.y, 200, 120); // coordinate
 * const arc = describeArc(center.x, center.y, 250, 0, 30); // settore segno
 * const noOverlap = resolveCollisions([10, 12, 15]); // => [10, 18, 26] (stesso ordine input)
 */

```


## File: src\lib\graphics\tokens.ts

```ts
// src/lib/graphics/tokens.ts
/**
 * Design tokens per colori e stili grafici dell'astrologia.
 * Usati da tutti i componenti Pro.
 */

export type ZodiacSign =
  | 'Aries' | 'Taurus' | 'Gemini' | 'Cancer' | 'Leo' | 'Virgo'
  | 'Libra' | 'Scorpio' | 'Sagittarius' | 'Capricorn' | 'Aquarius' | 'Pisces';

export type Aspect =
  | 'conjunction'
  | 'opposition'
  | 'trine'
  | 'square'
  | 'sextile';

export const SIGN_COLORS: Record<ZodiacSign, string> = {
  Aries:       '#E63946', // rosso vivo
  Taurus:      '#8D6E63', // terra/marrone
  Gemini:      '#FFD166', // giallo brillante
  Cancer:      '#118AB2', // blu acqua
  Leo:         '#F4A261', // arancio solare
  Virgo:       '#2A9D8F', // verde teal
  Libra:       '#E76F51', // rosato
  Scorpio:     '#6D597A', // viola scuro
  Sagittarius: '#06D6A0', // verde smeraldo
  Capricorn:   '#264653', // blu/nero sobrio
  Aquarius:    '#457B9D', // azzurro
  Pisces:      '#A8DADC', // acquamarina
};

export const ASPECT_COLORS: Record<Aspect, string> = {
  conjunction: '#333333', // nero scuro
  opposition:  '#E63946', // rosso dinamico
  trine:       '#118AB2', // blu armonico
  square:      '#F4A261', // arancio dinamico
  sextile:     '#06D6A0', // verde armonico
};

// dimensioni e stili base
export const STROKES = {
  ring: 1.2,
  aspect: 1.5,
  cusp: 1,
};

export const FONTS = {
  label: '10px sans-serif',
  glyph: '16px serif',
};

```


## File: src\lib\graphics\types.ts

```ts
// src/lib/graphics/types.ts
/** Punto di un tema natale / transiti / sinastria */
export interface ProPoint {
  name: string;        // es. "Sun", "Moon", ...
  longitude: number;   // gradi 0..360
  sign?: string | null;
  house?: number | null;
  retro?: boolean | null;
}

```


## File: src\lib\houses\common.ts

```ts
// src/lib/houses/common.ts
// Utility comuni e tipi per i sistemi di case. MIT-compatible.

export type HouseSystem = 'whole' | 'placidus';

/** Converte gradi → radianti. */
export function deg2rad(d: number): number {
  return (d * Math.PI) / 180;
}

/** Converte radianti → gradi. */
export function rad2deg(r: number): number {
  return (r * 180) / Math.PI;
}

/** Normalizza un angolo in gradi nell'intervallo [0, 360). */
export function normalizeAngle(deg: number): number {
  let x = deg % 360;
  if (x < 0) x += 360;
  return x;
}

/** Restituisce true se angolo b è tra a (incluso) e c (escluso) muovendosi in senso crescente modulare 360°. */
export function isBetweenAngles(a: number, b: number, c: number): boolean {
  a = normalizeAngle(a);
  b = normalizeAngle(b);
  c = normalizeAngle(c);
  if (a === c) return true; // l'intervallo copre l'intero cerchio
  if (a < c) {
    return b >= a && b < c;
  } else {
    // wrap-around
    return b >= a || b < c;
  }
}

/** Clamp numerico semplice. */
export function clamp(x: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, x));
}

/** True se latitudine è in zona critica per Placidus (non definito/instabile). */
export function isExtremeLatitude(latDeg: number): boolean {
  // Soglia prudenziale: Circoli Polari ~66.56°, lasciamo margine
  return Math.abs(latDeg) > 66.5;
}

/** Errore specifico per latitudini estreme/unsupported. */
export class PlacidusUnsupportedLatitudeError extends Error {
  constructor(latDeg: number) {
    super(
      `Placidus non supportato/instabile a latitudine ${latDeg.toFixed(
        4
      )}°. Applicare fallback (Whole Sign).`
    );
    this.name = 'PlacidusUnsupportedLatitudeError';
  }
}

```


## File: src\lib\houses\placidus.ts

```ts
// src/lib/houses/placidus.ts
// Placidus robusto (MIT): ASC/MC via LST (GMST Meeus 12.4), MC risolto numericamente α(λ)=θ,
// cuspidi 12/11/9/8 su arco corto, opposte 6/5/3/2 per +180°, fallback Whole Sign per |lat|>66.5°.

export type PlacidusResult = {
  system: 'placidus';
  cusps: number[]; // [12] in gradi [0,360)
  asc: number;     // [0,360)
  mc: number;      // [0,360)
};

// ---------------------------- util ----------------------------
const TAU = 2 * Math.PI;
const DEG = Math.PI / 180;

const d2r = (d: number) => d * DEG;
const r2d = (r: number) => r / DEG;
const normRad = (x: number) => ((x % TAU) + TAU) % TAU;
const normDeg = (x: number) => ((x % 360) + 360) % 360;
const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));

/** differenza angolare firmata in radianti, in (-π, +π] */
function angDiff(a: number, b: number): number {
  let d = ((a - b) % TAU + TAU) % TAU;
  if (d > Math.PI) d -= TAU;
  return d;
}

/** percorri l'ARCO PIÙ CORTO da a -> b, parametro t∈[0,1] */
function stepShortest(a: number, b: number, t01: number): number {
  const d = ((b - a + Math.PI) % TAU) - Math.PI; // (-π,π]
  return normRad(a + d * t01);
}

// ----------------------- astronomia di base ----------------------

/** obliquità media (Meeus 22.2) – più che sufficiente per cuspidi/angoli */
function meanObliquityRad(jd: number): number {
  const T = (jd - 2451545.0) / 36525.0;
  const seconds = 21.448 - T * (46.8150 + T * (0.00059 - T * 0.001813));
  const eps0 = 23 + 26 / 60 + (seconds / 3600);
  return d2r(eps0);
}

/** eclittica -> equatoriale (β=0) */
function eclToEq(lambda: number, eps: number): { ra: number; dec: number } {
  const sinλ = Math.sin(lambda);
  const cosλ = Math.cos(lambda);
  const sinE = Math.sin(eps);
  const cosE = Math.cos(eps);

  const sinδ = sinλ * sinE;
  const δ = Math.asin(clamp(sinδ, -1, 1));
  const y = sinλ * cosE;
  const x = cosλ;
  const α = normRad(Math.atan2(y, x));
  return { ra: α, dec: δ };
}

/** RA(λ) per β=0 e sua derivata dα/dλ – utili per Newton */
function raOfLambda(lambda: number, eps: number): number {
  // α = atan2( sinλ cosε, cosλ )
  return normRad(Math.atan2(Math.sin(lambda) * Math.cos(eps), Math.cos(lambda)));
}
function dra_dlambda(lambda: number, eps: number): number {
  // derivata di atan2(y,x) con y=sinλ cosε, x=cosλ:
  // (x*y' - y*x')/(x^2 + y^2) = cosε / (cos^2λ + sin^2λ cos^2ε)
  const sinλ = Math.sin(lambda);
  const cosλ = Math.cos(lambda);
  const cosE = Math.cos(eps);
  const denom = cosλ * cosλ + (sinλ * cosE) * (sinλ * cosE);
  return cosE / denom;
}

/** GMST (Meeus 12.4) in radianti */
function gmstRad(jd: number): number {
  const T = (jd - 2451545.0) / 36525.0;
  const theta = 280.46061837 + 360.98564736629 * (jd - 2451545.0)
            + 0.000387933 * T * T - (T * T * T) / 38710000;
  return d2r(normDeg(theta));
}

/** LST = GMST + longitudine geografica (est +) */
function lstRad(jd: number, lonRad: number): number {
  return normRad(gmstRad(jd) + lonRad);
}

/** semi-arco (H0) per latitudine φ e declinazione δ */
function semiArcRad(phi: number, dec: number): number {
  const X = clamp(-Math.tan(phi) * Math.tan(dec), -1, 1);
  return Math.acos(X); // [0,π]
}

// ---------------------------- angoli principali ----------------------------

/** MC: risolvi numericamente α(λ)=θ (Newton + piccolo fallback) */
function mcLongitudeRad(lst: number, eps: number): number {
  // seed analitico (corretto): λ0 = atan2( sinθ, cosθ cosε )
  let lambda = normRad(Math.atan2(Math.sin(lst), Math.cos(lst) * Math.cos(eps)));

  // Newton – 6 iterazioni bastano largamente (funzione monotona)
  for (let i = 0; i < 6; i++) {
    const f = angDiff(raOfLambda(lambda, eps), lst);
    const df = dra_dlambda(lambda, eps);
    lambda = normRad(lambda - f / df);
  }

  // mini-fallback: rifinisci con due passi di bisezione sull’intorno
  const f0 = (λ: number) => angDiff(raOfLambda(λ, eps), lst);
  const width = d2r(2); // 2°
  const a = normRad(lambda - width); 
  let b = normRad(lambda + width);
  // cammina su arco corto
  for (let i = 0; i < 12; i++) {
    const m = (i + 1) / 12;
    const t = m;
    const fa = f0(stepShortest(a, b, 0));
    const fm = f0(stepShortest(a, b, t));
    if (fa * fm <= 0) { b = stepShortest(a, b, t); break; }
  }
  return lambda;
}

/** Ascendente:
 *  α_ASC = atan2( -cos θ, sin θ * cos ε + tan φ * sin ε )
 *  λ_tmp = ECL(α_ASC) restituisce il DSC; il vero ASC è λ = λ_tmp + π
 */
function ascLongitudeRad(lst: number, lat: number, eps: number): number {
  const sinT = Math.sin(lst);
  const cosT = Math.cos(lst);
  const tanφ = Math.tan(lat);
  const cosE = Math.cos(eps);
  const sinE = Math.sin(eps);

  const y = -cosT;
  const x = sinT * cosE + tanφ * sinE;
  const αasc = Math.atan2(y, x);
  const λtmp = raToLambda(normRad(αasc), eps); // mappa RA→λ in modo coerente
  return normRad(λtmp + Math.PI);
}

/** RA→λ (β=0) coerente con eclToEq: risolve α(λ)=α_target con Newton */
function raToLambda(alpha: number, eps: number): number {
  let λ = normRad(Math.atan2(Math.sin(alpha), Math.cos(alpha) * Math.cos(eps)));
  for (let i = 0; i < 5; i++) {
    const f = angDiff(raOfLambda(λ, eps), alpha);
    const df = dra_dlambda(λ, eps);
    λ = normRad(λ - f / df);
  }
  return λ;
}

// --------------------------- solver su arco corto ---------------------------

/** bisezione robusta sull'ARCO PIÙ CORTO (λA..λB), cercando fn(λ)=0 */
function solveOnShortestArc(
  λA: number,
  λB: number,
  fn: (λ: number) => number,
  maxIter = 50
): number {
  const N = 64; // campionamento per bracketing
  let a = 0, b = 1;
  let fa = fn(stepShortest(λA, λB, a));
  let got = false;

  for (let i = 1; i <= N; i++) {
    const t = i / N;
    const f = fn(stepShortest(λA, λB, t));
    if (fa * f <= 0) { a = (i - 1) / N; b = t; got = true; break; }
    fa = f;
  }
  if (!got) {
    // fallback: punto di minimo |f|
    let bestT = 0, bestAbs = Infinity;
    for (let i = 0; i <= N; i++) {
      const t = i / N;
      const val = Math.abs(fn(stepShortest(λA, λB, t)));
      if (val < bestAbs) { bestAbs = val; bestT = t; }
    }
    return stepShortest(λA, λB, bestT);
  }

  for (let i = 0; i < maxIter; i++) {
    const m = (a + b) / 2;
    const fm = fn(stepShortest(λA, λB, m));
    if (fa * fm <= 0) {
      b = m;
    } else {
      a = m; fa = fm;
    }
  }
  return stepShortest(λA, λB, (a + b) / 2);
}

// --------------------------- cuspidi Placidus ---------------------------

/** Q1 (ASC→MC), H<0 : α = θ + k·H0  → case 12 (k=2/3), 11 (k=1/3) */
function cuspQ1_between_ASC_MC(
  k: number, θ: number, φ: number, ε: number, λasc: number, λmc: number
): number {
  const f = (λ: number) => {
    const { ra, dec } = eclToEq(λ, ε);
    const H0 = semiArcRad(φ, dec);
    const target = θ + k * H0;        // H negativo: α = θ + k·H0
    return angDiff(ra, target);
  };
  return solveOnShortestArc(λasc, λmc, f);
}

/** Q2 (MC→DSC), H>0 : α = θ - k·H0  → case 9 (k=1/3), 8 (k=2/3) */
function cuspQ2_between_MC_DSC(
  k: number, θ: number, φ: number, ε: number, λmc: number, λdsc: number
): number {
  const f = (λ: number) => {
    const { ra, dec } = eclToEq(λ, ε);
    const H0 = semiArcRad(φ, dec);
    const target = θ - k * H0;        // H positivo: α = θ - k·H0
    return angDiff(ra, target);
  };
  return solveOnShortestArc(λmc, λdsc, f);
}

/** Calcola le cuspidi Placidus. */
export function computePlacidusCusps(
  jdUT: number,
  latDeg: number,
  lonDeg: number,
  _tzMinutes?: number   // mantenuto per compat; non serve al calcolo
): PlacidusResult {
  void _tzMinutes;
  const φ = d2r(latDeg);
  const λgeo = d2r(lonDeg);
  const ε = meanObliquityRad(jdUT);

  // Fallback per lat estreme
  if (Math.abs(latDeg) > 66.5) {
    const θ = lstRad(jdUT, λgeo);
    const λascWS = ascLongitudeRad(θ, φ, ε);
    const λmcWS  = mcLongitudeRad(θ, ε);
    const ascDeg = normDeg(r2d(λascWS));
    const cuspsWS = Array.from({ length: 12 }, (_, i) => normDeg(ascDeg + i * 30));
    return { system: 'placidus', cusps: cuspsWS, asc: ascDeg, mc: normDeg(r2d(λmcWS)) };
  }

  // LST e angoli principali
  const θ = lstRad(jdUT, λgeo);
  const λmc = mcLongitudeRad(θ, ε);           // ora risolto numericamente
  const λasc = ascLongitudeRad(θ, φ, ε);
  const λdsc = normRad(λasc + Math.PI);
  const λic  = normRad(λmc + Math.PI);

  // Cuspidi temporali
  const λ12 = cuspQ1_between_ASC_MC(2 / 3, θ, φ, ε, λasc, λmc);
  const λ11 = cuspQ1_between_ASC_MC(1 / 3, θ, φ, ε, λasc, λmc);
  const λ9  = cuspQ2_between_MC_DSC(1 / 3,  θ, φ, ε, λmc, λdsc);
  const λ8  = cuspQ2_between_MC_DSC(2 / 3,  θ, φ, ε, λmc, λdsc);

  // Opposte
  const λ6 = normRad(λ12 + Math.PI);
  const λ5 = normRad(λ11 + Math.PI);
  const λ3 = normRad(λ9  + Math.PI);
  const λ2 = normRad(λ8  + Math.PI);

  // Ordine 1..12
  const cuspsRad = [λasc, λ2, λ3, λic, λ5, λ6, λdsc, λ8, λ9, λmc, λ11, λ12];
  const cusps = cuspsRad.map(v => normDeg(r2d(v)));

  return { system: 'placidus', cusps, asc: normDeg(r2d(λasc)), mc: normDeg(r2d(λmc)) };
}

/** Assegna la casa (1..12) ad una longitudine λ data la lista di cuspidi 1..12 */
export function assignHouses(longitudeDeg: number, cusps: number[]): number {
  const λ = normDeg(longitudeDeg);
  if (!Array.isArray(cusps) || cusps.length !== 12) return 1;

  // Ordine geometrico CW a partire dalla cuspide 1
  const ordered: number[] = [0];
  for (let step = 0; step < 11; step++) {
    const i = ordered[ordered.length - 1];
    let bestJ = i, bestΔ = 361;
    for (let k = 0; k < 12; k++) {
      if (k === i) continue;
      const d = normDeg(cusps[k] - cusps[i]); // CW in gradi
      if (d > 0 && d < bestΔ) { bestΔ = d; bestJ = k; }
    }
    ordered.push(bestJ);
  }

  // Trova il settore CW [start..end) che contiene λ
  for (let j = 0; j < 12; j++) {
    const i = ordered[j];
    const n = ordered[(j + 1) % 12];
    const start = cusps[i];
    const end = cusps[n];
    const arc = normDeg(end - start);
    const dλ = normDeg(λ - start);
    if (dλ >= 0 && dλ < arc) return j + 1;
  }
  return 12;
}

```


## File: src\lib\houses\runtime.ts

```ts
// src/lib/houses/runtime.ts
import { computeHouses } from '@/lib/astro';

export type HouseSystem = 'whole' | 'placidus';

export function jdFromUTC(dateUTC: Date): number {
  // JD = 2440587.5 + msUTC/86400000
  return 2440587.5 + dateUTC.getTime() / 86400000;
}

/**
 * Calcola runtime le cuspidi case per una data UTC e coordinate geografiche.
 * Nessuna persistenza su DB.
 */
export function computeHousesForDateUTC(params: {
  system: HouseSystem;
  dateUTC: Date;          // data/ora in UTC
  latDeg: number;
  lonDeg: number;
}): { cusps: number[]; asc: number; mc: number; system: HouseSystem; fallbackApplied: boolean } {
  const { system, dateUTC, latDeg, lonDeg } = params;
  const jd = jdFromUTC(dateUTC);
  // tzMinutes non serve al calcolo case (si usa JD UT); lo forniamo per compatibilità con la firma
  const res = computeHouses(system, { jd, latDeg, lonDeg, tzMinutes: 0 });

  // Se Placidus e latitudine estrema, la nostra implementazione fa fallback a Whole Sign:
  const fallbackApplied = system === 'placidus' && Math.abs(latDeg) > 66.5;

  return {
    cusps: res.cusps,
    asc: res.asc,
    mc: res.mc,
    system,
    fallbackApplied,
  };
}

// append to: src/lib/houses/runtime.ts
import { DateTime } from 'luxon';

export async function computePersonHousesForUserSystem(params: {
  person: {
    birth_date: string;           // YYYY-MM-DD
    birth_time?: string | null;   // HH:MM
    tz_offset_minutes?: number | null;
    lat: number;
    lon: number;
  };
  userHouseSystem: HouseSystem;   // 'whole' | 'placidus'
}) {
  const { person, userHouseSystem } = params;
  if (!person?.birth_date || person.lat == null || person.lon == null) {
    return { system: userHouseSystem, cusps: undefined, asc: undefined, mc: undefined, fallbackApplied: false };
  }
  const hhmm = person.birth_time ?? '12:00';
  const off = person.tz_offset_minutes ?? 0;

  const local = DateTime.fromISO(`${person.birth_date}T${hhmm}:00`, { zone: 'UTC' }).toJSDate();
  // correggo l'UTC applicando l'offset (minuti) memorizzato
  const dateUTC = new Date(local.getTime() - off * 60_000);

  const res = computeHousesForDateUTC({
    system: userHouseSystem,
    dateUTC,
    latDeg: person.lat,
    lonDeg: person.lon,
  });
  return res;
}

```


## File: src\lib\houses\whole.ts

```ts
// src/lib/houses/whole.ts
// Cuspidi Whole Sign a partire dall'ASC e MC (entrambi gradi eclittici).

import { normalizeAngle } from './common';

export type WholeResult = {
  system: 'whole';
  cusps: number[]; // 12 valori: I..XII
  asc: number;
  mc: number;
  fallbackApplied?: boolean;
};

/** Cuspidi Whole Sign: cusp I = inizio del segno dell'ASC, poi ogni 30°. */
export function computeWholeCuspsFromAsc(ascDeg: number, mcDeg: number): WholeResult {
  const ascSignStart = Math.floor(normalizeAngle(ascDeg) / 30) * 30;
  const cusps = Array.from({ length: 12 }, (_, i) => normalizeAngle(ascSignStart + i * 30));
  return {
    system: 'whole',
    cusps,
    asc: normalizeAngle(ascDeg),
    mc: normalizeAngle(mcDeg),
  };
}

```


## File: src\lib\openai.ts

```ts
// src/lib/openai.ts
type ChatRole = 'system' | 'user' | 'assistant';

export type ChatMessage = { role: ChatRole; content: string };

function getModel(envName: 'OPENAI_MODEL_CHAT' | 'OPENAI_MODEL_REFINER', fallback: string): string {
  const m = process.env[envName];
  return (m && m.trim().length > 0) ? m : fallback;
}

export async function chatComplete(messages: ChatMessage[], useRefiner = false): Promise<string> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error('Missing OPENAI_API_KEY');
  }

  const model = useRefiner
    ? getModel('OPENAI_MODEL_REFINER', 'gpt-4o-mini')
    : getModel('OPENAI_MODEL_CHAT', 'gpt-4o-mini');

  const body = {
    model,
    messages,
    temperature: 0.8,
    top_p: 1,
  };

  const res = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(`OpenAI error ${res.status}: ${txt}`);
  }
  const data: unknown = await res.json();
  // type guard minimale
  const msg = (data as { choices?: Array<{ message?: { content?: string } }> })?.choices?.[0]?.message?.content;
  if (typeof msg !== 'string' || msg.length === 0) {
    throw new Error('OpenAI returned empty message');
  }
  return msg.trim();
}

```


## File: src\lib\planets\runtime.ts

```ts
// src/lib/planets/runtime.ts
import { Body, AstroTime, GeoVector, Ecliptic } from 'astronomy-engine';

export type RuntimePointName =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';

export type RuntimePoint = {
  name: RuntimePointName;
  longitude: number; // gradi 0..360
  sign: string;      // "Aries", ...
  retro: boolean;
};

const BODY_MAP: { name: RuntimePointName; body: Body }[] = [
  { name: 'Sun',     body: Body.Sun },
  { name: 'Moon',    body: Body.Moon },
  { name: 'Mercury', body: Body.Mercury },
  { name: 'Venus',   body: Body.Venus },
  { name: 'Mars',    body: Body.Mars },
  { name: 'Jupiter', body: Body.Jupiter },
  { name: 'Saturn',  body: Body.Saturn },
  { name: 'Uranus',  body: Body.Uranus },
  { name: 'Neptune', body: Body.Neptune },
  { name: 'Pluto',   body: Body.Pluto },
];

function normDeg(x: number): number { return ((x % 360) + 360) % 360; }

function signedDeltaDeg(a: number, b: number): number {
  // ritorna a-b in (-180, +180]
  let d = a - b;
  if (d > 180) d -= 360;
  if (d <= -180) d += 360;
  return d;
}

function signFromLongitude(lon: number): string {
  const SIGNS = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  const idx = Math.floor(normDeg(lon) / 30) % 12;
  return SIGNS[idx];
}

/** Calcola i pianeti per una certa data UTC (geocentric, ecliptic of-date). */
export function computeDailyPlanets(dateUTC: Date): RuntimePoint[] {
  const tNow  = new AstroTime(dateUTC);
  const tPrev = new AstroTime(new Date(dateUTC.getTime() - 86400000)); // -1 giorno

  return BODY_MAP.map(({ name, body }): RuntimePoint => {
    const vNow  = GeoVector(body, tNow, /*aberration*/ true);
    const eNow  = Ecliptic(vNow); // {elon, elat, dist}
    const lonNow = normDeg(eNow.elon);

    const vPrev  = GeoVector(body, tPrev, true);
    const ePrev  = Ecliptic(vPrev);
    const lonPrev = normDeg(ePrev.elon);

    const retro = signedDeltaDeg(lonNow, lonPrev) < 0;

    return {
      name,
      longitude: lonNow,
      sign: signFromLongitude(lonNow),
      retro,
    };
  });
}

export function computePlanetsAtUTC(dateUTC: Date): RuntimePoint[] {
  return computeDailyPlanets(dateUTC);
}

// --- add aliases/types for consumers ---
export type RuntimePlanet = { name: string; longitude: number; retro?: boolean };
```


## File: src\lib\supabase.ts

```ts
import { createClient } from '@supabase/supabase-js'


const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!


export const supabase = createClient(supabaseUrl, supabaseAnonKey)
```


## File: src\lib\supabaseAdmin.ts

```ts
import { createClient } from '@supabase/supabase-js';


const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;


export const supabaseAdmin = createClient(url, serviceKey, {
auth: { autoRefreshToken: false, persistSession: false }
});
```


## File: src\lib\supabaseBrowser.ts

```ts
// src/lib/supabaseBrowser.ts
import { createClient } from '@supabase/supabase-js';

export function createSupabaseBrowser() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
  return createClient(url, anon, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
  });
}

```


## File: src\lib\supabaseServer.ts

```ts
// src/lib/supabaseServer.ts
import { cookies } from 'next/headers';
import { createServerClient, type CookieOptions } from '@supabase/ssr';

function getSupabaseUrlAndKey() {
  const url =
    process.env.NEXT_PUBLIC_SUPABASE_URL ||
    process.env.SUPABASE_URL ||
    '';
  const anon =
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ||
    process.env.SUPABASE_ANON_KEY ||
    '';
  if (!url || !anon) {
    throw new Error(
      "Your project's URL and Key are required to create a Supabase client!\n" +
      'Set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in .env.local'
    );
  }
  return { url, anon };
}

/** Da usare in Server Components (RSC): NESSUNA mutazione cookie */
export function createSupabaseServerComponentClient() {
  const cookieStore = cookies();
  const { url, anon } = getSupabaseUrlAndKey();

  return createServerClient(url, anon, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      // set/remove NON disponibili in RSC: no-op per evitare errori
      set() {},
      remove() {},
    },
  });
}

/** Da usare SOLO in Route Handlers / Server Actions: può mutare cookie */
export function createSupabaseServerRouteClient() {
  const cookieStore = cookies();
  const { url, anon } = getSupabaseUrlAndKey();

  return createServerClient(url, anon, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      set(name: string, value: string, options: CookieOptions) {
        cookieStore.set({ name, value, ...options });
      },
      remove(name: string, options: CookieOptions) {
        cookieStore.set({ name, value: '', ...options });
      },
    },
  });
}

```


## File: src\lib\synastry.ts

```ts
// src/lib/synastry.ts
import { normalizeDeg, type AspectType, type PointName } from '@/lib/astro';

export type NatalPointLite = { name: PointName; longitude: number };

export type SynAspect = {
  a_point: PointName;
  b_point: PointName;
  aspect: AspectType;
  orb: number;   // degrees
  score: number; // 0..1
};

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang'; // ASC/MC
}

function maxOrb(p1: PointName, p2: PointName): number {
  const c1 = classOfPoint(p1);
  const c2 = classOfPoint(p2);
  if (c1 === 'lum' || c2 === 'lum') return 6;
  if (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function pointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeSynastryAspects(a: NatalPointLite[], b: NatalPointLite[]): SynAspect[] {
  const res: SynAspect[] = [];
  const aspects: AspectType[] = ['conjunction','sextile','square','trine','opposition'];
  for (const A of a) {
    for (const B of b) {
      const d = minAngle(A.longitude, B.longitude);
      let best: { asp: AspectType; diff: number } | null = null;
      for (const asp of aspects) {
        const diff = Math.abs(d - ASPECT_DEGREES[asp]);
        if (!best || diff < best.diff) best = { asp, diff };
      }
      if (!best) continue;
      const max = maxOrb(A.name, B.name);
      if (best.diff <= max) {
        const score = aspectWeight(best.asp) * pointWeight(A.name) * pointWeight(B.name);
        res.push({
          a_point: A.name,
          b_point: B.name,
          aspect: best.asp,
          orb: +best.diff.toFixed(2),
          score: +score.toFixed(3),
        });
      }
    }
  }
  res.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return res;
}

export function formatSynastryContext(top: SynAspect[], labelA: string, labelB: string): string {
  const lines = top.map(s =>
    `${labelA}:${s.a_point} ${s.aspect} ${labelB}:${s.b_point} (orb ${s.orb}°, score ${Math.round(s.score*100)})`
  );
  return `CONTEXT_SYNASTRY\n${lines.join('\n')}`;
}

```


## File: src\lib\synastry\aspects.ts

```ts
// src/lib/synastry/aspects.ts
import { wrapDeg } from '@/lib/graphics/polar';
import type { PlanetName } from '@/lib/graphics/glyphs';

export type AspectName =
  | 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile'
  | 'quincunx' | 'semi-sextile';

export type ChartPoint = {
  name: PlanetName | 'ASC' | 'MC';
  lon: number;        // 0..360
  retro?: boolean;
};

export type SynastryAspect = {
  a: { owner: 'user' | 'person'; name: ChartPoint['name']; lon: number };
  b: { owner: 'user' | 'person'; name: ChartPoint['name']; lon: number };
  aspect: AspectName;
  exact: number;      // 0,60,90,120,150,180
  orb: number;        // |delta| in gradi
  applying: boolean;  // stima (runtime)
  score: number;      // 0..1
};

const ASPECT_DEG: Record<AspectName, number> = {
  conjunction: 0, sextile: 60, square: 90, trine: 120,
  quincunx: 150, opposition: 180, 'semi-sextile': 30,
};

// orbi massimi (luminari > personali/angoli > sociali > lenti)
function classOf(p: ChartPoint['name']) {
  if (p === 'Sun' || p === 'Moon') return 'lum';
  if (p === 'Mercury' || p === 'Venus' || p === 'Mars') return 'pers';
  if (p === 'Jupiter' || p === 'Saturn') return 'soc';
  if (p === 'Uranus' || p === 'Neptune' || p === 'Pluto') return 'out';
  return 'ang';
}
function maxOrb(p1: ChartPoint['name'], p2: ChartPoint['name'], a: AspectName): number {
  const c1 = classOf(p1), c2 = classOf(p2);
  const base =
    (c1 === 'lum' || c2 === 'lum') ? 8 :
    (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') ? 6 :
    4;
  // aspetti minori: orb leggermente ridotto
  if (a === 'quincunx' || a === 'semi-sextile') return Math.max(2, base - 2);
  return base;
}

function minAngle(a: number, b: number): number {
  const raw = Math.abs(wrapDeg(a - b));
  return raw > 180 ? 360 - raw : raw;
}

// stima velocità giornaliera media (deg/giorno) per applicare applying/separating
const MEAN_SPEED: Partial<Record<PlanetName | 'ASC' | 'MC', number>> = {
  Sun: 0.9856, Moon: 13.176, Mercury: 1.2, Venus: 1.2, Mars: 0.5,
  Jupiter: 0.083, Saturn: 0.033, Uranus: 0.012, Neptune: 0.006, Pluto: 0.004,
  ASC: 0, MC: 0,
};
function isApplying(a: ChartPoint, b: ChartPoint, aspectExact: number): boolean {
  // prende il "più veloce" come riferimento
  const va = MEAN_SPEED[a.name as PlanetName] ?? 0;
  const vb = MEAN_SPEED[b.name as PlanetName] ?? 0;
  const fast = va >= vb ? a : b;
  // Se il veloce è "prima" dell'esatto muovendosi in avanti → applying
  // target = long dell'altro +/- aspectExact (quello più vicino)
  const target1 = wrapDeg((b.lon + aspectExact));
  const target2 = wrapDeg((b.lon - aspectExact));
  const d1 = minAngle(fast.lon, target1);
  const d2 = minAngle(fast.lon, target2);
  const target = d1 <= d2 ? target1 : target2;
  const delta = wrapDeg(target - fast.lon); // quanto manca muovendosi avanti
  return delta < 180; // se "davanti" nel senso diretto → applica
}

function aspectWeight(a: AspectName): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.78;
    case 'quincunx':    return 0.55;
    case 'semi-sextile':return 0.50;
  }
}
function pointWeight(p: ChartPoint['name']): number {
  switch (classOf(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export type ComputeOpts = {
  includeMinor?: boolean;
  topN?: number;
};

export function computeSynastryAspects(
  userPoints: ChartPoint[],
  personPoints: ChartPoint[],
  opts: ComputeOpts = {}
): SynastryAspect[] {
  const aspects: AspectName[] = opts.includeMinor
    ? ['conjunction','semi-sextile','sextile','square','trine','quincunx','opposition']
    : ['conjunction','sextile','square','trine','opposition'];

  const res: SynastryAspect[] = [];
  for (const ua of userPoints) {
    for (const pb of personPoints) {
      const d = minAngle(ua.lon, pb.lon);

      // individua l'aspetto più vicino
      let best: { a: AspectName; exact: number; diff: number } | null = null;
      for (const a of aspects) {
        const exact = ASPECT_DEG[a];
        const diff = Math.abs(d - exact);
        if (!best || diff < best.diff) best = { a, exact, diff };
      }
      if (!best) continue;

      const orbMax = maxOrb(ua.name, pb.name, best.a);
      if (best.diff <= orbMax) {
        const applying = isApplying(ua, pb, best.exact);
        const score =
          aspectWeight(best.a) * pointWeight(ua.name) * pointWeight(pb.name) * (1 - best.diff / orbMax);

        res.push({
          a: { owner: 'user', name: ua.name, lon: ua.lon },
          b: { owner: 'person', name: pb.name, lon: pb.lon },
          aspect: best.a,
          exact: best.exact,
          orb: Number(best.diff.toFixed(2)),
          applying,
          score: Number(score.toFixed(3)),
        });
      }
    }
  }

  res.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return typeof opts.topN === 'number' ? res.slice(0, opts.topN) : res;
}

// Helper per chatbot: stringa sintetica
export function formatSynastryContext(rows: SynastryAspect[], top = 10): string {
  const lines = (rows.slice(0, top)).map(r =>
    `${r.a.name}(${r.a.owner[0]}) ${r.aspect} ${r.b.name}(${r.b.owner[0]}) orb ${r.orb}° score ${r.score}`
  );
  return lines.length ? `CONTEXT_SYNASTRY\n${lines.join('\n')}` : '';
}

```


## File: src\lib\time.ts

```ts
// src/lib/time.ts
import { DateTime } from 'luxon';

export function getDefaultTZ(): string {
  return process.env.DEFAULT_TZ || 'UTC';
}

export function todayISOInTZ(tz?: string): string {
  const zone = tz || getDefaultTZ();
  return DateTime.now().setZone(zone).toFormat('yyyy-LL-dd'); // YYYY-MM-DD
}

export function nowInfo(tz?: string) {
  const zone = tz || getDefaultTZ();
  const dt = DateTime.now().setZone(zone);
  return {
    tz: zone,
    now_iso: dt.toISO(),
    now_human: dt.toFormat('cccc, dd LLL yyyy HH:mm'),
    utc_offset_minutes: dt.offset, // es. +120 per CEST
  };
}

```


## File: src\lib\time\resolveTz.ts

```ts
// src/lib/time/resolveTz.ts
// Helper server-side: dato (lat, lon, data locale, ora locale) risolve la timezone IANA
// e calcola l'offset (in minuti) valido in quel momento (gestisce automaticamente il DST).
//
// Dipendenze: luxon, tz-lookup
//   npm i tz-lookup
//
// Uso tipico:
//   const { tz_name, offset_minutes } = resolveTimezoneForLocalMoment(lat, lon, "1988-01-31", "12:34");

import { DateTime } from 'luxon';
import tzlookup from 'tz-lookup';

export type ResolvedTz = {
  tz_name: string;         // es. "Europe/Rome"
  offset_minutes: number;  // minuti da UTC, es. 60 o 120 a seconda del DST
};

export function resolveTimezoneForLocalMoment(
  lat: number,
  lon: number,
  dateISO: string,  // "YYYY-MM-DD"
  timeHHMM: string  // "HH:MM" (ora locale)
): ResolvedTz {
  // 1) timezone IANA dal punto geografico
  const tz_name = tzlookup(lat, lon);

  // 2) offset specifico di QUELLA data/ora locale (DST incluso)
  //    Luxon usa i dati tzdb della IANA per calcolare l'offset corretto.
  const dtLocal = DateTime.fromISO(`${dateISO}T${timeHHMM}`, { zone: tz_name });
  const offset_minutes = dtLocal.offset; // minuti (int)

  return { tz_name, offset_minutes };
}

```


## File: src\lib\transits.ts

```ts
// src/lib/transits.ts
import * as Astronomy from 'astronomy-engine';
import {
  type BodyName,
  type PointName,
  type AspectType,
  normalizeDeg,
} from '@/lib/astro';

export type TransitLongitude = {
  name: BodyName;
  longitude: number; // 0..360
};

export type NatalPointLite = {
  name: PointName;
  longitude: number;
};

export type TransitEventCalc = {
  date: string;         // YYYY-MM-DD (UTC day)
  t_planet: BodyName;   // transiting planet
  n_point: PointName;   // natal planet/angle
  aspect: AspectType;   // conj/sxt/sqr/trn/opp
  orb: number;          // degrees (0..maxOrb)
  score: number;        // 0..1
};

const TRANSIT_PLANETS: BodyName[] = [
  'Sun', 'Moon', 'Mercury', 'Venus', 'Mars',
  'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto',
];

const BODY_ENUM: Record<BodyName, Astronomy.Body> = {
  Sun: Astronomy.Body.Sun,
  Moon: Astronomy.Body.Moon,
  Mercury: Astronomy.Body.Mercury,
  Venus: Astronomy.Body.Venus,
  Mars: Astronomy.Body.Mars,
  Jupiter: Astronomy.Body.Jupiter,
  Saturn: Astronomy.Body.Saturn,
  Uranus: Astronomy.Body.Uranus,
  Neptune: Astronomy.Body.Neptune,
  Pluto: Astronomy.Body.Pluto,
};

function rad(d: number): number { return (d * Math.PI) / 180; }
function deg(r: number): number { return (r * 180) / Math.PI; }

const OBLIQUITY = (23.4392911 * Math.PI) / 180;

function eclipticFromEquatorial(eq: Astronomy.EquatorialCoordinates): { elon: number } {
  // RA in ore → gradi
  const raDeg = eq.ra * 15;
  const decDeg = eq.dec;
  const ra = rad(raDeg);
  const dec = rad(decDeg);
  const sinE = Math.sin(OBLIQUITY);
  const cosE = Math.cos(OBLIQUITY);
  const sinRa = Math.sin(ra);
  const cosRa = Math.cos(ra);
  const y = sinRa * cosE + Math.tan(dec) * sinE;
  const x = cosRa;
  const elon = Math.atan2(y, x);
  return { elon: normalizeDeg(deg(elon)) };
}

function geocentricEclLongitude(body: Astronomy.Body, when: Date): number {
  const vec = Astronomy.GeoVector(body, when, true);
  const eq  = Astronomy.EquatorFromVector(vec);
  return eclipticFromEquatorial(eq).elon;
}

export function utNoon(dateIso: string): Date {
  const [y, m, d] = dateIso.split('-').map((s) => Number(s));
  return new Date(Date.UTC(y, (m - 1), d, 12, 0, 0)); // 12:00 UTC
}

export function computeTransitingLongitudes(dateIso: string): TransitLongitude[] {
  const when = utNoon(dateIso);
  return TRANSIT_PLANETS.map((p) => ({
    name: p,
    longitude: geocentricEclLongitude(BODY_ENUM[p], when),
  }));
}

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang';
}

// MVP guideline orbs: 6° luminari, 5° personali/angoli, 3° lenti
export function maxOrbForPair(transiting: BodyName, natal: PointName): number {
  const cT = classOfPoint(transiting);
  const cN = classOfPoint(natal);
  if (cT === 'lum' || cN === 'lum') return 6;
  if (cT === 'pers' || cN === 'pers' || cN === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function transitPlanetWeight(p: BodyName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 0.85;  // per non far dominare la Luna
    case 'pers': return 0.90;
    case 'soc': return 0.95;
    case 'out': return 1.00;  // lenti più “pesanti”
    case 'ang': return 0.95;
  }
}

function natalPointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeTransitEventsForDay(
  dateIso: string,
  transits: TransitLongitude[],
  natalPoints: NatalPointLite[]
): TransitEventCalc[] {
  const events: TransitEventCalc[] = [];
  const aspects: AspectType[] = ['conjunction', 'sextile', 'square', 'trine', 'opposition'];

  for (const t of transits) {
    for (const n of natalPoints) {
      const d = minAngle(t.longitude, n.longitude);
      // aspetto più vicino
      let best: { a: AspectType; diff: number } | null = null;
      for (const a of aspects) {
        const ad = ASPECT_DEGREES[a];
        const diff = Math.abs(d - ad);
        if (best === null || diff < best.diff) best = { a, diff };
      }
      if (!best) continue;

      const maxOrb = maxOrbForPair(t.name, n.name);
      if (best.diff <= maxOrb) {
        const score =
          aspectWeight(best.a) *
          transitPlanetWeight(t.name) *
          natalPointWeight(n.name);

        events.push({
          date: dateIso,
          t_planet: t.name,
          n_point: n.name,
          aspect: best.a,
          orb: Number(best.diff.toFixed(2)),
          score: Number(score.toFixed(3)),
        });
      }
    }
  }

  // ordina per score desc, poi orb asc
  events.sort((A, B) => (B.score - A.score) || (A.orb - B.orb));
  return events;
}

```


## File: src\lib\utils.ts

```ts
// FILE: src/lib/utils.ts
export function cn(...values: Array<string | false | null | undefined>): string {
  return values.filter(Boolean).join(" ");
}

```


## File: src\types\tz-lookup.d.ts

```ts
﻿declare module 'tz-lookup' {
  export default function tzLookup(lat: number, lon: number): string;
}

```


## File: supabase\migrations\0001_init.sql

```sql
-- Enable useful extensions
id bigserial primary key,
session_id uuid not null references public.chat_sessions(id) on delete cascade,
role text not null check (role in ('user','assistant','system')),
content text not null,
created_at timestamptz not null default now()
);
create index if not exists idx_chat_messages_session on public.chat_messages(session_id);


-- RLS
alter table public.users enable row level security;
alter table public.birth_data enable row level security;
alter table public.chart_points enable row level security;
alter table public.natal_aspects enable row level security;
alter table public.transit_events enable row level security;
alter table public.interpretations enable row level security;
alter table public.chat_sessions enable row level security;
alter table public.chat_messages enable row level security;


-- policies: users (owner read/update)
create policy users_select_own on public.users
for select using (id = auth.uid());
create policy users_update_own on public.users
for update using (id = auth.uid()) with check (id = auth.uid());
-- no insert/delete by clients


-- policies: tables with user_id (owner-only full access)
create policy bd_rw_own on public.birth_data
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cp_rw_own on public.chart_points
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy na_rw_own on public.natal_aspects
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy te_rw_own on public.transit_events
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cs_rw_own on public.chat_sessions
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy cm_read_by_session on public.chat_messages
for select using (exists (
select 1 from public.chat_sessions s
where s.id = chat_messages.session_id and s.user_id = auth.uid()
));
create policy cm_write_by_session on public.chat_messages
for insert with check (exists (
select 1 from public.chat_sessions s
where s.id = chat_messages.session_id and s.user_id = auth.uid()
));


-- interpretations: readable by anyone, writable only with service role
create policy interp_public_read on public.interpretations
for select using (true);
-- (no insert/update/delete policy for anon/auth; use service role key in server routes)
```


## File: supabase\migrations\0002_people_synastry.sql

```sql
-- 0002_people_synastry.sql
-- Tabelle per persone (contatti) e relativi dati astrologici


create table if not exists public.people (
id uuid primary key default gen_random_uuid(),
user_id uuid not null references public.users(id) on delete cascade,
label text not null, -- es. "papà", "collega 1"
birth_date date not null,
birth_time text, -- HH:MM opzionale
birth_tz_name text, -- es. Europe/Rome
birth_tz_offset_minutes int, -- comodo per storicizzare
birth_place_name text,
birth_lat double precision,
birth_lon double precision,
current_place_name text, -- opzionale: dove si trova ora
current_lat double precision,
current_lon double precision,
current_tz_name text,
created_at timestamptz not null default now(),
updated_at timestamptz not null default now()
);


create table if not exists public.people_chart_points (
id bigserial primary key,
person_id uuid not null references public.people(id) on delete cascade,
name text not null, -- Sun, Moon, Mercury, ... ASC, MC
longitude double precision not null,
sign text not null,
house int,
retro boolean default false
);


create table if not exists public.people_natal_aspects (
id bigserial primary key,
person_id uuid not null references public.people(id) on delete cascade,
p1 text not null,
p2 text not null,
aspect text not null, -- conjunction|sextile|square|trine|opposition
orb double precision not null,
strength int not null
);


-- RLS
alter table public.people enable row level security;
alter table public.people_chart_points enable row level security;
alter table public.people_natal_aspects enable row level security;


create policy people_rw_own on public.people
for all using (user_id = auth.uid()) with check (user_id = auth.uid());


create policy ppl_points_rw_own on public.people_chart_points
for all using (person_id in (select id from public.people where user_id = auth.uid()))
with check (person_id in (select id from public.people where user_id = auth.uid()));


create policy ppl_aspects_rw_own on public.people_natal_aspects
for all using (person_id in (select id from public.people where user_id = auth.uid()))
with check (person_id in (select id from public.people where user_id = auth.uid()));
```


## File: supabase\migrations\2025-09-17_add_user_prefs.sql

```sql
-- 2025-09-17_add_user_prefs.sql
create table if not exists public.user_prefs (
  user_id uuid primary key references public.users(id) on delete cascade,
  current_place_name text,
  current_lat double precision,
  current_lon double precision,
  current_tz_name text,
  focus jsonb default '[]'::jsonb, -- es. ["work","relationships"]
  updated_at timestamptz default now()
);

alter table public.user_prefs enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_prefs' and policyname='user_prefs_select_own'
  ) then
    create policy user_prefs_select_own
      on public.user_prefs for select
      using (auth.uid() = user_id);
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_prefs' and policyname='user_prefs_upsert_own'
  ) then
    create policy user_prefs_upsert_own
      on public.user_prefs for insert with check (auth.uid() = user_id);
    create policy user_prefs_update_own
      on public.user_prefs for update using (auth.uid() = user_id);
  end if;
end$$;

```
