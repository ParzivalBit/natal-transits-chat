# Repository Knowledge Base (chunk 0004)


## File: src\components\astro\ChartWheelPro.tsx

```tsx
// src/components/astro/ChartWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { ProPoint } from '@/lib/graphics/types';
import {
  signColor,
  planetChar,
  PlanetName,
  ZodiacSign,
  signChar,
} from '@/lib/graphics/glyphs';
import { ASPECT_COLORS } from '@/lib/graphics/tokens';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type Axes = { asc: number; mc: number };

export default function ChartWheelPro({
  title = 'ChartWheelPro (Natal)',
  points,
  houseCusps,
  axes,                 // opzionale
  size = 520,
  className,
  responsive = true,
  usePlanetBadges = false,
}: {
  title?: string;
  points: ProPoint[];
  houseCusps?: number[];
  axes?: Axes;
  size?: number;
  className?: string;
  responsive?: boolean;
  usePlanetBadges?: boolean;
}) {
  const r = size / 2;

  // —— RAGGI (dal centro verso l’esterno) ——
  const aspectsR          = r * 0.34;
  const housesNumR        = r * 0.48;
  const housesNumInnerR   = r * 0.44;
  const housesNumOuterR   = r * 0.52;
  const planetsR          = r * 0.76;
  const zodiacInnerR      = r * 0.86;
  const zodiacOuterR      = r * 0.98;

  // —— Assi: derivazione se non forniti —— //
  const baseAxes: Axes = useMemo(() => {
    if (axes) return { asc: norm(axes.asc), mc: norm(axes.mc) };
    if (houseCusps && houseCusps.length === 12) {
      return { asc: norm(houseCusps[0]!), mc: norm(houseCusps[9]!) };
    }
    return { asc: 180, mc: 90 }; // placeholder
  }, [axes, houseCusps]);

  // —— Rotazione ANGOLI (non testo): vogliamo AC a 270° (sinistra) —— //
  // polarToXY usa 0° in alto, 90° a destra, 180° in basso, 270° a sinistra.
  // Quindi rot = 270 - ASC.
  const rot = useMemo(() => norm(270 - baseAxes.asc), [baseAxes.asc]);
  const applyRot = (deg: number) => norm(deg + rot);

  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanetIdx, setHoverPlanetIdx] = useState<number | null>(null);
  const [focusPlanetIdx, setFocusPlanetIdx] = useState<number | null>(null);

  const planetAnglesRaw = useMemo(
    () => resolveCollisions(points.map(p => p.longitude), 8),
    [points]
  );

  // —— aspetti natal —— //
  const aspects = useMemo(() => {
    const results: { from: number; to: number; type: keyof typeof ASPECT_COLORS }[] = [];
    const defs = [
      { type: 'conjunction' as const, deg: 0 },
      { type: 'opposition'  as const, deg: 180 },
      { type: 'trine'       as const, deg: 120 },
      { type: 'square'      as const, deg: 90 },
      { type: 'sextile'     as const, deg: 60 },
    ];
    const orb = 6;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const diff = Math.abs(points[i].longitude - points[j].longitude) % 360;
        const d = diff > 180 ? 360 - diff : diff;
        const found = defs.find(a => Math.abs(d - a.deg) <= orb);
        if (found) results.push({ from: i, to: j, type: found.type });
      }
    }
    return results;
  }, [points]);

  const aspectsByPlanet = useMemo(() => {
    const map = new Map<number, number[]>();
    aspects.forEach((a, idx) => {
      (map.get(a.from) ?? map.set(a.from, []).get(a.from)!).push(idx);
      (map.get(a.to) ?? map.set(a.to, []).get(a.to)!).push(idx);
    });
    return map;
  }, [aspects]);

  const highlightedPlanets = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) {
      const a = aspects[hoverAspectIdx];
      if (a) { set.add(a.from); set.add(a.to); }
    }
    if (hoverPlanetIdx != null) {
      set.add(hoverPlanetIdx);
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) { const a = aspects[idx]; set.add(a.from); set.add(a.to); }
    }
    if (focusPlanetIdx != null) set.add(focusPlanetIdx);
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, focusPlanetIdx, aspects, aspectsByPlanet]);

  const highlightedAspects = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) set.add(hoverAspectIdx);
    if (hoverPlanetIdx != null) {
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) set.add(idx);
    }
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, aspectsByPlanet]);

  function buildAriaLabel(p: ProPoint): string {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}° ${sign}`;
  }

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 text-sm font-medium">{title}</div>

      <svg
        role="img"
        aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* —— Zodiac band —— */}
        {Array.from({ length: 12 }).map((_, i) => {
          const path = describeDonutSector(
            r, r, zodiacOuterR, zodiacInnerR,
            applyRot(i * 30), applyRot(i * 30 + 30)
          );
          return <path key={`sec-${i}`} d={path} fill="white" stroke="none" />;
        })}
        {Array.from({ length: 12 }).map((_, i) => {
          const deg = applyRot(i * 30);
          const p1 = polarToXY(r, r, zodiacInnerR, deg);
          const p2 = polarToXY(r, r, zodiacOuterR, deg);
          return <line key={`sep-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#111827" strokeWidth={1} opacity={0.7} />;
        })}
        <circle cx={r} cy={r} r={zodiacOuterR} fill="none" stroke="#111827" strokeWidth={1.5} />
        <circle cx={r} cy={r} r={zodiacInnerR} fill="none" stroke="#111827" strokeWidth={1} opacity={0.6} />

        {renderZodiacBandColored(r, size, (zodiacInnerR + zodiacOuterR) / 2, applyRot)}

        {/* —— Case —— */}
        {houseCusps && houseCusps.length === 12 && houseCusps.map((deg, i) => {
          const d = applyRot(deg);
          const p1 = polarToXY(r, r, 0, d);
          const p2 = polarToXY(r, r, zodiacInnerR, d);
          return <line key={`cusp-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#9ca3af" strokeWidth={0.9} />;
        })}

        {/* —— Assi + etichette —— */}
        {renderAxes(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}
        {renderAxisLabels(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}

        {/* —— Rete aspetti —— */}
        {aspects.map((a, idx) => {
          const a1 = applyRot(planetAnglesRaw[a.from]);
          const a2 = applyRot(planetAnglesRaw[a.to]);
          const p1 = polarToXY(r, r, aspectsR, a1);
          const p2 = polarToXY(r, r, aspectsR, a2);
          const isHi = highlightedAspects.has(idx);
          return (
            <line
              key={idx}
              x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
              stroke={ASPECT_COLORS[a.type]}
              strokeWidth={isHi ? 2.6 : 1.2}
              opacity={isHi ? 1 : 0.75}
              onMouseEnter={() => setHoverAspectIdx(idx)}
              onMouseLeave={() => setHoverAspectIdx(null)}
            />
          );
        })}

        {/* —— Anello numeri case —— */}
        <circle cx={r} cy={r} r={housesNumInnerR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        <circle cx={r} cy={r} r={housesNumOuterR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        {houseCusps && houseCusps.length === 12 && renderHouseNumbers(r, size, housesNumR, houseCusps, applyRot)}

        {/* —— Pianeti —— */}
        {points.map((p, i) => {
          const aRot = applyRot(planetAnglesRaw[i]);

          const tickStartR = zodiacInnerR;
          const tickEndR   = zodiacInnerR - (zodiacInnerR - planetsR) * 0.45;

          const tickStart = polarToXY(r, r, tickStartR, aRot);
          const tickEnd   = polarToXY(r, r, tickEndR, aRot);
          const glyph     = polarToXY(r, r, planetsR, aRot);

          const isHi = highlightedPlanets.has(i) || focusPlanetIdx === i;
          const char = planetChar(p.name as PlanetName);
          const glyphFont = 14 * (size / 520);

          return (
            <g
              key={i}
              tabIndex={0}
              role="img"
              aria-label={buildAriaLabel(p)}
              onFocus={() => setFocusPlanetIdx(i)}
              onBlur={() => setFocusPlanetIdx(null)}
              onMouseEnter={() => setHoverPlanetIdx(i)}
              onMouseLeave={() => setHoverPlanetIdx(null)}
              style={{ cursor: 'pointer' }}
            >
              <line x1={tickStart.x} y1={tickStart.y} x2={tickEnd.x} y2={tickEnd.y} stroke="#111827" strokeWidth={0.9} opacity={0.85} />
              <circle cx={glyph.x} cy={glyph.y} r={9 * (size / 520)} fill="white" />
              <text
                x={glyph.x}
                y={glyph.y}
                textAnchor="middle"
                dominantBaseline="central"
                fontSize={glyphFont}
                fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                fill="#111827"
                pointerEvents="none"
              >
                {char}
              </text>
              {usePlanetBadges ? (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={10 * (size / 520)} fill="white" stroke={isHi ? '#111827' : 'black'} strokeWidth={isHi ? 1.8 : 1} />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={13.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
                </>
              ) : (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={12 * (size / 520)} fill="transparent" pointerEvents="all" />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={12.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.9} />}
                </>
              )}
              <title>{buildAriaLabel(p)}</title>
            </g>
          );
        })}
      </svg>
    </div>
  );
}

/** Glifi dei segni colorati (testo diritto), con angoli ruotati */
function renderZodiacBandColored(
  cx: number,
  size: number,
  radius: number,
  applyRot: (deg: number) => number
) {
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs.map((s, i) => {
    const mid = applyRot(i * 30 + 15);
    const { x, y } = polarToXY(cx, cx, radius, mid);
    return (
      <text
        key={s}
        x={x}
        y={y}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize={14 * (size / 520)}
        fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
        fill={signColor(s)}
      >
        {signChar(s)}
      </text>
    );
  });
}

function renderAxes(
  r: number,
  size: number,
  axesRot: Axes,   // asc/mc già ruotati via applyRot
  outerRingR: number
) {
  // Invertiamo MC/IC per avere MC in alto e IC in basso
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Chart axes">
      {items.map((it, idx) => {
        const p1 = polarToXY(r, r, 0, it.deg);
        const p2 = polarToXY(r, r, outerRingR, it.deg);
        return (
          <line
            key={idx}
            x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
            stroke="#111827" strokeWidth={1.1} opacity={0.7}
          />
        );
      })}
    </g>
  );
}

function renderAxisLabels(
  r: number,
  size: number,
  axesRot: Axes,
  outerRingR: number
) {
  const labelR = outerRingR + 14 * (size / 520);
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Axis labels">
      {items.map((it, idx) => {
        const t = polarToXY(r, r, labelR, it.deg);
        return (
          <text
            key={idx}
            x={t.x}
            y={t.y}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={11 * (size / 520)}
            fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
            fill="#111827"
          >
            {it.label}
          </text>
        );
      })}
    </g>
  );
}

/** Numeri delle case nel “middle” tra cusp[i] e cusp[i+1], con rotazione applicata */
function renderHouseNumbers(
  r: number,
  size: number,
  radius: number,
  cusps: number[],
  applyRot: (deg: number) => number
) {
  const items = Array.from({ length: 12 }).map((_, i) => {
    const a = applyRot(cusps[i]!);
    const b = applyRot(cusps[(i + 1) % 12]!);
    const mid = midAngle(a, b);
    const { x, y } = polarToXY(r, r, radius, mid);
    return { i: i + 1, x, y };
  });
  return (
    <g aria-label="House numbers">
      {items.map(({ i, x, y }) => (
        <text
          key={i}
          x={x}
          y={y}
          textAnchor="middle"
          dominantBaseline="central"
          fontSize={12 * (size / 520)}
          fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
          fill="#111827"
          opacity={0.85}
        >
          {i}
        </text>
      ))}
    </g>
  );
}

function midAngle(a: number, b: number) {
  let d = norm(b - a);
  if (d > 180) d -= 360;
  return norm(a + d / 2);
}

function norm(deg: number) {
  let d = deg % 360;
  if (d < 0) d += 360;
  return d;
}

/** Settore ad anello (donut) tra due raggi */
function describeDonutSector(
  cx: number, cy: number,
  rOuter: number, rInner: number,
  startDeg: number, endDeg: number
): string {
  const startOuter = polarToXY(cx, cy, rOuter, endDeg);
  const endOuter   = polarToXY(cx, cy, rOuter, startDeg);
  const startInner = polarToXY(cx, cy, rInner, startDeg);
  const endInner   = polarToXY(cx, cy, rInner, endDeg);
  const delta = norm(endDeg - startDeg);
  const largeArc = delta <= 180 ? 0 : 1;
  return [
    `M ${startOuter.x} ${startOuter.y}`,
    `A ${rOuter} ${rOuter} 0 ${largeArc} 0 ${endOuter.x} ${endOuter.y}`,
    `L ${startInner.x} ${startInner.y}`,
    `A ${rInner} ${rInner} 0 ${largeArc} 1 ${endInner.x} ${endInner.y}`,
    'Z',
  ].join(' ');
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs[idx]!;
}

```


## File: src\components\astro\DailyWheelPro.tsx

```tsx
// src/components/astro/DailyWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { ProPoint } from '@/lib/graphics/types';
import {
  PlanetName, ZodiacSign, planetChar, signColor,
} from '@/lib/graphics/glyphs';
import { aspectColor } from '@/lib/graphics/glyphs';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type AspectType = 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile';
type SkyAspect = { ring: 'today'; a: number; b: number; type: AspectType };
type CrossAspect = { ring: 'cross'; a: number; b: number; type: AspectType };
type AnyAspect = SkyAspect | CrossAspect;

export default function DailyWheelPro({
  title = 'DailyWheelPro',
  natal,
  today,
  houseCusps,
  size = 520,
  className,
  responsive = true,
  skyOnly = false,
  useTextGlyphs = true,
}: {
  title?: string;
  natal: ProPoint[];
  today: ProPoint[];
  houseCusps?: number[];
  size?: number;
  className?: string;
  responsive?: boolean;
  skyOnly?: boolean;
  useTextGlyphs?: boolean;
}) {
  const r = size / 2;

  const innerR = r * 0.45;
  const natalR = skyOnly ? 0 : r * 0.65;
  const todayR = r * 0.85;

  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanet, setHoverPlanet] = useState<{ ring: 'natal' | 'today'; idx: number } | null>(null);
  const [focusPlanet, setFocusPlanet] = useState<{ ring: 'natal' | 'today'; idx: number } | null>(null);

  const natalAngles = useMemo(() => resolveCollisions(natal.map(p => p.longitude), 8), [natal]);
  const todayAngles = useMemo(() => resolveCollisions(today.map(p => p.longitude), 8), [today]);

  const aspects = useMemo<AnyAspect[]>(() => {
    const defs: { type: AspectType; deg: number }[] = [
      { type: 'conjunction', deg: 0 },
      { type: 'opposition',  deg: 180 },
      { type: 'trine',       deg: 120 },
      { type: 'square',      deg: 90 },
      { type: 'sextile',     deg: 60 },
    ];
    const orb = 6;

    if (skyOnly) {
      const rows: SkyAspect[] = [];
      for (let i = 0; i < today.length; i++) {
        for (let j = i + 1; j < today.length; j++) {
          const diff = Math.abs(today[i].longitude - today[j].longitude) % 360;
          const d = diff > 180 ? 360 - diff : diff;
          const found = defs.find(a => Math.abs(d - a.deg) <= orb);
          if (found) rows.push({ a: i, b: j, type: found.type, ring: 'today' });
        }
      }
      return rows;
    } else {
      const rows: CrossAspect[] = [];
      for (let i = 0; i < natal.length; i++) {
        for (let j = 0; j < today.length; j++) {
          const diff = Math.abs(natal[i].longitude - today[j].longitude) % 360;
          const d = diff > 180 ? 360 - diff : diff;
          const found = defs.find(a => Math.abs(d - a.deg) <= orb);
          if (found) rows.push({ a: i, b: j, type: found.type, ring: 'cross' });
        }
      }
      return rows;
    }
  }, [natal, today, skyOnly]);

  const aspectsByKey = useMemo(() => {
    const m = new Map<string, number[]>();
    aspects.forEach((a, idx) => {
      if (a.ring === 'today') {
        const k1 = `today-${a.a}`, k2 = `today-${a.b}`;
        (m.get(k1) ?? m.set(k1, []).get(k1)!).push(idx);
        (m.get(k2) ?? m.set(k2, []).get(k2)!).push(idx);
      } else {
        const k1 = `natal-${a.a}`, k2 = `today-${a.b}`;
        (m.get(k1) ?? m.set(k1, []).get(k1)!).push(idx);
        (m.get(k2) ?? m.set(k2, []).get(k2)!).push(idx);
      }
    });
    return m;
  }, [aspects]);

  const highlightedAspects = useMemo(() => {
    const s = new Set<number>();
    if (hoverAspectIdx != null) s.add(hoverAspectIdx);
    if (hoverPlanet) {
      const arr = aspectsByKey.get(`${hoverPlanet.ring}-${hoverPlanet.idx}`) ?? [];
      arr.forEach(x => s.add(x));
    }
    return s;
  }, [hoverAspectIdx, hoverPlanet, aspectsByKey]);

  const highlightedPlanets = useMemo(() => {
    const s = new Set<string>();
    if (hoverAspectIdx != null) {
      const a = aspects[hoverAspectIdx];
      if (a.ring === 'today') {
        s.add(`today-${a.a}`); s.add(`today-${a.b}`);
      } else {
        s.add(`natal-${a.a}`); s.add(`today-${a.b}`);
      }
    }
    if (hoverPlanet) {
      s.add(`${hoverPlanet.ring}-${hoverPlanet.idx}`);
      const arr = aspectsByKey.get(`${hoverPlanet.ring}-${hoverPlanet.idx}`) ?? [];
      for (const aspIdx of arr) {
        const a = aspects[aspIdx];
        if (a.ring === 'today') { s.add(`today-${a.a}`); s.add(`today-${a.b}`); }
        else { s.add(`natal-${a.a}`); s.add(`today-${a.b}`); }
      }
    }
    if (focusPlanet) s.add(`${focusPlanet.ring}-${focusPlanet.idx}`);
    return s;
  }, [hoverAspectIdx, hoverPlanet, focusPlanet, aspects, aspectsByKey]);

  const buildAria = (p: ProPoint) => {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}° ${sign}`;
  };

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 text-sm font-medium">{skyOnly ? 'Sky Now' : 'Daily (Natal + Today)'}</div>

      <svg
        role="img"
        aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* sfondo zodiacale */}
        {Array.from({ length: 12 }).map((_, i) => {
          const start = i * 30, end = start + 30;
          const path = describeSector(r, r, r - 10, start, end);
          const signs: ZodiacSign[] = [
            'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
            'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
          ];
          return <path key={i} d={path} fill={signColor(signs[i])} fillOpacity={0.08} stroke="#e5e7eb" />;
        })}

        {/* cuspi (se forniti) */}
        {houseCusps && houseCusps.length === 12 && houseCusps.map((deg, i) => {
          const p1 = polarToXY(r, r, 0, deg);
          const p2 = polarToXY(r, r, r, deg);
          return <line key={i} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#9ca3af" strokeWidth={0.6} />;
        })}

        {/* aspetti con tick */}
        {aspects.map((a, idx) => {
          let angle1 = 0, angle2 = 0, tick1 = '#2563eb', tick2 = '#ea580c';
          if (a.ring === 'today') {
            angle1 = todayAngles[a.a];
            angle2 = todayAngles[a.b];
            tick1 = '#ea580c'; tick2 = '#ea580c';
          } else {
            angle1 = natalAngles[a.a];
            angle2 = todayAngles[a.b];
            tick1 = '#2563eb'; tick2 = '#ea580c';
          }
          const p1 = polarToXY(r, r, innerR, angle1);
          const p2 = polarToXY(r, r, innerR, angle2);
          const hi = highlightedAspects.has(idx);

          return (
            <g key={idx}
               onMouseEnter={() => setHoverAspectIdx(idx)}
               onMouseLeave={() => setHoverAspectIdx(null)}>
              <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
                    stroke={aspectColor(a.type)} strokeWidth={hi ? 2.4 : 1.2} opacity={hi ? 1 : 0.95}/>
              <circle cx={p1.x} cy={p1.y} r={2} fill={tick1} />
              <circle cx={p2.x} cy={p2.y} r={2} fill={tick2} />
            </g>
          );
        })}

        {/* pianeti natal (solo se non skyOnly) */}
        {!skyOnly && natal.map((p, i) => {
          const angle = natalAngles[i];
          const pos = polarToXY(r, r, natalR, angle);
          const hi = highlightedPlanets.has(`natal-${i}`);
          return (
            <g key={`n-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'natal', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'natal', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#2563eb" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#2563eb">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}

        {/* pianeti today (sempre visibili) */}
        {today.map((p, i) => {
          const angle = todayAngles[i];
          const pos = polarToXY(r, r, todayR, angle);
          const hi = highlightedPlanets.has(`today-${i}`);
          return (
            <g key={`t-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'today', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'today', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#ea580c" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#ea580c" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#ea580c">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}
      </svg>
    </div>
  );
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  return signs[idx]!;
}
function describeSector(cx: number, cy: number, r: number, startDeg: number, endDeg: number): string {
  const start = polarToXY(cx, cy, r, endDeg);
  const end = polarToXY(cx, cy, r, startDeg);
  const largeArc = endDeg - startDeg <= 180 ? 0 : 1;
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} 0 ${end.x} ${end.y} Z`;
}

```


## File: src\components\astro\SynastryWheelPro.tsx

```tsx
// src/components/astro/SynastryWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { ProPoint } from '@/lib/graphics/types';
import { PlanetName, ZodiacSign, planetChar, signColor } from '@/lib/graphics/glyphs';
import { aspectColor } from '@/lib/graphics/glyphs';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type AspectType = 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile';

export default function SynastryWheelPro({
  title = 'SynastryWheelPro',
  a,
  b,
  size = 520,
  className,
  defaultOrb = 6,
  defaultAspects = ['conjunction','opposition','trine','square','sextile'] as AspectType[],
  responsive = true,
  useTextGlyphs = true,
}: {
  title?: string;
  a: ProPoint[];
  b: ProPoint[];
  size?: number;
  className?: string;
  defaultOrb?: number;
  defaultAspects?: AspectType[];
  responsive?: boolean;
  useTextGlyphs?: boolean;
}) {
  const r = size / 2;
  const innerR = r * 0.45;
  const aR = r * 0.65;
  const bR = r * 0.90;

  const [orb, setOrb] = useState<number>(defaultOrb);
  const [enabled, setEnabled] = useState<Record<AspectType, boolean>>({
    conjunction: defaultAspects.includes('conjunction'),
    opposition:  defaultAspects.includes('opposition'),
    trine:       defaultAspects.includes('trine'),
    square:      defaultAspects.includes('square'),
    sextile:     defaultAspects.includes('sextile'),
  });
  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanet, setHoverPlanet] = useState<{ ring: 'a' | 'b'; idx: number } | null>(null);
  const [focusPlanet, setFocusPlanet] = useState<{ ring: 'a' | 'b'; idx: number } | null>(null);

  const aAngles = useMemo(() => resolveCollisions(a.map(p => p.longitude), 8), [a]);
  const bAngles = useMemo(() => resolveCollisions(b.map(p => p.longitude), 8), [b]);

  const aspects = useMemo(() => {
    const defs = [
      { type: 'conjunction' as const, deg: 0 },
      { type: 'opposition'  as const, deg: 180 },
      { type: 'trine'       as const, deg: 120 },
      { type: 'square'      as const, deg: 90 },
      { type: 'sextile'     as const, deg: 60 },
    ];
    const rows: { i: number; j: number; type: AspectType }[] = [];
    for (let i = 0; i < a.length; i++) {
      for (let j = 0; j < b.length; j++) {
        const diff = Math.abs(a[i].longitude - b[j].longitude) % 360;
        const d = diff > 180 ? 360 - diff : diff;
        const found = defs.find(x => enabled[x.type] && Math.abs(d - x.deg) <= orb);
        if (found) rows.push({ i, j, type: found.type });
      }
    }
    return rows;
  }, [a, b, enabled, orb]);

  const aspectsByA = useMemo(() => {
    const m = new Map<number, number[]>();
    aspects.forEach((aAsp, idx) => {
      (m.get(aAsp.i) ?? m.set(aAsp.i, []).get(aAsp.i)!).push(idx);
    });
    return m;
  }, [aspects]);
  const aspectsByB = useMemo(() => {
    const m = new Map<number, number[]>();
    aspects.forEach((aAsp, idx) => {
      (m.get(aAsp.j) ?? m.set(aAsp.j, []).get(aAsp.j)!).push(idx);
    });
    return m;
  }, [aspects]);

  const highlightedAspects = useMemo(() => {
    const s = new Set<number>();
    if (hoverAspectIdx != null) s.add(hoverAspectIdx);
    if (hoverPlanet) {
      const arr = hoverPlanet.ring === 'a' ? (aspectsByA.get(hoverPlanet.idx) ?? []) : (aspectsByB.get(hoverPlanet.idx) ?? []);
      arr.forEach(x => s.add(x));
    }
    return s;
  }, [hoverAspectIdx, hoverPlanet, aspectsByA, aspectsByB]);

  const highlightedPlanets = useMemo(() => {
    const s = new Set<string>();
    if (hoverAspectIdx != null) {
      const aAsp = aspects[hoverAspectIdx];
      s.add(`a-${aAsp.i}`); s.add(`b-${aAsp.j}`);
    }
    if (hoverPlanet) {
      s.add(`${hoverPlanet.ring}-${hoverPlanet.idx}`);
      const arr = hoverPlanet.ring === 'a' ? (aspectsByA.get(hoverPlanet.idx) ?? []) : (aspectsByB.get(hoverPlanet.idx) ?? []);
      for (const idx of arr) {
        const aAsp = aspects[idx];
        s.add(`a-${aAsp.i}`); s.add(`b-${aAsp.j}`);
      }
    }
    if (focusPlanet) s.add(`${focusPlanet.ring}-${focusPlanet.idx}`);
    return s;
  }, [hoverAspectIdx, hoverPlanet, focusPlanet, aspects, aspectsByA, aspectsByB]);

  const buildAria = (p: ProPoint) => {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}° ${sign}`;
  };

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 flex items-center justify-between gap-3">
        <div className="text-sm font-medium">{title}</div>
        <div className="flex items-center gap-3 text-xs">
          <div className="flex items-center gap-2">
            <label className="text-gray-600">orb</label>
            <input type="range" min={1} max={10} value={orb} onChange={(e) => setOrb(Number(e.target.value))} />
            <span className="w-6 text-right tabular-nums">{orb}°</span>
          </div>
          {(['conjunction','opposition','trine','square','sextile'] as AspectType[]).map(t => (
            <label key={t} className="inline-flex items-center gap-1">
              <input
                type="checkbox"
                checked={enabled[t]}
                onChange={(e) => setEnabled(s => ({ ...s, [t]: e.target.checked }))}
              />
              <span className="capitalize" style={{ color: aspectColor(t) }}>{t}</span>
            </label>
          ))}
        </div>
      </div>

      <svg
        role="img" aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* sfondo */}
        {Array.from({ length: 12 }).map((_, i) => {
          const start = i * 30, end = start + 30;
          const path = describeSector(r, r, r - 10, start, end);
          const signs: ZodiacSign[] = [
            'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
            'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
          ];
          return <path key={i} d={path} fill={signColor(signs[i])} fillOpacity={0.08} stroke="#e5e7eb" />;
        })}

        {/* aspetti + ticks */}
        {aspects.map((aAsp, idx) => {
          const aAngle = aAngles[aAsp.i];
          const bAngle = bAngles[aAsp.j];
          const p1 = polarToXY(r, r, innerR, aAngle);
          const p2 = polarToXY(r, r, innerR, bAngle);
          const hi = highlightedAspects.has(idx);
          return (
            <g key={idx} onMouseEnter={() => setHoverAspectIdx(idx)} onMouseLeave={() => setHoverAspectIdx(null)}>
              <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
                    stroke={aspectColor(aAsp.type)} strokeWidth={hi ? 2.4 : 1.2} opacity={hi ? 1 : 0.95}/>
              <circle cx={p1.x} cy={p1.y} r={2} fill="#2563eb" />
              <circle cx={p2.x} cy={p2.y} r={2} fill="#ea580c" />
            </g>
          );
        })}

        {/* pianeti A (blu) */}
        {a.map((p, i) => {
          const angle = aAngles[i];
          const pos = polarToXY(r, r, aR, angle);
          const hi = highlightedPlanets.has(`a-${i}`);
          return (
            <g key={`a-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'a', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'a', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#2563eb" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#2563eb">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}

        {/* pianeti B (arancio) */}
        {b.map((p, i) => {
          const angle = bAngles[i];
          const pos = polarToXY(r, r, bR, angle);
          const hi = highlightedPlanets.has(`b-${i}`);
          return (
            <g key={`b-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'b', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'b', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#ea580c" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#ea580c" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#ea580c">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}
      </svg>
    </div>
  );
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  return signs[idx]!;
}
function describeSector(cx: number, cy: number, r: number, startDeg: number, endDeg: number): string {
  const start = polarToXY(cx, cy, r, endDeg);
  const end = polarToXY(cx, cy, r, startDeg);
  const largeArc = endDeg - startDeg <= 180 ? 0 : 1;
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} 0 ${end.x} ${end.y} Z`;
}

```


## File: src\components\astro\TransitsWheelPro.tsx

```tsx
// src/components/astro/TransitsWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import type { ProPoint } from '@/lib/graphics/types';
import { PlanetName, ZodiacSign, planetChar, signColor } from '@/lib/graphics/glyphs';
import { aspectColor } from '@/lib/graphics/glyphs';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type AspectType = 'conjunction' | 'opposition' | 'trine' | 'square' | 'sextile';

export default function TransitsWheelPro({
  title = 'TransitsWheelPro',
  natal,
  transiting,
  size = 520,
  className,
  defaultOrb = 6,
  defaultAspects = ['conjunction','opposition','trine','square','sextile'] as AspectType[],
  responsive = true,
  useTextGlyphs = true,
}: {
  title?: string;
  natal: ProPoint[];
  transiting: ProPoint[];
  size?: number;
  className?: string;
  defaultOrb?: number;
  defaultAspects?: AspectType[];
  responsive?: boolean;
  useTextGlyphs?: boolean;
}) {
  const r = size / 2;
  const innerR = r * 0.45;
  const natalR = r * 0.65;
  const tranR  = r * 0.90;

  const [orb, setOrb] = useState<number>(defaultOrb);
  const [enabled, setEnabled] = useState<Record<AspectType, boolean>>({
    conjunction: defaultAspects.includes('conjunction'),
    opposition:  defaultAspects.includes('opposition'),
    trine:       defaultAspects.includes('trine'),
    square:      defaultAspects.includes('square'),
    sextile:     defaultAspects.includes('sextile'),
  });
  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanet, setHoverPlanet] = useState<{ ring: 'natal' | 'transit'; idx: number } | null>(null);
  const [focusPlanet, setFocusPlanet] = useState<{ ring: 'natal' | 'transit'; idx: number } | null>(null);

  const natalAngles = useMemo(() => resolveCollisions(natal.map(p => p.longitude), 8), [natal]);
  const tranAngles  = useMemo(() => resolveCollisions(transiting.map(p => p.longitude), 8), [transiting]);

  const aspects = useMemo(() => {
    const defs = [
      { type: 'conjunction' as const, deg: 0 },
      { type: 'opposition'  as const, deg: 180 },
      { type: 'trine'       as const, deg: 120 },
      { type: 'square'      as const, deg: 90 },
      { type: 'sextile'     as const, deg: 60 },
    ];
    const rows: { i: number; j: number; type: AspectType }[] = [];
    for (let i = 0; i < natal.length; i++) {
      for (let j = 0; j < transiting.length; j++) {
        const diff = Math.abs(natal[i].longitude - transiting[j].longitude) % 360;
        const d = diff > 180 ? 360 - diff : diff;
        const found = defs.find(a => enabled[a.type] && Math.abs(d - a.deg) <= orb);
        if (found) rows.push({ i, j, type: found.type });
      }
    }
    return rows;
  }, [natal, transiting, enabled, orb]);

  const aspectsByNatal = useMemo(() => {
    const m = new Map<number, number[]>();
    aspects.forEach((a, idx) => {
      (m.get(a.i) ?? m.set(a.i, []).get(a.i)!).push(idx);
    });
    return m;
  }, [aspects]);
  const aspectsByTransit = useMemo(() => {
    const m = new Map<number, number[]>();
    aspects.forEach((a, idx) => {
      (m.get(a.j) ?? m.set(a.j, []).get(a.j)!).push(idx);
    });
    return m;
  }, [aspects]);

  const highlightedAspects = useMemo(() => {
    const s = new Set<number>();
    if (hoverAspectIdx != null) s.add(hoverAspectIdx);
    if (hoverPlanet) {
      const arr = hoverPlanet.ring === 'natal' ? (aspectsByNatal.get(hoverPlanet.idx) ?? []) : (aspectsByTransit.get(hoverPlanet.idx) ?? []);
      arr.forEach(x => s.add(x));
    }
    return s;
  }, [hoverAspectIdx, hoverPlanet, aspectsByNatal, aspectsByTransit]);

  const highlightedPlanets = useMemo(() => {
    const s = new Set<string>();
    if (hoverAspectIdx != null) {
      const a = aspects[hoverAspectIdx];
      s.add(`natal-${a.i}`); s.add(`transit-${a.j}`);
    }
    if (hoverPlanet) {
      s.add(`${hoverPlanet.ring}-${hoverPlanet.idx}`);
      const arr = hoverPlanet.ring === 'natal' ? (aspectsByNatal.get(hoverPlanet.idx) ?? []) : (aspectsByTransit.get(hoverPlanet.idx) ?? []);
      for (const idx of arr) {
        const a = aspects[idx];
        s.add(`natal-${a.i}`); s.add(`transit-${a.j}`);
      }
    }
    if (focusPlanet) s.add(`${focusPlanet.ring}-${focusPlanet.idx}`);
    return s;
  }, [hoverAspectIdx, hoverPlanet, focusPlanet, aspects, aspectsByNatal, aspectsByTransit]);

  const buildAria = (p: ProPoint) => {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}° ${sign}`;
  };

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 flex items-center justify-between gap-3">
        <div className="text-sm font-medium">{title}</div>
        <div className="flex items-center gap-3 text-xs">
          <div className="flex items-center gap-2">
            <label className="text-gray-600">orb</label>
            <input type="range" min={1} max={10} value={orb} onChange={(e) => setOrb(Number(e.target.value))} />
            <span className="w-6 text-right tabular-nums">{orb}°</span>
          </div>
          {(['conjunction','opposition','trine','square','sextile'] as AspectType[]).map(t => (
            <label key={t} className="inline-flex items-center gap-1">
              <input
                type="checkbox"
                checked={enabled[t]}
                onChange={(e) => setEnabled(s => ({ ...s, [t]: e.target.checked }))}
              />
              <span className="capitalize" style={{ color: aspectColor(t) }}>{t}</span>
            </label>
          ))}
        </div>
      </div>

      <svg
        role="img" aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* sfondo: settori zodiacali */}
        {Array.from({ length: 12 }).map((_, i) => {
          const start = i * 30, end = start + 30;
          const path = describeSector(r, r, r - 10, start, end);
          const signs: ZodiacSign[] = [
            'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
            'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
          ];
          return <path key={i} d={path} fill={signColor(signs[i])} fillOpacity={0.08} stroke="#e5e7eb" />;
        })}

        {/* aspetti + endpoint ticks */}
        {aspects.map((a, idx) => {
          const aN = natalAngles[a.i];
          const aT = tranAngles[a.j];
          const p1 = polarToXY(r, r, innerR, aN);
          const p2 = polarToXY(r, r, innerR, aT);
          const hi = highlightedAspects.has(idx);
          return (
            <g key={idx} onMouseEnter={() => setHoverAspectIdx(idx)} onMouseLeave={() => setHoverAspectIdx(null)}>
              <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
                    stroke={aspectColor(a.type)} strokeWidth={hi ? 2.4 : 1.2} opacity={hi ? 1 : 0.95}/>
              <circle cx={p1.x} cy={p1.y} r={2} fill="#2563eb" />
              <circle cx={p2.x} cy={p2.y} r={2} fill="#ea580c" />
            </g>
          );
        })}

        {/* pianeti natal (blu) */}
        {natal.map((p, i) => {
          const angle = natalAngles[i];
          const pos = polarToXY(r, r, natalR, angle);
          const hi = highlightedPlanets.has(`natal-${i}`);
          return (
            <g key={`n-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'natal', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'natal', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#2563eb" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#2563eb">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}

        {/* pianeti transiting (arancio) */}
        {transiting.map((p, i) => {
          const angle = tranAngles[i];
          const pos = polarToXY(r, r, tranR, angle);
          const hi = highlightedPlanets.has(`transit-${i}`);
          return (
            <g key={`t-${i}`}
               transform={`translate(${pos.x},${pos.y}) scale(${size/520})`}
               tabIndex={0} role="img" aria-label={buildAria(p)}
               onFocus={() => setFocusPlanet({ ring: 'transit', idx: i })}
               onBlur={() => setFocusPlanet(null)}
               onMouseEnter={() => setHoverPlanet({ ring: 'transit', idx: i })}
               onMouseLeave={() => setHoverPlanet(null)}
               style={{ cursor: 'pointer' }}>
              {hi && <circle r={13.5} fill="none" stroke="#ea580c" strokeWidth={2} opacity={0.85} />}
              <circle r={10} fill="white" stroke="#ea580c" strokeWidth={hi ? 1.8 : 1} />
              {useTextGlyphs && (
                <text textAnchor="middle" dominantBaseline="central" fontSize={12}
                      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                      fill="#ea580c">
                  {planetChar(p.name as PlanetName)}
                </text>
              )}
              <title>{buildAria(p)}</title>
            </g>
          );
        })}
      </svg>

      <div className="mt-3 flex flex-wrap items-center gap-3 text-xs">
        <LegendItem color="#2563eb" label="Natal" />
        <LegendItem color="#ea580c" label="Transits" />
        {(['conjunction','opposition','trine','square','sextile'] as AspectType[]).map(t => (
          <LegendLine key={t} color={aspectColor(t)} label={t} active={enabled[t]} />
        ))}
      </div>
    </div>
  );
}

function LegendItem({ color, label }: { color: string; label: string }) {
  return (
    <span className="inline-flex items-center gap-1">
      <span className="inline-block h-3 w-3 rounded-full" style={{ background: color }} />
      <span className="text-gray-700">{label}</span>
    </span>
  );
}
function LegendLine({ color, label, active }: { color: string; label: string; active: boolean }) {
  return (
    <span className={`inline-flex items-center gap-1 ${active ? '' : 'opacity-40'}`}>
      <span className="inline-block h-[2px] w-5" style={{ background: color }} />
      <span className="capitalize text-gray-700">{label}</span>
    </span>
  );
}
function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  return signs[idx]!;
}
function describeSector(cx: number, cy: number, r: number, startDeg: number, endDeg: number): string {
  const start = polarToXY(cx, cy, r, endDeg);
  const end = polarToXY(cx, cy, r, startDeg);
  const largeArc = endDeg - startDeg <= 180 ? 0 : 1;
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArc} 0 ${end.x} ${end.y} Z`;
}

```


## File: src\components\AuthForm.tsx

```tsx
'use client';

import { useState } from 'react';
import { createSupabaseBrowser } from '@/lib/supabaseBrowser';

export default function AuthForm() {
  const supabase = createSupabaseBrowser();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const [loadingAction, setLoadingAction] = useState<'signup' | 'signin' | null>(null);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  async function doSignUp() {
    if (!email || !password) { setErr('Email and password required.'); return; }
    setLoadingAction('signup'); setErr(null); setMsg(null);
    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          // ← callback "non-API" come da struttura finale
          emailRedirectTo: `${window.location.origin}/auth/callback?next=/onboarding%23birth`,
        },
      });
      if (error) throw error;
      setMsg('Check your email to confirm your account. After confirming, you’ll be redirected here.');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Sign up error');
    } finally {
      setLoadingAction(null);
    }
  }

  async function doSignIn() {
    if (!email || !password) { setErr('Email and password required.'); return; }
    setLoadingAction('signin'); setErr(null); setMsg(null);
    try {
      // 1) login client
      const { error } = await supabase.auth.signInWithPassword({ email, password });
      if (error) throw error;

      // 2) porta i token al server per scrivere i cookie (necessari alle Server Components)
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token || !session.refresh_token) throw new Error('No session returned');

      const res = await fetch('/api/auth/set-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          access_token: session.access_token,
          refresh_token: session.refresh_token,
        }),
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`set-session failed (${res.status}): ${txt.slice(0, 120)}`);
      }
      const j = await res.json();
      if (!j.ok) throw new Error(j.error || 'Failed to set server session');

      // 3) forza una NAVIGAZIONE VERA (non solo hash) per ricaricare la Server Component
      const target = `/onboarding?ts=${Date.now()}#birth`;
      window.location.assign(target);
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Sign in error');
    } finally {
      setLoadingAction(null);
    }
  }

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <h2 className="font-medium">Create or access your account</h2>
      <div className="grid gap-2 sm:grid-cols-2">
        <input
          className="rounded border px-3 py-2 text-sm"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)} />
        <input
          className="rounded border px-3 py-2 text-sm"
          placeholder="Password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)} />
      </div>
      <div className="flex items-center gap-2">
        <button
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white hover:bg-blue-700"
          onClick={doSignUp}
          disabled={loadingAction !== null}
        >
          {loadingAction === 'signup' ? 'Signing up…' : 'Sign up'}
        </button>
        <button
          className="rounded border px-3 py-2 text-sm"
          onClick={doSignIn}
          disabled={loadingAction !== null}
        >
          {loadingAction === 'signin' ? 'Signing in…' : 'Sign in'}
        </button>
      </div>
      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}
      <p className="text-xs text-gray-500">
        We’ll store your chart and chat history securely. You can delete data anytime.
      </p>
    </div>
  );
}

```


## File: src\components\BirthForm.tsx

```tsx
// src/components/BirthForm.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type ResolveResult = {
  ok: boolean;
  query?: string;
  result?: {
    display_name: string;
    lat: number;
    lon: number;
    city: string | null;
    state: string | null;
    country: string | null;
    timezone: string | null;
    tz_offset_minutes: number | null;
  };
  error?: string;
};

type BirthInitial = {
  name?: string | null;
  date?: string | null;
  time?: string | null;
  place_name?: string | null;
  lat?: number | null;
  lon?: number | null;
  tz_name?: string | null; // opzionale; se assente, la risolviamo
};

export default function BirthForm({ initial }: { initial?: BirthInitial }) {
  const [name, setName] = useState(initial?.name ?? '');
  const [date, setDate] = useState(initial?.date ?? '');
  const [time, setTime] = useState(initial?.time ?? ''); // HH:MM
  const [placeQuery, setPlaceQuery] = useState(initial?.place_name ?? '');
  const [resolved, setResolved] = useState<ResolveResult | null>(null);

  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  // Se abbiamo già lat/lon/tz salvati, consideriamo "valida" la location
  const haveSavedPlace =
    !!initial?.place_name &&
    typeof initial?.lat === 'number' &&
    typeof initial?.lon === 'number';

  const canResolve = useMemo(() => placeQuery.trim().length >= 2, [placeQuery]);

  // È valida la place? o è stata risolta ora o abbiamo dati salvati
  const haveValidPlace = useMemo(() => {
    return (
      (resolved?.ok && !!resolved?.result?.timezone) ||
      (haveSavedPlace /* tz verrà ricavata da resolve al bisogno */)
    );
  }, [resolved, haveSavedPlace]);

  const canSubmit = useMemo(() => {
    return (
      name.trim().length > 0 &&
      /^\d{4}-\d{2}-\d{2}$/.test(date) &&
      haveValidPlace
    );
  }, [name, date, haveValidPlace]);

  async function resolvePlace() {
    setErr(null); setMsg(null); setResolved(null);
    if (!canResolve) { setErr('Type at least 2 characters for place'); return; }
    const params = new URLSearchParams();
    params.set('q', placeQuery.trim());
    params.set('date', date || '');
    if (time) params.set('time', time);

    const r = await fetch(`/api/geo/resolve?${params.toString()}`);
    const j = (await r.json()) as ResolveResult;
    if (!j.ok || !j.result) {
      setErr(j.error || 'Place not found');
      setResolved(j);
      return;
    }
    setResolved(j);
  }

  async function submit() {
    if (!canSubmit) return;
    setBusy(true); setErr(null); setMsg(null);

    try {
      // Usa i dati "resolved" se presenti; altrimenti i salvati iniziali
      const place = resolved?.result
        ? {
            place_name: resolved.result.display_name,
            lat: resolved.result.lat,
            lon: resolved.result.lon,
            tz_name: resolved.result.timezone || 'UTC',
          }
        : {
            place_name: initial?.place_name ?? placeQuery,
            lat: initial?.lat as number,
            lon: initial?.lon as number,
            tz_name: initial?.tz_name ?? null, // se null, comunque computePoints fallback a 'UTC'
          };

      const body = {
        name,
        date,
        time: time || null,
        ...place,
      };

      const resp = await fetch('/api/chart/compute', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      const j = await resp.json();
      if (!resp.ok || !j.ok) {
        throw new Error(j.error || `Compute failed (${resp.status})`);
      }

      setMsg('Birth data saved.');
      // Torna alla vista riassunto (rimuoviamo il flag edit)
      window.location.assign('/onboarding#birth');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Error');
    } finally {
      setBusy(false);
    }
  }

  // Se l'utente cambia query o data/ora, invalidiamo la risoluzione precedente
  useEffect(() => { setResolved(null); }, [placeQuery, date, time]);

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <div className="grid gap-3 md:grid-cols-2">
        <div className="space-y-1">
          <label className="text-xs text-gray-600">Full name</label>
          <input
            className="w-full rounded border px-3 py-2 text-sm"
            placeholder="e.g., Alex Morgan"
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birth date</label>
          <input
            type="date"
            className="w-full rounded border px-3 py-2 text-sm"
            value={date}
            onChange={(e) => setDate(e.target.value)}
          />
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birth time (optional)</label>
          <input
            type="time"
            className="w-full rounded border px-3 py-2 text-sm"
            value={time}
            onChange={(e) => setTime(e.target.value)}
          />
          <p className="text-xs text-gray-500">
            If unknown, we’ll use a solar chart (no houses/ASC).
          </p>
        </div>

        <div className="space-y-1">
          <label className="text-xs text-gray-600">Birthplace</label>
          <div className="flex gap-2">
            <input
              className="flex-1 rounded border px-3 py-2 text-sm"
              placeholder="City, Country"
              value={placeQuery}
              onChange={(e) => setPlaceQuery(e.target.value)}
            />
            <button
              type="button"
              className="rounded border px-3 py-2 text-sm"
              onClick={resolvePlace}
              disabled={!canResolve}
              title="Resolve with Nominatim"
            >
              Resolve
            </button>
          </div>

          {resolved?.ok && resolved.result ? (
            <div className="text-xs text-green-700">
              Resolved: {resolved.result.display_name} ({resolved.result.timezone})
            </div>
          ) : haveSavedPlace ? (
            <div className="text-xs text-gray-600">
              Using saved place: {initial?.place_name || '(unknown)'}
            </div>
          ) : (
            <div className="text-xs text-gray-500">Use Resolve to select a valid place.</div>
          )}
        </div>
      </div>

      <div className="flex items-center gap-2">
        <button
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white disabled:opacity-50"
          onClick={submit}
          disabled={!canSubmit || busy}
        >
          {busy ? 'Saving…' : 'Save natal chart'}
        </button>
        <button
          type="button"
          className="rounded border px-3 py-2 text-sm"
          onClick={() => window.location.assign('/onboarding#birth')}
        >
          Cancel
        </button>
      </div>

      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}

      <p className="text-xs text-gray-500">
        Wellness/entertainment only; not a substitute for medical, legal, or financial advice.
      </p>
    </div>
  );
}

```


## File: src\components\BirthSection.tsx

```tsx
'use client';

import { useMemo, useState } from 'react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import BirthForm from '@/components/BirthForm';

type Birth = {
  name: string;
  date: string;
  time: string;
  place_name: string;
  lat: number | null;
  lon: number | null;
};

export default function BirthSection({ birth }: { birth: Birth }) {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  // editMode è vero se ?edit=birth è presente oppure se l'utente ha cliccato Edit.
  const urlWantsEdit = (searchParams.get('edit') ?? '') === 'birth';
  const [localEdit, setLocalEdit] = useState(false);
  const editMode = urlWantsEdit || localEdit || !birth?.date || !birth?.place_name;

  const goEdit = () => {
    // Mantiene hash #birth e forza ?edit=birth (navigazione client → render immediato)
    const sp = new URLSearchParams(searchParams.toString());
    sp.set('edit', 'birth');
    router.replace(`${pathname}?${sp.toString()}#birth`);
    setLocalEdit(true);
  };

  const cancelEdit = () => {
    const sp = new URLSearchParams(searchParams.toString());
    sp.delete('edit');
    router.replace(`${pathname}?${sp.toString()}#birth`);
    setLocalEdit(false);
  };

  const hasSaved = useMemo(() => {
    return !!birth?.date && !!birth?.place_name;
  }, [birth]);

  if (editMode) {
    return (
      <div className="space-y-3">
        <BirthForm
          initial={{
            name: birth?.name ?? '',
            date: birth?.date ?? '',
            time: birth?.time ?? '',
            place_name: birth?.place_name ?? '',
            lat: birth?.lat ?? null,
            lon: birth?.lon ?? null,
          }}
        />
        <button
          type="button"
          onClick={cancelEdit}
          className="rounded border px-3 py-2 text-sm"
        >
          Cancel
        </button>
      </div>
    );
  }

  // Summary view + pulsante Edit SEMPRE visibile
  return (
    <div className="rounded-2xl border p-4 text-sm space-y-2">
      <div className="grid md:grid-cols-2 gap-2">
        <div><span className="text-gray-500">Name:</span> {birth?.name || '—'}</div>
        <div>
          <span className="text-gray-500">Date:</span>{' '}
          {birth?.date ? birth.date : '—'}{' '}
          {birth?.time ? `@ ${birth.time}` : '(solar chart)'}
        </div>
        <div className="md:col-span-2">
          <span className="text-gray-500">Place:</span> {birth?.place_name || '—'}
        </div>
      </div>

      <div className="flex items-center gap-2 pt-2">
        <button
          type="button"
          onClick={goEdit}
          className="rounded border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Edit birth data
        </button>
        {!hasSaved && (
          <span className="text-xs text-red-600">Complete your birth details to compute houses/ASC.</span>
        )}
      </div>

      <p className="text-xs text-gray-500">
        Whole Sign houses if time is provided. You can edit these details anytime.
      </p>
    </div>
  );
}

```


## File: src\components\ChartWheel.tsx

```tsx
// src/components/ChartWheel.tsx
// Wheel stile AstroDienst con case Placidus ordinate realmente in senso orario (CW)
// partendo dalla cuspide I. Numeri al midpoint dell’arco corretto.

import React, { useMemo } from 'react';

type Point = {
  name: string;
  longitude: number; // [0,360)
  sign?: string | null;
  house?: number | null;
  retro?: boolean | null;
};

type Props = {
  points: Point[];
  houseCusps?: number[];                // 12 cuspidi I..XII
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';     // default: by-asc (ASC a sinistra)
  direction?: 'cw' | 'ccw';             // default: 'cw' (come AstroDienst)
  size?: number;
  className?: string;
  showZodiacRing?: boolean;
  showHouseNumbers?: boolean;
};

const d2r = (d: number) => (d * Math.PI) / 180;
const norm = (x: number) => ((x % 360) + 360) % 360;

const SIGN_GLYPH = ['♈︎','♉︎','♊︎','♋︎','♌︎','♍︎','♎︎','♏︎','♐︎','♑︎','♒︎','♓︎'];
const SIGN_NAMES = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];

const POINT_GLYPH: Record<string,string> = {
  Sun: '☉', Moon: '☾', Mercury: '☿', Venus: '♀', Mars: '♂',
  Jupiter: '♃', Saturn: '♄', Uranus: '♅', Neptune: '♆', Pluto: '♇',
  'True Node': '☊', 'Mean Node': '☊', Node: '☊', 'South Node': '☋',
  Chiron: '⚷'
};

/** Proiezione λ → angolo SVG applicando direzione e rotazione. */
function projectAngleDeg(lambda: number, rotation: number, direction: 'cw' | 'ccw'): number {
  // SVG: 0° a destra, angoli crescono CCW.
  // - 'cw'  : angle = rotation - λ  (zodiaco visivamente orario)
  // - 'ccw' : angle = rotation + λ
  return direction === 'cw' ? norm(rotation - lambda) : norm(rotation + lambda);
}

/** Delta muovendosi CW nello spazio schermo (angoli proiettati). */
function deltaScreenCW(aStart: number, aEnd: number): number {
  return norm(aStart - aEnd); // [0,360)
}

/** Path SVG per un arco da aStart→aEnd nel verso CW o CCW. */
function arcPathDir(
  cx: number,
  cy: number,
  r: number,
  aStartDeg: number,
  aEndDeg: number,
  dir: 'cw' | 'ccw'
): string {
  const aStart = d2r(aStartDeg);
  let delta: number, endDeg: number, sweepFlag: 0 | 1;

  if (dir === 'ccw') {
    delta = norm(aEndDeg - aStartDeg);
    endDeg = aStartDeg + delta;
    sweepFlag = 1; // CCW
  } else {
    delta = norm(aStartDeg - aEndDeg);
    endDeg = aStartDeg - delta;
    sweepFlag = 0; // CW
  }

  const aEnd = d2r(norm(endDeg));
  const x1 = cx + Math.cos(aStart) * r;
  const y1 = cy + Math.sin(aStart) * r;
  const x2 = cx + Math.cos(aEnd) * r;
  const y2 = cy + Math.sin(aEnd) * r;
  const largeArc = delta > 180 ? 1 : 0;

  return `M ${x1} ${y1} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${x2} ${y2}`;
}

export default function ChartWheel({
  points,
  houseCusps,
  mcDeg,
  orientation = 'by-asc',
  direction = 'cw',
  size = 560,
  className,
  showZodiacRing = true,
  showHouseNumbers = true
}: Props) {
  const r = size / 2;
  const cx = r, cy = r;

  // Layer radii (rays fino al cerchio più interno, per spicchi netti)
  const R_OUTER = r - 8;
  const R_ZOD_OUT = r - 30;
  const R_ZOD_IN  = r - 64;
  const R_PLANETS = r - 108;
  const R_HOUSE_ARC = r - 146;
  const R_HOUSE_NUM = r - 168;
  const R_HOUSE_RAY = r - 200;
  const R_INNER = r - 200;

  const cusps = Array.isArray(houseCusps) && houseCusps.length === 12 ? houseCusps.map(norm) : null;
  const mcFromPoints = useMemo(() => points.find(p => p.name === 'MC')?.longitude ?? 0, [points]);
  const mc = typeof mcDeg === 'number' ? mcDeg : mcFromPoints;

  // Rotazione globale (ASC a sinistra, oppure MC in alto)
  const rotation = useMemo(() => {
    const dirSign = direction === 'cw' ? -1 : +1;
    if (orientation === 'by-asc' && cusps) return norm(180 - dirSign * cusps[0]);
    if (orientation === 'by-mc')          return norm( 90 - dirSign * norm(mc));
    return norm(90);
  }, [orientation, direction, cusps, mc]);

  // Anelli base
  const base = (
    <>
      <circle cx={cx} cy={cy} r={R_OUTER} fill="none" stroke="currentColor" strokeOpacity={0.25}/>
      <circle cx={cx} cy={cy} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={0.2}/>
      <circle cx={cx} cy={cy} r={R_ZOD_IN}  fill="none" stroke="currentColor" strokeOpacity={0.2}/>
      <circle cx={cx} cy={cy} r={R_INNER}   fill="none" stroke="currentColor" strokeOpacity={0.25}/>
    </>
  );

  // Zodiaco
  const zodiac = showZodiacRing ? (
    <>
      {Array.from({ length: 12 }, (_, i) => {
        const deg = i * 30;
        const A = d2r(projectAngleDeg(deg, rotation, direction));
        const x1 = cx + Math.cos(A) * R_ZOD_OUT;
        const y1 = cy + Math.sin(A) * R_ZOD_OUT;
        const x2 = cx + Math.cos(A) * R_ZOD_IN;
        const y2 = cy + Math.sin(A) * R_ZOD_IN;
        return <line key={`z-split-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke="currentColor" strokeOpacity={0.35}/>;
      })}
      {Array.from({ length: 12 }, (_, i) => {
        const mid = i * 30 + 15;
        const A = d2r(projectAngleDeg(mid, rotation, direction));
        const lx = cx + Math.cos(A) * ((R_ZOD_OUT + R_ZOD_IN) / 2);
        const ly = cy + Math.sin(A) * ((R_ZOD_OUT + R_ZOD_IN) / 2);
        return (
          <text
            key={`z-glyph-${i}`}
            x={lx} y={ly}
            textAnchor="middle" dominantBaseline="central"
            fontSize={14} fill="currentColor" opacity={0.9}
            aria-label={SIGN_NAMES[i]}
          >
            {SIGN_GLYPH[i]}
          </text>
        );
      })}
    </>
  ) : null;

  // --- CASE ---

  // Raggi sulle cuspidi, fino al cerchio interno
  const houseRays = cusps?.map((deg, i) => {
    const A = d2r(projectAngleDeg(deg, rotation, direction));
    const x1 = cx + Math.cos(A) * R_ZOD_IN;
    const y1 = cy + Math.sin(A) * R_ZOD_IN;
    const x2 = cx + Math.cos(A) * R_HOUSE_RAY;
    const y2 = cy + Math.sin(A) * R_HOUSE_RAY;
    const thick = (i === 0 || i === 9) ? 2 : 1;
    return <line key={`h-ray-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke="currentColor" strokeWidth={thick} />;
  }) ?? null;

  let houseArcs: JSX.Element[] | null = null;
  let houseNums: JSX.Element[] | null = null;

  if (cusps) {
    // Angoli proiettati delle 12 cuspidi
    const A: number[] = cusps.map(c => projectAngleDeg(c, rotation, direction));
    const N = 12;

    // Per ogni cuspide i, trova l'indice j della SUCCESSIVA adiacente in CW
    const nextCW: number[] = new Array(N).fill(0);
    for (let i = 0; i < N; i++) {
      let best = 360, bestJ = i;
      for (let k = 0; k < N; k++) {
        if (k === i) continue;
        const d = deltaScreenCW(A[i], A[k]);
        if (d > 0 && d < best) { best = d; bestJ = k; }
      }
      nextCW[i] = bestJ;
    }

    // Cammina davvero da cuspide I (indice 0) seguendo nextCW in CW → ordine geometrico
    const order: number[] = [];
    const seen = new Array(N).fill(false);
    let cur = 0;
    for (let step = 0; step < N; step++) {
      order.push(cur);
      seen[cur] = true;
      const nxt = nextCW[cur];
      if (seen[nxt]) {
        // (degenere) se chiude un ciclo prima di 12, riempi con gli indici mancanti ordinati per angolo CW
        if (order.length < N) {
          const rest = [...Array(N).keys()].filter(ix => !seen[ix]);
          // ordina i rimanenti in senso CW rispetto all’ultimo angolo
          rest.sort((i, j) => deltaScreenCW(A[cur], A[i]) - deltaScreenCW(A[cur], A[j]));
          order.push(...rest);
        }
        break;
      }
      cur = nxt;
    }
    if (order.length < N) {
      // fallback di sicurezza (non dovrebbe servire)
      const idx = [...Array(N).keys()];
      idx.sort((i, j) => deltaScreenCW(A[0], A[i]) - deltaScreenCW(A[0], A[j]));
      for (const k of idx) if (!order.includes(k)) order.push(k);
    }

    // Disegna archi Casa j: order[j] → order[j+1] (CW) e numero al midpoint di quell’arco
    houseArcs = order.map((idx, j) => {
      const start = A[idx];
      const end   = A[order[(j + 1) % N]];
      const path  = arcPathDir(cx, cy, R_HOUSE_ARC, start, end, 'cw');
      return (
        <path
          key={`h-arc-${j}`}
          d={path}
          fill="none"
          stroke="currentColor"
          strokeOpacity={0.28}
        />
      );
    });

    if (showHouseNumbers) {
      houseNums = order.map((idx, j) => {
        const start = A[idx];
        const end   = A[order[(j + 1) % N]];
        const delta = norm(start - end); // CW
        const midDeg = norm(start - delta / 2);
        const mid = d2r(midDeg);
        const lx = cx + Math.cos(mid) * R_HOUSE_NUM;
        const ly = cy + Math.sin(mid) * R_HOUSE_NUM;
        return (
          <text
            key={`h-num-${j}`}
            x={lx} y={ly}
            textAnchor="middle" dominantBaseline="central"
            fontSize={12} fill="currentColor" opacity={0.9}
          >
            {j + 1}
          </text>
        );
      });
    }
  }

  // Angoli (etichette sulle loro cuspidi)
  const angleLabels = cusps ? (() => {
    const idx = { AC: 0, MC: 9, DC: 6, IC: 3 }; // I, X, VII, IV
    return (Object.entries(idx) as Array<[keyof typeof idx, number]>).map(([label, i]) => {
      const A = d2r(projectAngleDeg(cusps[i], rotation, direction));
      const lx = cx + Math.cos(A) * (R_ZOD_OUT + 8);
      const ly = cy + Math.sin(A) * (R_ZOD_OUT + 8);
      return (
        <text key={`ang-${label}`} x={lx} y={ly} textAnchor="middle" dominantBaseline="central" fontSize={12}>
          {label}
        </text>
      );
    });
  })() : null;

  // Pianeti (senza angoli): tacchetta blu verso zodiaco
  const planetDots = points
    .filter(p => p.name !== 'ASC' && p.name !== 'MC' && p.name !== 'IC' && p.name !== 'DSC')
    .map((p) => {
      const lam = norm(p.longitude);
      const A = d2r(projectAngleDeg(lam, rotation, direction));
      const x = cx + Math.cos(A) * R_PLANETS;
      const y = cy + Math.sin(A) * R_PLANETS;

      const tx1 = cx + Math.cos(A) * (R_ZOD_IN + 4);
      const ty1 = cy + Math.sin(A) * (R_ZOD_IN + 4);
      const tx2 = cx + Math.cos(A) * (R_ZOD_IN + 12);
      const ty2 = cy + Math.sin(A) * (R_ZOD_IN + 12);

      const glyph = POINT_GLYPH[p.name] ?? p.name.slice(0, 1).toUpperCase();

      return (
        <g key={`pt-${p.name}-${lam.toFixed(2)}`}>
          <line x1={tx1} y1={ty1} x2={tx2} y2={ty2} stroke="#3b82f6" strokeWidth={1}/>
          <circle cx={x} cy={y} r={3} fill="currentColor" />
          <text
            x={x} y={y}
            dx={8} dy={-4}
            fontSize={11}
            textAnchor="start" dominantBaseline="central"
            fill="currentColor"
          >
            {glyph}{p.retro ? ' ℞' : ''}
          </text>
        </g>
      );
    });

  return (
    <svg width={size} height={size} className={className} role="img" aria-label="Astrology Chart Wheel">
      {base}
      {zodiac}
      {/* Case: archi (ampiezza), raggi (cuspidi) e numeri (midpoint CW in ordine 1..12) */}
      {houseArcs}
      {houseRays}
      {houseNums}
      {planetDots}
      {angleLabels}
    </svg>
  );
}

```


## File: src\components\ChatUI.tsx

```tsx
'use client';

import React, { useMemo, useRef, useState } from 'react';
import { systemChat } from '@/ai/systemPrompts';

type Msg = { role: 'system' | 'user' | 'assistant'; content: string };

type Props = {
  /** Contesto da /api/compat/[id] (CONTEXT_*, PEER_SUMMARY, ecc.) */
  initialContext?: string;
  /** Se vuoi passare un system prompt già unito, questo ha priorità */
  systemPrompt?: string;
  /** Endpoint della chat (default: /api/chat) */
  endpoint?: string;
};

/* ---------- Type guards & helpers (no any) ---------- */
function isRecord(o: unknown): o is Record<string, unknown> {
  return typeof o === 'object' && o !== null;
}
function isTextHolder(o: unknown): o is { text: string } {
  return isRecord(o) && typeof o.text === 'string';
}
function get(obj: unknown, path: Array<string | number>): unknown {
  let cur: unknown = obj;
  for (const key of path) {
    if (!isRecord(cur) && !Array.isArray(cur)) return undefined;
    if (typeof key === 'number') {
      if (!Array.isArray(cur) || key < 0 || key >= cur.length) return undefined;
      cur = cur[key];
    } else {
      const rec = cur as Record<string, unknown>;
      if (!(key in rec)) return undefined;
      cur = rec[key];
    }
  }
  return cur;
}

/** Estrae testo da stringhe o array di blocchi con {text} (OpenAI/Anthropic-like) */
function extractFromContentField(content: unknown): string {
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) {
    const parts = content
      .map((c) => (typeof c === 'string' ? c : isTextHolder(c) ? c.text : ''))
      .filter(Boolean);
    return parts.join('');
  }
  if (isTextHolder(content)) return content.text;
  return '';
}

/** Estrae il testo dai formati JSON più comuni (aggiunge anche supporto a { answer: "..." }) */
function extractTextFromJSON(json: unknown): string {
  if (!isRecord(json)) return '';

  // Diretti (incluso 'answer')
  const direct =
    get(json, ['answer']) ??            // <-- supporto al tuo backend
    get(json, ['reply']) ??
    get(json, ['content']) ??
    get(json, ['message']) ??
    get(json, ['text']) ??
    get(json, ['output_text']) ??
    get(json, ['result', 'text']) ??
    get(json, ['data', 0, 'text']) ??
    get(json, ['generations', 0, 'text']);
  const directStr = extractFromContentField(direct);
  if (directStr) return directStr;

  // OpenAI chat (non stream)
  const msgContent = get(json, ['choices', 0, 'message', 'content']);
  const msgStr = extractFromContentField(msgContent);
  if (msgStr) return msgStr;

  // Delta anche senza stream
  const deltaContent = get(json, ['choices', 0, 'delta', 'content']);
  const deltaStr = extractFromContentField(deltaContent);
  if (deltaStr) return deltaStr;

  // Anthropic-like
  const anthropicStr = extractFromContentField(get(json, ['content']));
  if (anthropicStr) return anthropicStr;

  return '';
}

/** Normalizza il testo per l’utente: niente **grassetti**, niente \n raw, bullet carini */
function normalizeOutput(text: string): string {
  let t = text;

  // Se accidentalmente è stato passato un JSON in stringa, prova a leggerlo
  if (t.trim().startsWith('{') && t.includes('"answer"')) {
    try {
      const parsed = JSON.parse(t) as unknown;
      const fromJson = extractTextFromJSON(parsed);
      if (fromJson) t = fromJson;
    } catch {
      // ignore
    }
  }

  // Unifica newline e rimuovi escape visivi
  t = t.replace(/\r\n/g, '\n');
  t = t.replace(/\\n/g, '\n').replace(/\\t/g, '    ');

  // Rimuovi markdown base
  t = t.replace(/\*\*(.*?)\*\*/g, '$1'); // **bold** -> bold
  t = t.replace(/\*(.*?)\*/g, '$1');     // *italic* -> italic (semplice)

  // Bullet list più leggibili
  t = t.replace(/^\s*-\s+/gm, '• ');

  // Collassa e rifinisci
  t = t.replace(/\n{3,}/g, '\n\n').trim();
  return t;
}
/* ---------------------------------------------------- */

export default function ChatUI({
  initialContext = '',
  systemPrompt,
  endpoint = '/api/chat',
}: Props) {
  // 1) Costruisci il messaggio di sistema unendo regole + contesto
  const finalSystem = useMemo(() => {
    if (systemPrompt && systemPrompt.trim()) return systemPrompt.trim();
    const blocks: string[] = [];
    if (systemChat) blocks.push(systemChat.trim());
    if (initialContext) blocks.push(initialContext.trim());
    return blocks.join('\n\n').trim();
  }, [systemPrompt, initialContext]);

  // Stato messaggi: includi il system come primo messaggio (non mostrato)
  const [messages, setMessages] = useState<Msg[]>(
    finalSystem ? [{ role: 'system', content: finalSystem }] : []
  );
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const streamingRef = useRef(false);

  function pushUserMessage(text: string) {
    setMessages(prev => [...prev, { role: 'user', content: text }]);
  }
  function startAssistantMessage() {
    setMessages(prev => [...prev, { role: 'assistant', content: '' }]);
  }
  function appendToAssistant(chunk: string) {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (!last || last.role !== 'assistant') return out;
      last.content = (last.content || '') + chunk;
      return out;
    });
  }
  function setAssistant(text: string) {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (!last || last.role !== 'assistant') out.push({ role: 'assistant', content: text });
      else last.content = text;
      return out;
    });
  }
  function normalizeLastAssistant() {
    setMessages(prev => {
      const out = [...prev];
      const last = out[out.length - 1];
      if (last && last.role === 'assistant') {
        last.content = normalizeOutput(last.content || '');
      }
      return out;
    });
  }

  // SSE (OpenAI style)
  async function readSSE(res: Response) {
    const reader = res.body?.getReader();
    if (!reader) { setAssistant('Errore: stream non disponibile.'); return; }
    streamingRef.current = true;
    startAssistantMessage();

    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });

      const lines = buffer.split(/\r?\n/);
      buffer = lines.pop() || '';

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || !trimmed.startsWith('data:')) continue;
        const data = trimmed.slice(5).trim();
        if (data === '[DONE]') { streamingRef.current = false; normalizeLastAssistant(); return; }
        try {
          const parsed: unknown = JSON.parse(data);
          const piece =
            extractFromContentField(get(parsed, ['choices', 0, 'delta', 'content'])) ||
            extractFromContentField(get(parsed, ['choices', 0, 'message', 'content'])) ||
            extractFromContentField(get(parsed, ['content'])) ||
            '';
          if (piece) appendToAssistant(piece);
        } catch {
          if (data) appendToAssistant(data + '\n');
        }
      }
    }
    streamingRef.current = false;
    normalizeLastAssistant();
  }

  // ——— Send ———
  async function send() {
    const text = input.trim();
    if (!text || loading) return;
    setLoading(true);

    pushUserMessage(text);
    setInput('');

    try {
      const payload = {
        messages: [...messages, { role: 'user', content: text } as Msg],
        system: finalSystem,
        prompt: finalSystem ? `${finalSystem}\n\n${text}` : text,
        question: text,
      };

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'accept': 'text/event-stream, application/json, text/plain',
        },
        body: JSON.stringify(payload),
      });

      const ctype = res.headers.get('content-type') || '';

      // Caso 1: SSE
      if (ctype.includes('text/event-stream')) {
        await readSSE(res);
        setLoading(false);
        return;
      }

      // Caso 2: JSON (leggiamo anche raw per fallback)
      if (ctype.includes('application/json')) {
        const raw = await res.clone().text().catch(() => '');
        let assistantText = '';
        try {
          const j: unknown = await res.json();
          assistantText = extractTextFromJSON(j);
        } catch {
          assistantText = '';
        }
        if (!assistantText && raw) {
          // alcuni back-end mandano JSON con content-type sbagliato nella clone
          try {
            const maybe: unknown = JSON.parse(raw);
            assistantText = extractTextFromJSON(maybe);
          } catch {
            assistantText = raw;
          }
        }
        setAssistant(assistantText ? normalizeOutput(assistantText) : 'Non ho ricevuto un contenuto utilizzabile dal modello.');
        setLoading(false);
        return;
      }

      // Caso 3: testo semplice (o content-type non affidabile)
      const textBody = await res.text();
      const clean = (textBody || '').trim();
      // Prova a interpretarlo come JSON con answer; altrimenti normalizza testo
      let final = '';
      if (clean.startsWith('{')) {
        try {
          const maybe: unknown = JSON.parse(clean);
          final = extractTextFromJSON(maybe);
        } catch {
          final = clean;
        }
      } else {
        final = clean;
      }
      setAssistant(final ? normalizeOutput(final) : 'Non ho ricevuto una risposta valida dal modello.');
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Errore di rete';
      setAssistant(`Errore: ${msg}`);
    } finally {
      setLoading(false);
    }
  }

  function onKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      void send();
    }
  }

  return (
    <div className="flex h-full flex-col">
      {/* Messaggi (non mostro il system) */}
      <div className="flex-1 overflow-y-auto space-y-3 pr-2">
        {messages
          .filter(m => m.role !== 'system')
          .map((m, i) => (
            <div
              key={i}
              className={
                m.role === 'user'
                  ? 'ml-auto max-w-[80%] rounded-2xl border px-3 py-2 bg-gray-50'
                  : 'mr-auto max-w-[80%] rounded-2xl border px-3 py-2'
              }
            >
              <div className="whitespace-pre-wrap text-[0.95rem] leading-relaxed">
                {m.content}
              </div>
            </div>
          ))}
      </div>

      {/* Input */}
      <div className="mt-3 flex gap-2">
        <input
          className="flex-1 rounded-lg border px-3 py-2"
          placeholder='Es. "qual è il segno di questa persona?"'
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={onKeyDown}
          disabled={loading}
        />
        <button
          className="rounded-lg border px-4 py-2 disabled:opacity-50"
          onClick={send}
          disabled={loading || !input.trim()}
        >
          {loading ? (streamingRef.current ? 'Ricevo…' : 'Invio…') : 'Invia'}
        </button>
      </div>

      <p className="mt-2 text-xs text-gray-500">
        La chat mostra solo testo pulito: niente JSON, niente markdown rumoroso.
      </p>
    </div>
  );
}

```


## File: src\components\CurrentLocationForm.tsx

```tsx
// src/components/CurrentLocationForm.tsx
'use client';

import { useEffect, useMemo, useState } from 'react';

type ResolvePayload = {
  display_name: string;
  lat: number;
  lon: number;
  city: string | null;
  state: string | null;
  country: string | null;
  timezone: string | null;
  tz_offset_minutes: number | null;
};

type ResolveResult = {
  ok: boolean;
  query?: string;
  result?: ResolvePayload;
  error?: string;
};

export type CurrentLocationInitial = {
  place_name?: string | null;
  lat?: number | null;
  lon?: number | null;
  tz_name?: string | null;
};

export default function CurrentLocationForm(props: { initial?: CurrentLocationInitial }) {
  const { initial } = props;

  const [query, setQuery] = useState<string>(initial?.place_name ?? '');
  const [resolved, setResolved] = useState<ResolveResult | null>(null);

  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string | null>(null);
  const [err, setErr] = useState<string | null>(null);

  const haveSaved =
    typeof initial?.lat === 'number' &&
    typeof initial?.lon === 'number' &&
    !!initial?.place_name;

  const canResolve = useMemo(() => query.trim().length >= 2, [query]);

  useEffect(() => {
    setResolved(null);
    setMsg(null);
    setErr(null);
  }, [query]);

  async function resolvePlace() {
    if (!canResolve) return;
    setBusy(true);
    setMsg(null);
    setErr(null);
    try {
      const r = await fetch(`/api/geo/resolve?q=${encodeURIComponent(query.trim())}`);
      const j = (await r.json()) as ResolveResult;
      if (!j.ok || !j.result) throw new Error(j.error || 'Place not found');
      setResolved(j);
      setMsg(`Resolved: ${j.result.display_name} ${j.result.timezone ? `(${j.result.timezone})` : ''}`);
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Resolve error');
    } finally {
      setBusy(false);
    }
  }

  const canSave = useMemo(() => {
    if (resolved?.ok && resolved.result) return true;
    return haveSaved;
  }, [resolved, haveSaved]);

  async function savePrefs() {
    if (!canSave) return;
    setBusy(true);
    setMsg(null);
    setErr(null);
    try {
      // usa i dati risolti se presenti, altrimenti quelli salvati
      const payload = resolved?.result
        ? {
            place_name: resolved.result.display_name,
            lat: resolved.result.lat,
            lon: resolved.result.lon,
            tz_name: resolved.result.timezone ?? null,
          }
        : {
            place_name: initial?.place_name ?? '',
            lat: (initial?.lat ?? null) as number | null,
            lon: (initial?.lon ?? null) as number | null,
            tz_name: initial?.tz_name ?? null,
          };

      const resp = await fetch('/api/user/prefs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const j = (await resp.json()) as { ok?: boolean; error?: string };
      if (!resp.ok || !j.ok) throw new Error(j.error || `Save failed (${resp.status})`);

      setMsg('Current location saved.');
      // opzionale: vai al dashboard
      // window.location.assign('/dashboard');
    } catch (e: unknown) {
      setErr(e instanceof Error ? e.message : 'Save error');
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <div className="space-y-1">
        <label className="text-xs text-gray-600">Current city (for transits)</label>
        <div className="flex gap-2">
          <input
            className="flex-1 rounded border px-3 py-2 text-sm"
            placeholder="City, Country"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
          />
          <button
            type="button"
            className="rounded border px-3 py-2 text-sm"
            onClick={resolvePlace}
            disabled={!canResolve || busy}
            title="Resolve with Nominatim"
          >
            {busy ? 'Resolving…' : 'Resolve'}
          </button>
        </div>

        {resolved?.ok && resolved.result ? (
          <div className="text-xs text-green-700">
            Resolved: {resolved.result.display_name}{' '}
            {resolved.result.timezone ? `(${resolved.result.timezone})` : ''}
          </div>
        ) : haveSaved ? (
          <div className="text-xs text-gray-600">
            Using saved place: {initial?.place_name}
            {initial?.tz_name ? ` (${initial.tz_name})` : ''}
          </div>
        ) : (
          <div className="text-xs text-gray-500">Use Resolve to select a valid place.</div>
        )}
      </div>

      <div className="flex items-center gap-2">
        <button
          type="button"
          onClick={savePrefs}
          disabled={!canSave || busy}
          className="rounded border px-3 py-2 text-sm bg-blue-600 text-white disabled:opacity-50"
        >
          {busy ? 'Saving…' : 'Save current location'}
        </button>
      </div>

      {msg && <div className="text-green-700 text-sm">{msg}</div>}
      {err && <div className="text-red-700 text-sm">{err}</div>}

      <p className="text-xs text-gray-500">
        Wellness/entertainment only; not a substitute for medical, legal, or financial advice.
      </p>
    </div>
  );
}

```


## File: src\components\HouseSystemSwitcher.tsx

```tsx
// src/components/HouseSystemSwitcher.tsx
'use client';

import { useState, useTransition } from 'react';
import { useRouter } from 'next/navigation';

type HouseSystem = 'placidus' | 'whole';

type Props = {
  current: HouseSystem;
  size?: 'sm' | 'md';
  className?: string;
};

export default function HouseSystemSwitcher({ current, size = 'md', className }: Props) {
  const [pending, startTransition] = useTransition();
  const [local, setLocal] = useState<HouseSystem>(current);
  const router = useRouter();

  const sizeClass = size === 'sm' ? 'px-2 py-1 text-xs' : 'px-3 py-1.5 text-sm';

  const btnBase =
    `rounded-md border ${sizeClass} transition-colors disabled:opacity-60 disabled:cursor-not-allowed`;
  const btnActive = 'bg-blue-600 text-white border-blue-600';
  const btnIdle = 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50';

  async function apply(system: HouseSystem) {
    if (system === local || pending) return;
    setLocal(system);

    try {
      const res = await fetch(`/api/chart/compute?system=${system}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ source: 'HouseSystemSwitcher' }),
        cache: 'no-store',
      });
      const json = await res.json().catch(() => ({}));
      if (!res.ok) {
        console.error('compute error', res.status, json);
        alert('Errore nel ricalcolo. Riprova.');
        return;
      }
      if (json?.fallbackApplied) {
        alert('Placidus non disponibile alla latitudine indicata: attivato il fallback Whole Sign.');
      }
    } catch (err) {
      console.error(err);
      alert('Errore di rete durante il ricalcolo.');
    } finally {
      startTransition(() => {
        router.refresh();
      });
    }
  }

  return (
    <div className={`inline-flex items-center gap-2 ${className ?? ''}`}>
      <span className="text-xs text-gray-500">House system:</span>
      <div className="inline-flex gap-1" aria-busy={pending}>
        <button
          type="button"
          className={`${btnBase} ${local === 'whole' ? btnActive : btnIdle}`}
          onClick={() => apply('whole')}
          disabled={pending}
          aria-pressed={local === 'whole'}
        >
          Whole
        </button>
        <button
          type="button"
          className={`${btnBase} ${local === 'placidus' ? btnActive : btnIdle}`}
          onClick={() => apply('placidus')}
          disabled={pending}
          aria-pressed={local === 'placidus'}
        >
          Placidus
        </button>
      </div>
    </div>
  );
}

```


## File: src\components\MonthTransitsList.tsx

```tsx
'use client';

import React, { MouseEvent, useRef } from 'react';

type AspectKey = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

type TransitHit = {
  date: string;
  t_planet: string;
  n_point: string;
  aspect: AspectKey;
  orb: number;
  score: number;
};

type DayBucket = { date: string; items: TransitHit[] };

function symbolForAspect(a: AspectKey): string {
  switch (a) {
    case 'conjunction': return '☌';
    case 'sextile':     return '✶';
    case 'square':      return '□';
    case 'trine':       return '△';
    case 'opposition':  return '☍';
  }
}

function fmtGoogleStamp(iso: string) {
  const d = new Date(iso);
  const pad = (n: number) => String(n).padStart(2, '0');
  return (
    d.getUTCFullYear().toString() +
    pad(d.getUTCMonth() + 1) +
    pad(d.getUTCDate()) +
    'T' +
    pad(d.getUTCHours()) +
    pad(d.getUTCMinutes()) +
    pad(d.getUTCSeconds()) +
    'Z'
  );
}

export default function MonthTransitsList({
  ym,
  days,
}: {
  ym: string;
  days: DayBucket[];
}) {
  const scrollRef = useRef<HTMLDivElement>(null);

  const goToDay = (e: MouseEvent<HTMLAnchorElement>, date: string) => {
    e.preventDefault();
    const container = scrollRef.current;
    if (!container) return;
    const el = container.querySelector<HTMLElement>(`section[data-date="${date}"]`);
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
  };

  return (
    <div className="rounded-2xl border p-4">
      {/* Indice "vai al giorno" compatto */}
      <nav className="mb-3 flex flex-wrap gap-2 text-xs">
        {days.map((d) => (
          <a
            key={d.date}
            href={`#${d.date}`}
            onClick={(e) => goToDay(e, d.date)}
            className="rounded-lg border px-2 py-1 hover:bg-gray-50"
            title={`Vai al ${d.date}`}
          >
            {d.date.slice(-2)}
          </a>
        ))}
      </nav>

      {/* Scroller interno che contiene TUTTI i transiti */}
      <div
        ref={scrollRef}
        className="h-[75vh] overflow-y-auto pr-2 space-y-5"
        aria-label={`Transiti di ${ym}`}
      >
        {days.map(({ date, items }) => (
          <section
            key={date}
            data-date={date}
            className="rounded-2xl border p-4 scroll-mt-24 bg-white"
          >
            <div className="mb-3 flex items-center justify-between">
              <h2 className="text-base font-semibold">{date}</h2>
              <a
                href={`#${date}`}
                onClick={(e) => goToDay(e, date)}
                className="text-xs text-gray-600 hover:underline"
              >
                Vai al giorno
              </a>
            </div>

            <ul className="space-y-3">
              {items.map((t, idx) => {
                const startISO = `${date}T09:00:00Z`; // orario placeholder
                const endISO = `${date}T10:00:00Z`;
                const gStart = fmtGoogleStamp(startISO);
                const gEnd = fmtGoogleStamp(endISO);

                const title = `${t.t_planet} ${t.aspect} ${t.n_point}`;
                const description = `Orb ${t.orb}°, score ${Math.round(
                  t.score
                )}. Generated by Natal + Transits + Chat (wellbeing/entertainment).`;

                const gcal = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(
                  title
                )}&dates=${gStart}/${gEnd}&details=${encodeURIComponent(description)}`;
                const ics = `/api/calendar/ics?title=${encodeURIComponent(
                  title
                )}&description=${encodeURIComponent(
                  description
                )}&start=${encodeURIComponent(startISO)}&duration=60`;

                return (
                  <li
                    key={`${date}-${t.t_planet}-${t.n_point}-${idx}`}
                    className="rounded-xl border p-3"
                  >
                    <div className="flex items-center justify-between">
                      <div className="font-medium">
                        {t.t_planet} {symbolForAspect(t.aspect)} {t.n_point}
                      </div>
                      <div className="text-xs text-gray-500">
                        orb {t.orb.toFixed(1)}° • score {Math.round(t.score)}
                      </div>
                    </div>

                    <div className="mt-2 flex items-center gap-2">
                      <a
                        href={gcal}
                        target="_blank"
                        rel="noreferrer"
                        className="rounded-lg border px-2 py-1 text-xs hover:bg-gray-50"
                      >
                        Google Calendar
                      </a>
                      <a
                        href={ics}
                        className="rounded-lg border px-2 py-1 text-xs hover:bg-gray-50"
                      >
                        Download .ics
                      </a>
                    </div>
                  </li>
                );
              })}
            </ul>
          </section>
        ))}
      </div>
    </div>
  );
}

```


## File: src\components\MoonPhaseCard.tsx

```tsx
// src/components/MoonPhaseCard.tsx
'use client';

import React from 'react';

export default function MoonPhaseCard({
  dateISO,
  tzName,
  moonSign,
  phaseName,
  illumination, // 0..1
  emoji,        // 🌑🌒🌓🌔🌕🌖🌗🌘
}: {
  dateISO: string;
  tzName: string;
  moonSign: string;
  phaseName: string;
  illumination: number;
  emoji: string;
}) {
  const pct = Math.round(illumination * 100);

  return (
    <div className="rounded-2xl border p-4 bg-white">
      <div className="mb-3 text-sm font-medium">
        Lunar calendar · {dateISO} ({tzName})
      </div>

      <div className="flex items-center gap-4">
        <div className="flex h-24 w-24 items-center justify-center rounded-xl border text-4xl bg-gray-50">
          {emoji}
        </div>

        <div className="text-sm">
          <div className="text-lg font-semibold mb-1">Moon in {moonSign}</div>
          <div className="text-gray-700">{phaseName}</div>
          <div className="text-gray-500">{pct}% illuminated</div>
        </div>
      </div>

      <p className="mt-3 text-xs text-gray-500">
        Wellbeing/entertainment. The Moon sign and phase are calculated for the selected date/time.
      </p>
    </div>
  );
}

```


## File: src\components\PeopleList.tsx

```tsx
'use client';
import useSWR from 'swr';
import Link from 'next/link';

const fetcher = (url: string) => fetch(url).then(r => r.json());

type Item = { id: string; label: string; birth_date: string; birth_place_name?: string | null };

export default function PeopleList() {
  const { data } = useSWR('/api/people', fetcher);
  const items: Item[] = data?.items || [];

  return (
    <div className="space-y-2">
      {items.length === 0 ? (
        <div className="text-sm text-gray-600">Nessuna persona salvata.</div>
      ) : (
        <ul className="space-y-1">
          {items.map(p => (
            <li key={p.id}>
              <Link
                href={`/dashboard/people/${p.id}`}
                className="flex items-center justify-between rounded border p-2 hover:bg-gray-50"
              >
                <div>
                  <div className="font-medium">{p.label}</div>
                  <div className="text-xs text-gray-500">
                    {p.birth_date}{p.birth_place_name ? ` • ${p.birth_place_name}` : ''}
                  </div>
                </div>
                <span className="text-gray-400">→</span>
              </Link>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

```


## File: src\components\PeoplePanel.tsx

```tsx
// src/components/PeoplePanel.tsx
'use client';

import { useMemo, useState } from 'react';
import dynamic from 'next/dynamic';
import { assignHouses } from '@/lib/houses/placidus';
import { computePlanetsAtUTC, type RuntimePoint } from '@/lib/planets/runtime';

type HouseSystem = 'placidus' | 'whole';

type NatalPoint = { name: string; longitude: number; sign?: string };

type Props = {
  system: HouseSystem;
  natalCusps: number[];     // cuspidi NATALI dell'utente
  natalAsc?: number | null;
  natalMc?: number | null;
  natalPoints: NatalPoint[]; // punti NATALI dell'utente (per aspetti)
};

type ChartPoint = {
  name: string;
  longitude: number;
  sign: string;
  house: number | null;
  retro?: boolean | null;
};

const ChartWheel = dynamic<{
  points: ChartPoint[];
  houseCusps?: number[];
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';
  showHouseNumbers?: boolean;
  showZodiacRing?: boolean;
  size?: number;
  className?: string;
}>(() => import('@/components/ChartWheel'), { ssr: false });

function normDeg(x: number): number { return ((x % 360) + 360) % 360; }
function sepDeg(a: number, b: number): number {
  let d = Math.abs(normDeg(a) - normDeg(b));
  if (d > 180) d = 360 - d;
  return d;
}

type AspectDef = { name: string; angle: number; orb: number; weight: number };
const ASPECTS: AspectDef[] = [
  { name: 'Conjunction', angle: 0,   orb: 6, weight: 5 },
  { name: 'Opposition',  angle: 180, orb: 6, weight: 4 },
  { name: 'Square',      angle: 90,  orb: 5, weight: 4 },
  { name: 'Trine',       angle: 120, orb: 4, weight: 3 },
  { name: 'Sextile',     angle: 60,  orb: 3, weight: 2 },
];

function bestAspect(aLon: number, bLon: number) {
  const s = sepDeg(aLon, bLon);
  let best: { aspect: AspectDef; orb: number; score: number } | null = null;
  for (const a of ASPECTS) {
    const orb = Math.abs(s - a.angle);
    if (orb <= a.orb) {
      const score = a.weight * (1 - orb / a.orb);
      if (!best || score > best.score) best = { aspect: a, orb, score };
    }
  }
  return best;
}

function makeUTC(dateISO: string, timeHHmm: string, tzOffsetMin: number): Date {
  // Data/ora locali (della persona B) → UTC
  // Interpretiamo timeHHmm come HH:mm locali nel fuso indicato da tzOffsetMin.
  const [yyyy, mm, dd] = dateISO.split('-').map(Number);
  const [HH, MM] = timeHHmm.split(':').map(Number);
  const millisLocal = Date.UTC(yyyy, (mm - 1), dd, HH, MM, 0);
  const millisUTC = millisLocal - tzOffsetMin * 60_000;
  return new Date(millisUTC);
}

export default function PeoplePanel({
  system,
  natalCusps,
  //natalAsc,
  natalMc,
  natalPoints,
}: Props) {
  // Form “altra persona”
  const today = new Date();
  const defDateISO = today.toISOString().slice(0, 10);
  const [dateISO, setDateISO] = useState<string>(defDateISO);
  const [timeHHmm, setTimeHHmm] = useState<string>('12:00');
  const [tzOffsetMin, setTzOffsetMin] = useState<number>(0);

  const dateUTC = useMemo(() => makeUTC(dateISO, timeHHmm, tzOffsetMin), [dateISO, timeHHmm, tzOffsetMin]);

  // Pianeti della persona B alla data/ora inserite
  const otherPlanets: RuntimePoint[] = useMemo(
    () => computePlanetsAtUTC(dateUTC),
    [dateUTC]
  );

  // Proiezione sulle case NATALI dell'utente
  const pointsForWheel: ChartPoint[] = useMemo(
    () =>
      otherPlanets.map((p) => ({
        name: p.name,
        longitude: p.longitude,
        sign: p.sign,
        house: assignHouses(p.longitude, natalCusps),
        retro: false, // niente ℞
      })),
    [otherPlanets, natalCusps]
  );

  // Top 3 sinastria (altra persona -> aspetti ai punti natali dell'utente)
  const top3 = useMemo(() => {
    type Hit = { score: number; orb: number; aspect: string; other: string; user: string };
    const hits: Hit[] = [];
    for (const op of otherPlanets) {
      for (const np of natalPoints) {
        const match = bestAspect(op.longitude, np.longitude);
        if (match) {
          hits.push({
            score: Number(match.score.toFixed(3)),
            orb: Number(match.orb.toFixed(2)),
            aspect: match.aspect.name,
            other: op.name,
            user: np.name,
          });
        }
      }
    }
    return hits.sort((a, b) => b.score - a.score).slice(0, 3);
  }, [otherPlanets, natalPoints]);

  return (
    <div className="space-y-4">
      {/* 1) Form dati altra persona */}
      <div className="rounded-2xl border p-4">
        <h3 className="font-semibold mb-3">Dati altra persona</h3>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
          <div className="col-span-2 md:col-span-1">
            <label className="block text-sm font-medium mb-1">Data</label>
            <input
              type="date"
              value={dateISO}
              onChange={(e) => setDateISO(e.target.value)}
              className="border rounded-md px-3 py-2 text-sm w-full"
            />
          </div>
          <div className="col-span-2 md:col-span-1">
            <label className="block text-sm font-medium mb-1">Ora (HH:mm)</label>
            <input
              type="time"
              value={timeHHmm}
              onChange={(e) => setTimeHHmm(e.target.value)}
              className="border rounded-md px-3 py-2 text-sm w-full"
            />
          </div>
          <div className="col-span-2 md:col-span-1">
            <label className="block text-sm font-medium mb-1">Offset (minuti)</label>
            <input
              type="number"
              value={tzOffsetMin}
              onChange={(e) => setTzOffsetMin(parseInt(e.target.value || '0', 10))}
              className="border rounded-md px-3 py-2 text-sm w-full"
              placeholder="es. 60 per CET"
            />
            <p className="text-xs text-gray-500 mt-1">
              Esempi: CET inverno = +60, CEST estate = +120, UTC = 0, New York = -300 (inverno)
            </p>
          </div>
          <div className="col-span-2 md:col-span-1 flex items-end">
            <div className="text-xs text-gray-600">
              <div><span className="font-medium">UTC:</span> {dateUTC.toISOString().replace('.000', '').replace('T', ' ')}</div>
            </div>
          </div>
        </div>
      </div>

      {/* 2) Ruota: pianeti dell’altra persona sulle case NATALI dell’utente */}
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="font-semibold">
            Sinastria — {system === 'placidus' ? 'Placidus' : 'Whole Sign'}
          </h3>
          <span className="text-xs text-gray-500">Case: tema natale del consultante</span>
        </div>
        <ChartWheel
          points={pointsForWheel}
          houseCusps={natalCusps}
          mcDeg={natalMc ?? natalCusps[9]}
          orientation="by-asc"
          showZodiacRing
          showHouseNumbers
          size={520}
        />
      </div>

      {/* 3) Top 3 interazioni */}
      <div className="rounded-2xl border p-4">
        <h3 className="font-semibold mb-2">Top 3 aspetti (altra persona → tuoi punti)</h3>
        {top3.length === 0 ? (
          <p className="text-sm text-gray-600">Nessun aspetto rilevante entro gli orbi standard.</p>
        ) : (
          <ul className="space-y-2 text-sm">
            {top3.map((h, i) => (
              <li key={i} className="flex items-center justify-between">
                <span>
                  <span className="font-medium">{h.other}</span> {h.aspect}{' '}
                  <span className="font-medium">{h.user}</span>
                  <span className="text-gray-500"> (orb {h.orb}°)</span>
                </span>
                <span className="text-xs px-2 py-0.5 rounded bg-gray-100">score {h.score}</span>
              </li>
            ))}
          </ul>
        )}
        <p className="mt-2 text-xs text-gray-500">
          Ranking: Conj 5, Opp/Sq 4, Tr 3, Sx 2 (decresce linearmente con l’orb).
        </p>
      </div>
    </div>
  );
}

```


## File: src\components\PersonForm.tsx

```tsx
'use client';
import React, { useState } from 'react';

type GeoApiItem = { name?: string; display_name?: string; lat: number; lon: number };
type GeoItem = { name: string; lat: number; lon: number };

function toGeoItem(r: GeoApiItem): GeoItem {
  return {
    name: r.name || r.display_name || 'loc',
    lat: Number(r.lat),
    lon: Number(r.lon),
  };
}

export default function PersonForm({ onCreated }: { onCreated?: (id: string) => void }) {
  const [label, setLabel] = useState('');
  const [date, setDate] = useState('');
  const [time, setTime] = useState('');
  const [place, setPlace] = useState('');
  const [lat, setLat] = useState<string>('');
  const [lon, setLon] = useState<string>('');
  const [searching, setSearching] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [results, setResults] = useState<GeoItem[]>([]);

  async function searchPlace() {
    if (!place.trim()) return;
    setSearching(true);
    try {
      const res = await fetch(`/api/geo/resolve?q=${encodeURIComponent(place)}&lang=it&limit=5`);
      const j: { items?: GeoApiItem[] } = await res.json();
      const items = Array.isArray(j?.items) ? j.items.map(toGeoItem) : [];
      setResults(items);
    } finally { setSearching(false); }
  }

  async function submit() {
    if (!label.trim() || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      alert('Inserisci etichetta e data (YYYY-MM-DD)');
      return;
    }
    setSubmitting(true);
    try {
      const res = await fetch('/api/people', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          label, date,
          time: time.trim() || null,
          place_name: place.trim() || null,
          lat: lat ? Number(lat) : null,
          lon: lon ? Number(lon) : null,
        }),
      });
      const j: { ok?: boolean; id?: string; error?: string } = await res.json();
      if (!res.ok || !j?.ok || !j.id) throw new Error(j?.error || 'Errore');
      // reset
      setLabel(''); setDate(''); setTime(''); setPlace(''); setLat(''); setLon(''); setResults([]);
      onCreated?.(j.id);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Errore';
      alert(message);
    } finally { setSubmitting(false); }
  }

  return (
    <div className="space-y-3">
      <div>
        <label className="block text-xs text-gray-500">Etichetta</label>
        <input className="w-full rounded border p-2" value={label}
               onChange={e=>setLabel(e.target.value)} placeholder="es. papà / collega 1 / amica 2" />
      </div>

      <div className="grid grid-cols-2 gap-3">
        <div>
          <label className="block text-xs text-gray-500">Data di nascita</label>
          <input type="date" className="w-full rounded border p-2" value={date}
                 onChange={e=>setDate(e.target.value)} />
        </div>
        <div>
          <label className="block text-xs text-gray-500">Ora (opzionale)</label>
          <input type="time" className="w-full rounded border p-2" value={time}
                 onChange={e=>setTime(e.target.value)} />
        </div>
      </div>

      <div>
        <label className="block text-xs text-gray-500">Luogo di nascita (facoltativo)</label>
        <div className="flex gap-2">
          <input className="flex-1 rounded border p-2" value={place}
                 onChange={e=>setPlace(e.target.value)} placeholder="città, paese" />
          <button type="button" className="rounded border px-3" onClick={searchPlace} disabled={searching}>
            {searching? '...' : 'Cerca'}
          </button>
        </div>
        {results.length>0 && (
          <div className="mt-2 space-y-1 text-sm">
            {results.map((r,i)=> (
              <button key={i}
                      className="block w-full text-left rounded border p-2 hover:bg-gray-50"
                      onClick={()=>{
                        setPlace(r.name);
                        setLat(String(r.lat));
                        setLon(String(r.lon));
                        setResults([]);
                      }}>
                {r.name} <span className="text-gray-500">({r.lat.toFixed(3)}, {r.lon.toFixed(3)})</span>
              </button>
            ))}
          </div>
        )}
      </div>

      <div className="grid grid-cols-2 gap-3">
        <div>
          <label className="block text-xs text-gray-500">Lat (facoltativa)</label>
          <input className="w-full rounded border p-2" value={lat} onChange={e=>setLat(e.target.value)} />
        </div>
        <div>
          <label className="block text-xs text-gray-500">Lon (facoltativa)</label>
          <input className="w-full rounded border p-2" value={lon} onChange={e=>setLon(e.target.value)} />
        </div>
      </div>

      <button type="button" className="rounded-lg border px-4 py-2" onClick={submit} disabled={submitting}>
        {submitting? 'Salvo…' : 'Aggiungi persona'}
      </button>
      <p className="text-xs text-gray-500">Se non inserisci il luogo, useremo la posizione attuale dell’utente per i calcoli “oggi”.</p>
    </div>
  );
}

```


## File: src\components\SignOutButton.tsx

```tsx
'use client';

export default function SignOutButton() {
  async function signOut() {
    await fetch('/api/auth/signout', { method: 'POST' });
    window.location.href = '/';
  }
  return (
    <button className="rounded border px-3 py-1 text-sm" onClick={signOut}>
      Sign out
    </button>
  );
}

```


## File: src\components\SkyWheel.tsx

```tsx
// src/components/SkyWheel.tsx
'use client';

import React from 'react';

export type SkyPoint = {
  name: string;        // Sun..Pluto, ASC, MC
  longitude: number;   // 0..360
  sign: string;
  house: number | null;
  retro: boolean;
};

const GLYPH: Record<string, string> = {
  Sun: '☉',
  Moon: '☾',
  Mercury: '☿',
  Venus: '♀',
  Mars: '♂',
  Jupiter: '♃',
  Saturn: '♄',
  Uranus: '♅',
  Neptune: '♆',
  Pluto: '♇',
  ASC: 'ASC',
  MC: 'MC',
};

const SIGNS = [
  'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
  'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
];

export default function SkyWheel({
  title,
  points,
}: {
  title: string;
  points: SkyPoint[];
}) {
  // dimensioni
  const size = 320;
  const r = size / 2;

  return (
    <div className="rounded-2xl border p-4 bg-white">
      <div className="mb-3 text-sm font-medium">{title}</div>
      <div
        className="relative mx-auto"
        style={{ width: size, height: size }}
        aria-label={title}
      >
        {/* cerchio esterno */}
        <div
          className="absolute inset-0 rounded-full border"
          aria-hidden="true"
        />
        {/* tacche segni (12) */}
        {Array.from({ length: 12 }).map((_, i) => {
          const angle = (i * 30) - 90; // 0° a destra → ruotiamo per avere 0° in alto
          return (
            <div
              key={i}
              className="absolute left-1/2 top-1/2 origin-left"
              style={{
                transform: `rotate(${angle}deg) translateX(${r - 12}px)`,
                width: 12,
                height: 2,
                background: '#e5e7eb',
              }}
              aria-hidden="true"
            />
          );
        })}
        {/* etichette segni */}
        {SIGNS.map((s, i) => {
          const angle = (i * 30) - 90;
          const rr = r - 28;
          return (
            <div
              key={s}
              className="absolute left-1/2 top-1/2 text-[10px] text-gray-600"
              style={{
                transform: `rotate(${angle}deg) translateX(${rr}px) rotate(${-angle}deg)`,
                transformOrigin: '0 0',
              }}
              aria-hidden="true"
            >
              {s}
            </div>
          );
        })}
        {/* pianeti/punti */}
        {points.map((p, idx) => {
          const a = p.longitude - 90; // portiamo 0° in alto
          const rr = r - 56;
          const label = GLYPH[p.name] ?? p.name;
          return (
            <div
              key={`${p.name}-${idx}`}
              className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-xs"
              style={{
                transform: `rotate(${a}deg) translate(${rr}px) rotate(${-a}deg)`,
              }}
              title={`${p.name} ${p.sign}${p.house ? ` · H${p.house}` : ''}${p.retro ? ' (R)' : ''}`}
            >
              <span className="inline-flex items-center gap-1 rounded-lg border px-2 py-0.5 bg-white">
                <span>{label}</span>
                <span className="text-[10px] text-gray-500">
                  {p.sign}{p.house ? `·${p.house}` : ''}{p.retro ? 'R' : ''}
                </span>
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
}

```


## File: src\components\TransitsPanel.tsx

```tsx
// src/components/TransitsPanel.tsx
'use client';

import { useMemo, useState } from 'react';
import dynamic from 'next/dynamic';
import { computeDailyPlanets, type RuntimePoint } from '@/lib/planets/runtime';
import { assignHouses } from '@/lib/houses/placidus';

type NatalPoint = { name: string; longitude: number; sign?: string };
type HouseSystem = 'placidus' | 'whole';

type Props = {
  system: HouseSystem;
  natalCusps: number[];     // 12 cuspidi in gradi 0..360
  natalAsc?: number | null; // opzionale
  natalMc?: number | null;  // opzionale
  natalPoints: NatalPoint[]; // posizioni natali per calcolo aspetti
};

type ChartPoint = {
  name: string;
  longitude: number;
  sign: string;
  house: number | null;
  retro?: boolean | null;
};

const ChartWheel = dynamic<{
  points: ChartPoint[];
  houseCusps?: number[];
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';
  showHouseNumbers?: boolean;
  showZodiacRing?: boolean;
  size?: number;
  className?: string;
}>(() => import('@/components/ChartWheel'), { ssr: false });

function normDeg(x: number): number { return ((x % 360) + 360) % 360; }
function sepDeg(a: number, b: number): number {
  // distanza angolare 0..180
  let d = Math.abs(normDeg(a) - normDeg(b));
  if (d > 180) d = 360 - d;
  return d;
}

type AspectDef = { name: string; angle: number; orb: number; weight: number };
const ASPECTS: AspectDef[] = [
  { name: 'Conjunction', angle: 0,   orb: 6, weight: 5 },
  { name: 'Opposition',  angle: 180, orb: 6, weight: 4 },
  { name: 'Square',      angle: 90,  orb: 5, weight: 4 },
  { name: 'Trine',       angle: 120, orb: 4, weight: 3 },
  { name: 'Sextile',     angle: 60,  orb: 3, weight: 2 },
];

function bestAspect(tLon: number, nLon: number) {
  const s = sepDeg(tLon, nLon);
  let best: { aspect: AspectDef; orb: number; score: number } | null = null;
  for (const a of ASPECTS) {
    const orb = Math.abs(s - a.angle);
    if (orb <= a.orb) {
      const score = a.weight * (1 - orb / a.orb); // 0..weight
      if (!best || score > best.score) best = { aspect: a, orb, score };
    }
  }
  return best;
}

export default function TransitsPanel({ system, natalCusps, natalMc, natalPoints }: Props) {
  // inizializzo il date picker all'oggi (UTC)
  const todayISO = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
  const [dateISO, setDateISO] = useState<string>(todayISO);

  const dateUTC = useMemo(() => new Date(`${dateISO}T00:00:00Z`), [dateISO]);

  // Pianeti in transito per la data selezionata
  const transitPlanets: RuntimePoint[] = useMemo(
    () => computeDailyPlanets(dateUTC),
    [dateUTC]
  );

  // Assegno la casa in base alle cuspidi NATALI selezionate
  const pointsForWheel: ChartPoint[] = useMemo(
    () =>
      transitPlanets.map(p => ({
        name: p.name,
        longitude: p.longitude,
        sign: p.sign,
        house: assignHouses(p.longitude, natalCusps),
        retro: false, // evito il simbolo ℞/Px nella ruota dei transiti
      })),
    [transitPlanets, natalCusps]
  );

  // “Top 3” transiti del giorno contro i punti natali
  const top3 = useMemo(() => {
    type Hit = { score: number; orb: number; aspect: string; tName: string; nName: string };
    const hits: Hit[] = [];
    for (const t of transitPlanets) {
      for (const n of natalPoints) {
        const match = bestAspect(t.longitude, n.longitude);
        if (match) {
          hits.push({
            score: Number(match.score.toFixed(3)),
            orb: Number(match.orb.toFixed(2)),
            aspect: match.aspect.name,
            tName: t.name,
            nName: n.name,
          });
        }
      }
    }
    return hits.sort((a, b) => b.score - a.score).slice(0, 3);
  }, [transitPlanets, natalPoints]);

  return (
    <div className="space-y-4">
      {/* 1) Date picker */}
      <div>
        <label className="block text-sm font-medium mb-1">Seleziona data</label>
        <input
          type="date"
          className="border rounded-md px-3 py-2 text-sm"
          value={dateISO}
          onChange={(e) => setDateISO(e.target.value)}
        />
      </div>

      {/* 2) Ruota: pianeti in transito sulle case natali */}
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="font-semibold">
            Transits — {system === 'placidus' ? 'Placidus' : 'Whole Sign'}
          </h3>
          <span className="text-xs text-gray-500">{dateISO} (UTC)</span>
        </div>

        <ChartWheel
          points={pointsForWheel}
          houseCusps={natalCusps}
          mcDeg={natalMc ?? natalCusps[9]}
          orientation="by-asc"
          showZodiacRing
          showHouseNumbers
          size={520}
        />
      </div>

      {/* 3) Top 3 transiti */}
      <div className="rounded-2xl border p-4">
        <h3 className="font-semibold mb-2">Top 3 transiti del giorno</h3>
        {top3.length === 0 ? (
          <p className="text-sm text-gray-600">Nessun aspetto rilevante entro gli orbi standard.</p>
        ) : (
          <ul className="space-y-2 text-sm">
            {top3.map((h, i) => (
              <li key={i} className="flex items-center justify-between">
                <span>
                  <span className="font-medium">{h.tName}</span> {h.aspect}{' '}
                  <span className="font-medium">{h.nName}</span>
                  <span className="text-gray-500"> (orb {h.orb}°)</span>
                </span>
                <span className="text-xs px-2 py-0.5 rounded bg-gray-100">score {h.score}</span>
              </li>
            ))}
          </ul>
        )}
        <p className="mt-2 text-xs text-gray-500">
          Ranking basato su pesi: Conj 5, Opp/Sq 4, Tr 3, Sx 2; ridotto linearmente con l’orb.
        </p>
      </div>
    </div>
  );
}

```


## File: src\components\TransitsToday.tsx

```tsx
// src/components/TransitsToday.tsx
import React from 'react';
import { headers, cookies } from 'next/headers';

type TransitItem = {
  date: string;
  t_planet: string;
  n_point: string;
  aspect: string;   // 'conjunction' | 'sextile' | ...
  orb: number;
  score: number;
};

function todayISO(): string {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}

function ymOfToday(): string {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  return `${yyyy}-${mm}`;
}

function symbolForAspect(a: string): string {
  switch (a) {
    case 'conjunction': return '☌';
    case 'sextile':     return '✶';
    case 'square':      return '□';
    case 'trine':       return '△';
    case 'opposition':  return '☍';
    default:            return a;
  }
}

export default async function TransitsToday() {
  const date = todayISO();
  const ym = ymOfToday();

  // Costruiamo un URL assoluto basandoci sugli header della richiesta
  const h = headers();
  const host = h.get('x-forwarded-host') ?? h.get('host') ?? 'localhost:3000';
  const proto = h.get('x-forwarded-proto') ?? 'http';
  const baseUrl = `${proto}://${host}`;

  const res = await fetch(`${baseUrl}/api/transits?date=${date}`, {
    cache: 'no-store',
    headers: { cookie: cookies().toString() }, // mantiene la sessione → niente 401
  });

  if (!res.ok) {
    return (
      <div className="space-y-3">
        <div className="text-sm text-red-700">Errore nel calcolo dei transiti ({res.status}).</div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi mese
        </a>
      </div>
    );
  }

  const data = (await res.json()) as { ok?: boolean; top?: TransitItem[]; error?: string };

  if (!data.ok || !data.top || data.top.length === 0) {
    return (
      <div className="space-y-3">
        <div className="text-sm text-gray-600">Nessun transito rilevante per oggi.</div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi mese
        </a>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <span className="text-sm text-gray-700">Stai vedendo i</span>
        <span className="text-xs rounded-full bg-gray-100 px-2 py-1 text-gray-700">Top 5</span>
      </div>

      <ul className="space-y-3">
        {data.top.map((t, idx) => (
          <li key={`${t.t_planet}-${t.n_point}-${idx}`} className="rounded-xl border p-3">
            <div className="flex items-center justify-between">
              <div className="font-medium">
                {t.t_planet} {symbolForAspect(t.aspect)} {t.n_point}
              </div>
              <div className="text-xs text-gray-500">
                orb {t.orb.toFixed(1)}° • score {Math.round(t.score)}
              </div>
            </div>
            <div className="text-xs text-gray-600">Date: {t.date}</div>
          </li>
        ))}
      </ul>

      <div>
        <a
          href={`/dashboard/transits/month?ym=${ym}`}
          className="inline-block rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
        >
          Vedi tutti i transiti del mese
        </a>
      </div>
    </div>
  );
}

```


## File: src\lib\astro.ts

```ts
// src/lib/astro.ts
import { DateTime } from 'luxon';
import * as Astronomy from 'astronomy-engine';

export type BodyName =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';

export type AngleName = 'ASC' | 'MC';
export type PointName = BodyName | AngleName;

export type Point = {
  name: PointName;
  longitude: number;       // 0..360 eclittica geocentrica
  sign: string;            // Aries..Pisces
  house: number | null;    // 1..12 se noto, altrimenti null
  retro: boolean;          // pianeti; ASC/MC=false
};

export type AspectType =
  | 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

export type NatalAspect = {
  p1: PointName;
  p2: PointName;
  aspect: AspectType;
  orb: number;        // scarto dall’esatto in °
  strength: number;   // 0..100 circa
};

const OBLIQUITY = (23.4392911 * Math.PI) / 180; // rad, J2000 (ok per MVP)

const SIGN_NAMES = [
  'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
  'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
] as const;

export function normalizeDeg(x: number): number {
  let d = x % 360;
  if (d < 0) d += 360;
  return d;
}

function rad(d: number): number { return (d * Math.PI) / 180; }
function deg(r: number): number { return (r * 180) / Math.PI; }

export function signFromLongitude(lon: number): string {
  const i = Math.floor(normalizeDeg(lon) / 30) % 12;
  return SIGN_NAMES[i];
}

function eclipticFromEquatorial(eq: Astronomy.EquatorialCoordinates): { elon: number; elat: number } {
  // conversione esplicita (oppure si può usare Astronomy.Ecliptic(eq))
  const ra = eq.ra * 15; // ore → gradi
  const dec = eq.dec;    // gradi
  const raRad = rad(ra);
  const decRad = rad(dec);
  const sinE = Math.sin(OBLIQUITY);
  const cosE = Math.cos(OBLIQUITY);
  const sinDec = Math.sin(decRad);
  const cosDec = Math.cos(decRad);
  const sinRa = Math.sin(raRad);
  const cosRa = Math.cos(raRad);
  const elat = Math.asin(sinDec * cosE - cosDec * sinE * sinRa);
  const y = sinRa * cosE + Math.tan(decRad) * sinE;
  const x = cosRa;
  const elon = Math.atan2(y, x);
  return { elon: normalizeDeg(deg(elon)), elat: deg(elat) };
}

/**
 * Longitudine eclittica geocentrica “of date” senza passare un Observer:
 * usiamo GeoVector (geocentrico) → EquatorFromVector → conversione a eclittiche.
 */
function geocentricEclipticLongitude(body: Astronomy.Body, date: Date): number {
  // true = ofDate vector (correzioni appropriate per l’epoca)
  const vec = Astronomy.GeoVector(body, date, true);
  const eq = Astronomy.EquatorFromVector(vec); // RA/Dec
  const ecl = eclipticFromEquatorial(eq);
  return ecl.elon;
}

function isRetrograde(body: Astronomy.Body, date: Date): boolean {
  const prev = new Date(date.getTime() - 24 * 3600 * 1000);
  const lonNow = geocentricEclipticLongitude(body, date);
  const lonPrev = geocentricEclipticLongitude(body, prev);
  let diff = normalizeDeg(lonNow - lonPrev);
  if (diff > 180) diff -= 360; // -180..+180
  return diff < 0;
}

function localSiderealAngle(date: Date, lonDeg: number): number {
  const gstHours = Astronomy.SiderealTime(date); // ore
  return rad(normalizeDeg(gstHours * 15 + lonDeg)); // rad
}

function ascendantLongitude(date: Date, latDeg: number, lonDeg: number): number {
  const phi = rad(latDeg);
  const sinPhi = Math.sin(phi);
  const cosPhi = Math.cos(phi);
  const theta = localSiderealAngle(date, lonDeg);

  let bestLam = 0;
  let bestScore = 1e12;

  // Più fine ⇒ più preciso sul SEGNO (0.1° ok per MVP)
  const step = 0.1;

  for (let lam = 0; lam < 360; lam += step) {
    const l = rad(lam);

    // β=0 → RA/Dec sull'eclittica
    const sinLam = Math.sin(l);
    const cosLam = Math.cos(l);
    const sinDec = Math.sin(OBLIQUITY) * sinLam;
    const dec = Math.asin(sinDec);
    const ra = Math.atan2(sinLam * Math.cos(OBLIQUITY), cosLam);

    // Angolo orario
    let H = theta - ra;
    H = Math.atan2(Math.sin(H), Math.cos(H)); // normalizza -π..π

    // Alt/Az (convenz. astronomica: 0°=Sud, 90°=Ovest, 180°=Nord, 270°=Est)
    const alt = Math.asin(sinPhi * Math.sin(dec) + cosPhi * Math.cos(dec) * Math.cos(H));
    const az = Math.atan2(
      Math.sin(H),
      Math.cos(H) * sinPhi - Math.tan(dec) * Math.cos(phi)
    );
    const azDeg = normalizeDeg(deg(az));
    const absAlt = Math.abs(deg(alt));

    // Distanza angolare dall'Est (270°), considerando il wrap
    const distEast = Math.min(Math.abs(azDeg - 270), Math.abs(azDeg + 90)); // 270° ≡ -90°

    // Score: vogliamo alt≈0 (orizzonte) E vicino a Est (270°)
    const score = absAlt + 0.05 * distEast;

    if (score < bestScore) {
      bestScore = score;
      bestLam = lam;
    }
  }

  return bestLam; // è già l'Ascendente (scelto a Est)
}


function midheavenLongitude(date: Date, lonDeg: number): number {
  const theta = localSiderealAngle(date, lonDeg);
  const num = Math.sin(theta);
  const den = Math.cos(OBLIQUITY) * Math.cos(theta);
  const lam = Math.atan2(num, den);
  return normalizeDeg(deg(lam));
}

export function computePoints(
  tzName: string | null,
  dateISO: string,            // YYYY-MM-DD
  timeHHMM: string | null,    // HH:MM locale (null => 12:00)
  lat: number | null,
  lon: number | null
): { points: Point[]; houses: boolean; timestampUTC: Date } {
  const localTime = timeHHMM ?? '12:00';
  const dtLocal = DateTime.fromISO(`${dateISO}T${localTime}`, { zone: tzName ?? 'UTC' });
  const dtUtc = dtLocal.toUTC();
  const when = dtUtc.toJSDate();

  const bodies: { name: BodyName; body: Astronomy.Body }[] = [
    { name: 'Sun', body: Astronomy.Body.Sun },
    { name: 'Moon', body: Astronomy.Body.Moon },
    { name: 'Mercury', body: Astronomy.Body.Mercury },
    { name: 'Venus', body: Astronomy.Body.Venus },
    { name: 'Mars', body: Astronomy.Body.Mars },
    { name: 'Jupiter', body: Astronomy.Body.Jupiter },
    { name: 'Saturn', body: Astronomy.Body.Saturn },
    { name: 'Uranus', body: Astronomy.Body.Uranus },
    { name: 'Neptune', body: Astronomy.Body.Neptune },
    { name: 'Pluto', body: Astronomy.Body.Pluto }
  ];

  const planetPoints: Point[] = bodies.map(({ name, body }) => {
    const lonEcl = geocentricEclipticLongitude(body, when);
    const retro = isRetrograde(body, when);
    return {
      name,
      longitude: lonEcl,
      sign: signFromLongitude(lonEcl),
      house: null,
      retro
    };
  });

  let asc: Point | null = null;
  let mc: Point | null = null;
  let haveHouses = false;

  if (timeHHMM && lat != null && lon != null) {
    const λasc = ascendantLongitude(when, lat, lon);
    const λmc  = midheavenLongitude(when, lon);
    const ascSign = signFromLongitude(λasc);

    asc = { name: 'ASC', longitude: λasc, sign: ascSign, house: 1, retro: false };
    mc  = { name: 'MC',  longitude: λmc,  sign: signFromLongitude(λmc), house: null, retro: false };

    const ascIndex = Math.floor(normalizeDeg(λasc) / 30);
    for (const p of planetPoints) {
      const pIndex = Math.floor(normalizeDeg(p.longitude) / 30);
      const diff = (pIndex - ascIndex + 12) % 12;
      p.house = diff + 1;
    }
    haveHouses = true;
  }

  const allPoints = asc && mc ? [...planetPoints, asc, mc] : planetPoints;
  return { points: allPoints, houses: haveHouses, timestampUTC: when };
}

// ──────────────────────────────── Aspetti ────────────────────────────────────

const ASPECT_DEGREES: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

function minAngle(a: number, b: number): number {
  let d = Math.abs(normalizeDeg(a - b));
  if (d > 180) d = 360 - d;
  return d;
}

function classOfPoint(name: PointName): 'lum' | 'pers' | 'soc' | 'out' | 'ang' {
  if (name === 'Sun' || name === 'Moon') return 'lum';
  if (name === 'Mercury' || name === 'Venus' || name === 'Mars') return 'pers';
  if (name === 'Jupiter' || name === 'Saturn') return 'soc';
  if (name === 'Uranus' || name === 'Neptune' || name === 'Pluto') return 'out';
  return 'ang';
}

function orbMax(p1: PointName, p2: PointName): number {
  const c1 = classOfPoint(p1);
  const c2 = classOfPoint(p2);
  if (c1 === 'lum' || c2 === 'lum') return 6;
  if (c1 === 'pers' || c2 === 'pers' || c1 === 'ang' || c2 === 'ang') return 5;
  return 3;
}

function aspectWeight(a: AspectType): number {
  switch (a) {
    case 'conjunction': return 1.00;
    case 'opposition':  return 0.95;
    case 'trine':       return 0.90;
    case 'square':      return 0.85;
    case 'sextile':     return 0.75;
  }
}

function pointWeight(p: PointName): number {
  switch (classOfPoint(p)) {
    case 'lum': return 1.00;
    case 'ang': return 0.95;
    case 'pers': return 0.90;
    case 'soc': return 0.80;
    case 'out': return 0.70;
  }
}

export function computeNatalAspects(points: Point[]): NatalAspect[] {
  const res: NatalAspect[] = [];
  const targets: AspectType[] = ['conjunction', 'sextile', 'square', 'trine', 'opposition'];

  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      const A = points[i];
      const B = points[j];
      const d = minAngle(A.longitude, B.longitude);

      let best: { type: AspectType; diff: number } | null = null;
      for (const t of targets) {
        const target = ASPECT_DEGREES[t];
        const diff = Math.abs(d - target);
        if (best === null || diff < best.diff) best = { type: t, diff };
      }
      if (!best) continue;

      const maxOrb = orbMax(A.name, B.name);
      if (best.diff <= maxOrb) {
        const aw = aspectWeight(best.type);
        const pw = pointWeight(A.name) * pointWeight(B.name);
        const tightness = 1 - best.diff / maxOrb;
        const strength = Math.round(100 * aw * pw * (0.6 + 0.4 * tightness));
        res.push({
          p1: A.name,
          p2: B.name,
          aspect: best.type,
          orb: parseFloat(best.diff.toFixed(2)),
          strength
        });
      }
    }
  }
  return res;
}

// ──────────────────────────────── House systems factory ──────────────────────
import { computePlacidusCusps, assignHouses as assignHousesPlacidus } from '@/lib/houses/placidus';
import { computeWholeCuspsFromAsc } from '@/lib/houses/whole';
import { normalizeAngle as _norm } from '@/lib/houses/common';

export type HouseSystem = 'whole' | 'placidus';

/**
 * Calcola cuspidi/ASC/MC per il sistema scelto (Whole o Placidus).
 * Inputs:
 * - jd: Julian Day UT
 * - latDeg/lonDeg: coordinate geografiche (E+, W-)
 * - tzMinutes: non usato per il calcolo (coerenza firma)
 */
export function computeHouses(
  system: HouseSystem,
  args: { jd: number; latDeg: number; lonDeg: number; tzMinutes: number }
):
  | { system: 'whole'; cusps: number[]; asc: number; mc: number; fallbackApplied?: boolean }
  | { system: 'placidus'; cusps: number[]; asc: number; mc: number; fallbackApplied?: boolean } {
  const { jd, latDeg, lonDeg } = args;

  // Per ASC/MC “whole” possiamo riutilizzare le funzioni esistenti basate su Date;
  // ricostruiamo Date UTC da JD per coerenza con il resto del file.
  const when = new Date((jd - 2440587.5) * 86400000);

  if (system === 'placidus') {
    // Placidus calcola già ASC/MC e le 12 cuspidi
    return computePlacidusCusps(jd, latDeg, lonDeg);
  }

  // WHOLE SIGN:
  const ascDeg = ascendantLongitude(when, latDeg, lonDeg);
  const mcDeg = midheavenLongitude(when, lonDeg);
  return computeWholeCuspsFromAsc(ascDeg, mcDeg);
}

/**
 * Assegna il numero di casa (1..12) ad un punto dato un set di cuspidi.
 * Attenzione: per Placidus usiamo la funzione robusta del modulo Placidus (wrap-safe).
 * Per Whole, le cuspidi sono equispaziate; la regola è identica.
 */
export function assignHousesGeneric(longitudeDeg: number, cusps: number[]): number {
  return assignHousesPlacidus(_norm(longitudeDeg), cusps);
}


```
