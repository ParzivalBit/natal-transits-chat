# Repository Knowledge Base (chunk 0004)


## File: src\app\dashboard\people\page.tsx

```tsx
// src/app/dashboard/people/page.tsx
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import dynamicImport from 'next/dynamic';
import { redirect } from 'next/navigation';
import { computeHouses } from '@/lib/astro';

export const dynamic = 'force-dynamic';

type HouseSystem = 'placidus' | 'whole';

type NatalPoint = { name: string; longitude: number; sign?: string };
type ChartPointRow = { name: string; longitude: number; sign: string | null };

const ChatUI = dynamicImport(() => import('@/components/ChatUI'), { ssr: false });
const PeoplePanel = dynamicImport(() => import('@/components/PeoplePanel'), { ssr: false });
const HouseSystemSwitcher = dynamicImport(() => import('@/components/HouseSystemSwitcher'), { ssr: false });


type CuspsPacket = {
  system: HouseSystem;
  cusps: number[];     // 12 longitudes 0..360
  asc: number;         // cusps[0]
  mc: number;          // cusps[9]
  note?: string | null;
};

function has12(arr: unknown[] | null | undefined): arr is number[] {
  return !!arr && arr.length === 12 && arr.every(v => Number.isFinite(Number(v)));
}

export default async function Page() {
  const supabase = createSupabaseServerComponentClient();

  // --- auth robusto: ricaviamo userId e facciamo redirect se manca
  const auth = await supabase.auth.getUser();
  const userId = auth.data.user?.id ?? null;
  if (!userId) redirect('/onboarding');

  // 1) Sistema preferito (default whole se mancante)
  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', userId)
    .single();
  const preferred: HouseSystem = prefs?.house_system === 'placidus' ? 'placidus' : 'whole';

  // Helper: carica 12 cuspidi per un dato sistema (schema verticale: 12 righe cusp/longitude)
  async function loadCuspsFor(system: HouseSystem): Promise<number[] | null> {
    const { data, error } = await supabase
      .from('house_cusps')
      .select('cusp, longitude')
      .eq('user_id', userId)
      .eq('system', system)
      .order('cusp', { ascending: true });
    if (error) return null;
    if (!data || data.length !== 12) return null;
    const arr = data.map(r => Number(r.longitude));
    return has12(arr) ? arr : null;
  }

  // 2) Tenta preferito, poi qualsiasi sistema disponibile come fallback
  let usedSystem: HouseSystem | null = null;
  let cusps: number[] | null = await loadCuspsFor(preferred);
  let note: string | null = null;

  if (cusps) {
    usedSystem = preferred;
  } else {
    // fallback: prendi la prima serie disponibile dell'utente (qualsiasi system)
    const { data: anyRows } = await supabase
      .from('house_cusps')
      .select('system, cusp, longitude')
      .eq('user_id', userId)
      .order('system', { ascending: true })
      .order('cusp', { ascending: true });

    if (anyRows && anyRows.length >= 12) {
      // raggruppa per sistema e prendi il primo con 12 righe
      const bySystem = new Map<string, { cusp: number; longitude: number }[]>();
      for (const r of anyRows) {
        const s = String(r.system);
        const arr = bySystem.get(s) ?? [];
        arr.push({ cusp: Number(r.cusp), longitude: Number(r.longitude) });
        bySystem.set(s, arr);
      }
      for (const [sys, arr] of bySystem.entries()) {
        if (arr.length === 12) {
          arr.sort((a, b) => a.cusp - b.cusp);
          const lons = arr.map(x => x.longitude);
          if (has12(lons)) {
            usedSystem = (sys === 'placidus' ? 'placidus' : 'whole');
            cusps = lons;
            if (usedSystem !== preferred) {
              note = `Cuspidi trovate per il sistema "${usedSystem}". Preferenza corrente: "${preferred}".`;
            }
            break;
          }
        }
      }
    }
  }

  // 3) Se ancora nulla, calcolo runtime da birth_data (senza scrivere su DB)
  if (!cusps) {
    const { data: bd } = await supabase
      .from('birth_data')
      .select('datetime_utc, lat, lon, tz_offset_min')
      .eq('user_id', userId)
      .single();

    if (bd?.datetime_utc && bd.lat != null && bd.lon != null) {
      const dt = new Date(bd.datetime_utc as string);
      const jd = 2440587.5 + dt.getTime() / 86400000;
      const houses = computeHouses(preferred, {
        jd,
        latDeg: Number(bd.lat),
        lonDeg: Number(bd.lon),
        tzMinutes: Number(bd.tz_offset_min ?? 0),
      });
      cusps = houses.cusps;
      usedSystem = preferred;
      note = `Cuspidi calcolate runtime da birth_data (non trovate in house_cusps).`;
    }
  }

  // 4) Se proprio nulla, mostriamo CTA onboarding
  let packet: CuspsPacket | null = null;
  if (cusps && usedSystem) {
    packet = {
      system: usedSystem,
      cusps,
      asc: cusps[0],   // cusp 1 = ASC (eclittica)
      mc: cusps[9],    // cusp 10 = MC (eclittica)
      note,
    };
  }

  // Punti natali del consultante (per sinastria/overlay nel pannello)
  const { data: natalPointsRaw } = await supabase
    .from('chart_points')
    .select('name, longitude, sign')
    .eq('user_id', userId)
    .order('name', { ascending: true });

  const natalPoints: NatalPoint[] = Array.isArray(natalPointsRaw)
    ? (natalPointsRaw as ChartPointRow[]).map((p) => ({
        name: p.name,
        longitude: Number(p.longitude),
        sign: p.sign ?? undefined,
      }))
    : [];

  return (
    <div className="grid lg:grid-cols-2 gap-6">
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
        <h2 className="text-lg font-semibold">People / Sinastria</h2>
          <HouseSystemSwitcher current={packet?.system ?? 'whole'} />
        </div>
        {!packet ? (
          <div className="space-y-3">
            <h2 className="text-lg font-semibold">Completa i dati di nascita</h2>
            <p className="text-sm text-gray-600">
              Per usare la sinastria abbiamo bisogno del tuo tema natale (cuspidi delle case).
            </p>
            <a
              href="/onboarding"
              className="inline-block px-3 py-2 text-sm rounded-md bg-blue-600 text-white"
            >
              Vai a Onboarding
            </a>
          </div>
        ) : (
          <>
            {packet.note && (
              <div className="mb-3 rounded-md border border-amber-300 bg-amber-50 text-amber-800 text-xs px-3 py-2">
                {packet.note}
              </div>
            )}
            <div className="text-xs text-gray-500 mb-2">
              ASC natal: {packet.asc.toFixed(2)}° · MC natal: {packet.mc.toFixed(2)}° · Sistema: {packet.system}
            </div>
            <PeoplePanel
              system={packet.system}
              natalCusps={packet.cusps}
              natalAsc={packet.asc}
              natalMc={packet.mc}
              natalPoints={natalPoints}
            />
          </>
        )}
      </div>

      <div className="rounded-2xl border p-4 min-h-[480px]">
        <h2 className="text-lg font-semibold mb-3">Ask about compatibility</h2>
        <ChatUI />
      </div>
    </div>
  );
}

```


## File: src\app\dashboard\transits\month\page.tsx

```tsx
// src/app/dashboard/transits/month/page.tsx
import { headers, cookies } from 'next/headers';
import ChatUI from '@/components/ChatUI';
import MonthTransitsList from '@/components/MonthTransitsList';

type AspectKey = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

type TransitHit = {
  date: string;
  t_planet: string;
  n_point: string;
  aspect: AspectKey;
  orb: number;
  score: number;
};

type DayBucket = { date: string; items: TransitHit[] };

function buildMonthlyContext(ym: string, days: DayBucket[]): string {
  const lines: string[] = [];
  for (const d of days) {
    for (const t of d.items) {
      lines.push(
        `${d.date}: ${t.t_planet} ${t.aspect} ${t.n_point} (orb ${t.orb}°, score ${t.score})`
      );
    }
  }
  return `MONTH_TRANSITS ${ym}
${lines.join('\n')}

Guidelines:
- Contestualizza i transiti per lavoro/relazioni/energia in modo non-deterministico e pratico.
- Se l'utente cita una data (YYYY-MM-DD), filtra le righe di quel giorno e spiega 2–3 implicazioni utili.
- Evita assoluti; tono empatico. Ricorda il disclaimer benessere/entertainment.`;
}

export default async function TransitsMonthPage({
  searchParams,
}: {
  searchParams: { ym?: string; mode?: string; limit?: string };
}) {
  const ym = searchParams.ym ?? new Date().toISOString().slice(0, 7);
  const mode = (searchParams.mode ?? 'top') as 'top' | 'all';
  const limit = searchParams.limit ?? '5';

  const h = headers();
  const host = h.get('x-forwarded-host') ?? h.get('host') ?? 'localhost:3000';
  const proto = h.get('x-forwarded-proto') ?? 'http';
  const base = `${proto}://${host}`;

  const res = await fetch(`${base}/api/transits/month?ym=${ym}&mode=${mode}&limit=${limit}`, {
    cache: 'no-store',
    headers: { cookie: cookies().toString() },
  });

  if (!res.ok) {
    return (
      <div className="p-6">
        <div className="rounded-xl border p-4 text-sm text-red-700">
          Errore nel calcolo dei transiti mensili ({res.status}).
        </div>
      </div>
    );
  }

  const json = (await res.json()) as { ok?: boolean; days?: DayBucket[]; error?: string };
  if (!json.ok) {
    return (
      <div className="p-6">
        <div className="rounded-xl border p-4 text-sm text-red-700">
          {json.error ?? 'Errore sconosciuto.'}
        </div>
      </div>
    );
  }

  const days = json.days ?? [];
  const monthlyContext = buildMonthlyContext(ym, days);

  return (
    <div className="p-6">
      <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
        {/* Colonna sinistra (2/3): header + scroller */}
        <div className="xl:col-span-2 space-y-4">
          <header className="flex items-center justify-between">
            <h1 className="text-lg font-semibold">Transiti di {ym}</h1>
            <div className="flex items-center gap-2 text-sm">
              <a
                className={`rounded-lg border px-3 py-1 ${mode === 'top' ? 'bg-gray-900 text-white' : 'hover:bg-gray-50'}`}
                href={`/dashboard/transits/month?ym=${ym}&mode=top&limit=${limit}`}
              >
                Top {limit}
              </a>
              <a
                className={`rounded-lg border px-3 py-1 ${mode === 'all' ? 'bg-gray-900 text-white' : 'hover:bg-gray-50'}`}
                href={`/dashboard/transits/month?ym=${ym}&mode=all`}
              >
                Tutti
              </a>
            </div>
          </header>

          {days.length === 0 ? (
            <div className="rounded-xl border p-4 text-sm text-gray-600">
              Nessun transito rilevante in {ym}.
            </div>
          ) : (
            <MonthTransitsList ym={ym} days={days} />
          )}
        </div>

        {/* Colonna destra (1/3): Chat sticky, altezza fissa */}
        <div className="xl:col-span-1">
          <div className="sticky top-6 h-[75vh]">
            <ChatUI initialContext={monthlyContext} />
          </div>
        </div>
      </div>
    </div>
  );
}

```


## File: src\app\dashboard\transits\page.tsx

```tsx
// src/app/dashboard/transits/page.tsx
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import dynamicImport from 'next/dynamic';
import { redirect } from 'next/navigation';

export const dynamic = 'force-dynamic';

type HouseSystem = 'placidus' | 'whole';

type ChartPoint = {
  name: string;
  longitude: number;
  sign?: string;
  house?: number | null;
  retro?: boolean;
};

type Props = {
  searchParams?: { [key: string]: string | string[] | undefined };
};

// Componenti client
const ChartWheel = dynamicImport<{
  points: ChartPoint[];
  houseCusps?: number[];
  mcDeg?: number;
  orientation?: 'by-asc' | 'by-mc';
  showHouseNumbers?: boolean;
  showZodiacRing?: boolean;
  size?: number;
  className?: string;
}>(() => import('@/components/ChartWheel'), { ssr: false });

const ChatUI = dynamicImport(() => import('@/components/ChatUI'), { ssr: false });
const HouseSystemSwitcher = dynamicImport(() => import('@/components/HouseSystemSwitcher'), { ssr: false });

// Pianeti di transito (runtime) — usa la tua API
import { computePlanetsAtUTC, type RuntimePoint } from '@/lib/planets/runtime';

// ----------------- util locali

function has12(arr: unknown[] | null | undefined): arr is number[] {
  return !!arr && arr.length === 12 && arr.every(v => Number.isFinite(Number(v)));
}

function zodiacSignFromLon(lon: number): string {
  const signs = ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'];
  const idx = Math.floor((((lon % 360) + 360) % 360) / 30);
  return signs[idx];
}

// aspetto (maggiore) più vicino e distanza in gradi
function nearestMajorAspectDelta(d: number): { aspect: number | null; delta: number } {
  const majors = [0, 60, 90, 120, 180];
  let best: number | null = null;
  let min = 999;
  for (const a of majors) {
    const diff = Math.abs(((d - a + 540) % 360) - 180);
    if (diff < min) { min = diff; best = a; }
  }
  return { aspect: best, delta: min };
}

// punteggio semplice: più è stretto l’orbe, più alto
function scoreAspect(planet: string, aspect: number | null, orb: number): number {
  if (aspect === null) return 0;
  const baseOrb =
    planet === 'Sun' || planet === 'Moon' ? 6 :
    planet === 'Mercury' || planet === 'Venus' ? 4 :
    planet === 'Mars' ? 4 :
    3.5;
  const maxOrb =
    aspect === 0 ? baseOrb + 1.0 :
    aspect === 180 ? baseOrb + 0.5 :
    baseOrb;
  const v = Math.max(0, maxOrb - orb);
  const w =
    aspect === 0 ? 1.05 :
    aspect === 180 ? 1.02 :
    aspect === 120 ? 1.00 :
    aspect === 90 ? 0.98 :
    aspect === 60 ? 0.95 : 0.9;
  return v * w;
}

export default async function Page({ searchParams }: Props) {
  const supabase = createSupabaseServerComponentClient();
  const auth = await supabase.auth.getUser();
  const userId = auth.data.user?.id ?? null;
  if (!userId) redirect('/onboarding');

  // 1) Data selezionata (default: oggi UTC)
  const dParam = typeof searchParams?.d === 'string' ? searchParams!.d : undefined;
  const today = new Date();
  const yyyy = today.getUTCFullYear();
  const mm = String(today.getUTCMonth() + 1).padStart(2, '0');
  const dd = String(today.getUTCDate()).padStart(2, '0');
  const dateUTC = dParam ?? `${yyyy}-${mm}-${dd}`;            // "YYYY-MM-DD"
  const dateObjUTC = new Date(`${dateUTC}T00:00:00Z`);        // mezzanotte UTC

  // 2) Sistema case preferito
  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', userId)
    .maybeSingle();

  const system: HouseSystem = prefs?.house_system === 'placidus' ? 'placidus' : 'whole';

  // 3) Cuspidi natalizie (schema verticale)
  const { data: cuspsRows } = await supabase
    .from('house_cusps')
    .select('cusp, longitude')
    .eq('user_id', userId)
    .eq('system', system)
    .order('cusp', { ascending: true });

  const houseCusps = Array.isArray(cuspsRows) && cuspsRows.length === 12
    ? cuspsRows.map(r => Number(r.longitude))
    : undefined;

  const mcDeg = has12(houseCusps) ? houseCusps[9] : undefined;

  // 4) Punti natali (per aspetto con transiti)
  const { data: natalRows } = await supabase
    .from('chart_points')
    .select('name, longitude')
    .eq('user_id', userId)
    .order('name', { ascending: true });

  const natalPoints: ChartPoint[] = Array.isArray(natalRows)
    ? natalRows.map(r => ({ name: r.name, longitude: Number(r.longitude) }))
    : [];

  // 5) Pianeti di transito (runtime) per la data selezionata
  const transitRaw: RuntimePoint[] = computePlanetsAtUTC(dateObjUTC);
  const transitPoints: ChartPoint[] = transitRaw.map((p) => ({
    name: p.name,
    longitude: Number(p.longitude),
    retro: !!p.retro,
    sign: zodiacSignFromLon(Number(p.longitude)),
    house: null,
  }));

  // 6) Top 3 transiti del giorno
  type TransitHit = { planet: string; target: string; aspect: number; orb: number; score: number };
  const hits: TransitHit[] = [];
  for (const tp of transitPoints) {
    for (const np of natalPoints) {
      const d = Math.abs(((tp.longitude - np.longitude + 540) % 360) - 180);
      const { aspect, delta } = nearestMajorAspectDelta(d);
      const score = scoreAspect(String(tp.name), aspect, delta);
      if (score > 0.5 && aspect !== null) {
        hits.push({
          planet: String(tp.name),
          target: String(np.name),
          aspect,
          orb: Number(delta),
          score,
        });
      }
    }
  }
  hits.sort((a, b) => b.score - a.score);
  const top3 = hits.slice(0, 3);

  return (
    <div className="grid lg:grid-cols-2 gap-6">
      {/* Colonna sinistra */}
      <div className="rounded-2xl border p-4">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-semibold">Transits</h2>
          <HouseSystemSwitcher current={system} />
        </div>

        {/* Date picker */}
        <form className="mb-4" action="/dashboard/transits" method="get">
          <label className="text-xs text-gray-600 mr-2">Date (UTC):</label>
          <input
            type="date"
            name="d"
            defaultValue={dateUTC}
            className="border rounded-md px-2 py-1 text-sm"
          />
          <button
            type="submit"
            className="ml-2 px-3 py-1 text-sm rounded-md border bg-white hover:bg-gray-50"
          >
            Go
          </button>
        </form>

        {/* Ruota: transiti + case natalizie utente */}
        <div className="mb-4">
          <ChartWheel
            key={`${system}-${(houseCusps?.[0] ?? 0).toFixed(3)}-${dateUTC}`}
            points={transitPoints}
            houseCusps={houseCusps}
            mcDeg={mcDeg}
            orientation="by-asc"
            showZodiacRing
            showHouseNumbers
            size={460}
          />
        </div>

        {/* Top 3 transiti */}
        <div>
          <h3 className="text-sm font-semibold mb-2">Top transits for {dateUTC}</h3>
          {top3.length === 0 ? (
            <p className="text-sm text-gray-600">Nessun aspetto rilevante nei range di orb impostati.</p>
          ) : (
            <ul className="text-sm space-y-1">
              {top3.map((t, i) => (
                <li key={i} className="flex items-center justify-between">
                  <span>
                    <span className="font-medium">{t.planet}</span>{' '}
                    {t.aspect === 0 && 'conj.'}
                    {t.aspect === 60 && 'sext.'}
                    {t.aspect === 90 && 'sq.'}
                    {t.aspect === 120 && 'trine'}
                    {t.aspect === 180 && 'opp.'}{' '}
                    <span className="font-medium">{t.target}</span>
                  </span>
                  <span className="text-xs text-gray-500">orb {t.orb.toFixed(2)}°</span>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>

      {/* Colonna destra: Chat */}
      <div className="rounded-2xl border p-4 min-h-[480px]">
        <h2 className="text-lg font-semibold mb-3">Ask about today</h2>
        <ChatUI />
      </div>
    </div>
  );
}

```


## File: src\app\globals.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;


html, body {
height: 100%;
}
```


## File: src\app\lab\daily-pro\action.ts

```ts
// FILE: src/app/lab/daily-pro/action.ts
"use server";

import { createSupabaseServerComponentClient } from "../../../lib/supabaseServer";
import type { DailyData } from "./loadData";

// Mappa dai codici interni (conj, sq, tri, opp, sext) ai valori DB
const DB_ASPECTS: Record<string, string> = {
  conj: "conjunction",
  sext: "sextile",
  sq: "square",
  tri: "trine",
  opp: "opposition",
};

export async function upsertTransitDay(
  payload: Pick<DailyData, "transitingAspects" | "dateISO">
) {
  const sb = createSupabaseServerComponentClient();

  const {
    data: { user },
    error: uerr,
  } = await sb.auth.getUser();
  if (uerr || !user) throw new Error("Not authenticated");

  // Cancella record già presenti per la data
  const del = await sb
    .from("transit_events")
    .delete()
    .eq("user_id", user.id)
    .eq("date", payload.dateISO);
  if (del.error) throw new Error(del.error.message);

  if (!payload.transitingAspects?.length) {
    return { ok: true, inserted: 0 };
  }

  const rows = payload.transitingAspects.map((a) => {
    const aspectKey = DB_ASPECTS[a.aspect] ?? "conjunction"; // fallback safe
    return {
      user_id: user.id,
      date: payload.dateISO,
      t_planet: a.t,
      n_point: a.n,
      aspect: aspectKey,
      orb: a.orb,
      score: Math.max(1, Math.round(100 - a.orb * 10)),
    };
  });

  const ins = await sb.from("transit_events").insert(rows);
  if (ins.error) throw new Error(ins.error.message);

  return { ok: true, inserted: rows.length };
}

```


## File: src\app\lab\daily-pro\ClientDailyPro.tsx

```tsx
// FILE: src/app/lab/daily-pro/ClientDailyPro.tsx
"use client";

import React, { useState } from "react";
import DailySkyWheelPro, {
  type ProPoint,
  type AspectType,
} from "@/components/astro/DailySkyWheelPro";

function Controls({
  enabledAspects,
  setEnabledAspects,
  orbOffsetDeg,
  setOrbOffsetDeg,
}: {
  enabledAspects: Record<AspectType, boolean>;
  setEnabledAspects: (val: Record<AspectType, boolean>) => void;
  orbOffsetDeg: number;
  setOrbOffsetDeg: (v: number) => void;
}) {
  const toggle = (k: AspectType) =>
    setEnabledAspects({ ...enabledAspects, [k]: !enabledAspects[k] });

  return (
    <div className="mb-4 grid gap-3 rounded-xl border border-gray-200 bg-white p-4 text-sm shadow-sm">
      <div className="font-medium text-gray-800">Impostazioni aspetti</div>

      <div className="grid grid-cols-2 gap-2 sm:grid-cols-5">
        {(["conjunction", "sextile", "square", "trine", "opposition"] as AspectType[]).map(
          (t) => (
            <label key={t} className="inline-flex items-center gap-2">
              <input
                type="checkbox"
                className="h-4 w-4 accent-gray-900"
                checked={enabledAspects[t]}
                onChange={() => toggle(t)}
              />
              <span className="capitalize">{t}</span>
            </label>
          )
        )}
      </div>

      <div className="mt-2">
        <label htmlFor="orb" className="mb-1 block text-gray-700">
          Orb globale (± gradi):{" "}
          <span className="font-semibold">
            {orbOffsetDeg >= 0 ? `+${orbOffsetDeg}` : orbOffsetDeg}°
          </span>
        </label>
        <input
          id="orb"
          type="range"
          min={-4}
          max={6}
          step={1}
          value={orbOffsetDeg}
          onChange={(e) => setOrbOffsetDeg(Number(e.target.value))}
          className="w-full"
        />
        <p className="mt-1 text-xs text-gray-500">
          Applica un offset agli orbi base (conj 8°, sext 4°, sq 6°, tr 6°, opp 8°).
        </p>
      </div>
    </div>
  );
}

export default function ClientDailyPro({ today }: { today: ProPoint[] }) {
  const [enabledAspects, setEnabledAspects] = useState<Record<AspectType, boolean>>({
    conjunction: true,
    sextile: true,
    square: true,
    trine: true,
    opposition: true,
  });
  const [orbOffsetDeg, setOrbOffsetDeg] = useState<number>(0);

  return (
    <div className="mx-auto max-w-5xl px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-2xl font-semibold tracking-tight">Daily Sky — Pro</h1>
        <p className="text-sm text-gray-500">
          Cielo del giorno: pianeti in transito e aspetti (toggle + orb come in transits-pro).
        </p>
      </div>

      {/* Controls */}
      <Controls
        enabledAspects={enabledAspects}
        setEnabledAspects={setEnabledAspects}
        orbOffsetDeg={orbOffsetDeg}
        setOrbOffsetDeg={setOrbOffsetDeg}
      />

      {/* Wheel */}
      <div className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
        <div className="aspect-square w-full max-w-[720px] mx-auto">
          <DailySkyWheelPro
            today={today}
            enabledAspects={enabledAspects}
            orbOffsetDeg={orbOffsetDeg}
            responsive
          />
        </div>
      </div>
    </div>
  );
}

```


## File: src\app\lab\daily-pro\loadData.ts

```ts
// FILE: src/app/lab/daily-pro/loadData.ts
import {
  ASPECTS,
  acuteDelta,
  closestAspectDelta,
  maxOrbForPair,
  PointName,
  Point,
} from "../../../lib/aspects";
import { createSupabaseServerComponentClient } from "../../../lib/supabaseServer";
import { computePlanetsAtUTC } from "../../../lib/planets/runtime";

export type HouseSystem = "whole" | "placidus";

export type DailyData = {
  houseSystem: HouseSystem;
  natalPoints: Point[];
  natalCusps: number[];
  todayPoints: Point[];
  todayCusps: number[];
  transitingAspects: Array<{
    t: PointName;
    n: PointName;
    aspect: keyof typeof ASPECTS;
    orb: number;
  }>;
  dateISO: string;
};

export async function loadDaily(): Promise<DailyData> {
  const sb = createSupabaseServerComponentClient();

  // Auth
  const {
    data: { user },
    error: uerr,
  } = await sb.auth.getUser();
  if (uerr || !user) throw new Error("Not authenticated");

  // Preferenze
  const { data: prefs, error: perr } = await sb
    .from("user_prefs")
    .select("house_system, current_lat, current_lon")
    .eq("user_id", user.id)
    .single();
  if (perr) throw new Error(perr.message);

  const houseSystem: HouseSystem = (prefs?.house_system as HouseSystem) || "whole";

  // Punti natali
  const { data: natalPoints, error: nperr } = await sb
    .from("chart_points")
    .select("name, longitude, retro")
    .eq("user_id", user.id);
  if (nperr) throw new Error(nperr.message);

  // Case natali
  const { data: cuspsRow } = await sb
    .from("house_cusps")
    .select("c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12")
    .eq("user_id", user.id)
    .eq("house_system", houseSystem)
    .maybeSingle();

  const natalCusps: number[] = cuspsRow
    ? [
        cuspsRow.c1,
        cuspsRow.c2,
        cuspsRow.c3,
        cuspsRow.c4,
        cuspsRow.c5,
        cuspsRow.c6,
        cuspsRow.c7,
        cuspsRow.c8,
        cuspsRow.c9,
        cuspsRow.c10,
        cuspsRow.c11,
        cuspsRow.c12,
      ]
    : [];

  // Data corrente
  const now = new Date();
  const dateISO = now.toISOString().slice(0, 10);

  // Pianeti runtime
  const todayPoints = computePlanetsAtUTC(now).map((p) => ({
    name: p.name,
    longitude: p.longitude,
    retro: p.retro,
  })) as Point[];

  // Fallback: todayCusps = natalCusps (fino a che non colleghiamo calcolo runtime case)
  const todayCusps = natalCusps;

  // Aspetti transiting → natal
  const aspectList: DailyData["transitingAspects"] = [];
  for (const t of todayPoints) {
    const tn = t.name as PointName;
    if (
      ![
        "Sun",
        "Moon",
        "Mercury",
        "Venus",
        "Mars",
        "Jupiter",
        "Saturn",
        "Uranus",
        "Neptune",
        "Pluto",
      ].includes(tn)
    )
      continue;

    for (const n of (natalPoints as unknown as Point[]) ?? []) {
      const nn = n.name as PointName;
      const delta = acuteDelta(t.longitude, n.longitude);
      const hit = closestAspectDelta(delta);
      const max = maxOrbForPair(tn, nn, hit.aspect.key);
      if (hit.orb <= max) {
        aspectList.push({
          t: tn,
          n: nn,
          aspect: hit.aspect.key,
          orb: +hit.orb.toFixed(2),
        });
      }
    }
  }

  return {
    houseSystem,
    natalPoints: (natalPoints as unknown as Point[]) ?? [],
    natalCusps,
    todayPoints,
    todayCusps,
    transitingAspects: aspectList,
    dateISO,
  };
}

```


## File: src\app\lab\daily-pro\page.tsx

```tsx
// FILE: src/app/lab/daily-pro/page.tsx
import { Suspense } from "react";
import ClientDailyPro from "./ClientDailyPro";
import { computeDailyPlanets } from "@/lib/planets/runtime";

// ---------------------------
// Tipi locali
// ---------------------------

type RuntimePlanet = {
  name: string;
  longitude: number;
  retro?: boolean;
  sign?: string | null;
};

export type ProPoint = {
  id: string;
  name: string;
  lon: number;
  retro?: boolean;
  sign?: string | null;
};

export const revalidate = 60;

// ---------------------------
// Data loader (server)
// ---------------------------

async function loadDailyData() {
  const nowUTC = new Date();
  const todayRaw: RuntimePlanet[] = await computeDailyPlanets(nowUTC);
  const today: ProPoint[] = todayRaw.map((p) => ({
    id: p.name,
    name: p.name,
    lon: p.longitude,
    retro: !!p.retro,
    sign: p.sign ?? null,
  }));
  return { today };
}

// ---------------------------
// Page (Server Component)
// ---------------------------

export default async function Page() {
  const { today } = await loadDailyData();
  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamento Daily Sky…</div>}>
      <ClientDailyPro today={today} />
    </Suspense>
  );
}

```


## File: src\app\lab\daily-pro\sbServer.ts

```ts

```


## File: src\app\lab\natal-pro\page.tsx

```tsx
// src/app/lab/natal-pro/page.tsx
import nextDynamic from 'next/dynamic';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import { redirect } from 'next/navigation';
import { computeHouses } from '@/lib/astro';

const ChartWheelPro = nextDynamic(() => import('@/components/astro/ChartWheelPro'), { ssr: false });

export const dynamic = 'force-dynamic';

type HouseSystem = 'placidus' | 'whole';
interface ChartPoint {
  name: string;
  longitude: number;
  sign: string;
  house: number | null;
  retro: boolean;
}

export default async function Page() {
  const supabase = createSupabaseServerComponentClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) redirect('/onboarding');

  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('house_system')
    .eq('user_id', user.id)
    .maybeSingle();

  const system: HouseSystem = prefs?.house_system === 'placidus' ? 'placidus' : 'whole';

  const { data: cuspsRows } = await supabase
    .from('house_cusps')
    .select('cusp, longitude')
    .eq('user_id', user.id)
    .eq('system', system)
    .order('cusp');

  let cusps: number[] | null =
    Array.isArray(cuspsRows) && cuspsRows.length === 12 ? cuspsRows.map(r => Number(r.longitude)) : null;

  //let mc: number | undefined;

  if (!cusps) {
    const { data: bd } = await supabase
      .from('birth_data')
      .select('date,time,tz_offset_minutes,lat,lon')
      .eq('user_id', user.id)
      .maybeSingle();

    if (bd?.date && bd.time && bd.lat != null && bd.lon != null) {
      const [hh, mm] = String(bd.time).slice(0, 5).split(':').map(Number);
      const local = new Date(`${bd.date}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00Z`);
      const tzOff = Number(bd.tz_offset_minutes ?? 0);
      const jdUT = local.getTime() / 86400000 + 2440587.5 - tzOff/1440;

      const pkt = computeHouses(system, {
        jd: jdUT,
        latDeg: Number(bd.lat),
        lonDeg: Number(bd.lon),
        tzMinutes: tzOff,
      });

      cusps = pkt.cusps;
      //mc = pkt.mc;
    }
  }

  const { data: pointsRaw } = await supabase
    .from('chart_points')
    .select('name,longitude,sign,house,retro')
    .eq('user_id', user.id)
    .order('name');

  const points: ChartPoint[] = Array.isArray(pointsRaw)
    ? pointsRaw.map((p: unknown) => {
        const obj = p as { name: string; longitude: number; sign: string | null; house: number | null; retro: boolean | null };
        return {
          name: String(obj.name),
          longitude: Number(obj.longitude),
          sign: String(obj.sign ?? ''),
          house: obj.house ?? null,
          retro: Boolean(obj.retro),
        };
      })
    : [];

  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">Lab · Natal Pro</h1>
      <ChartWheelPro
        title={`Natal (system: ${system})`}
        points={points}
        houseCusps={cusps ?? undefined}
      />
    </div>
  );
}

```


## File: src\app\lab\people-pro\[id]\ChatSynastryPane.tsx

```tsx
// FILE: src/app/lab/people/[id]/ChatSynastryPane.tsx
"use client";

import React, { useState } from "react";

export type SynastryContext = {
  user: {
    id: string;
    houseSystem: "placidus" | "whole";
    houses?: number[];
    points: { name: string; lon: number; retro?: boolean }[];
    axes?: { AC: number; IC: number; DC: number; MC: number };
  };
  person: {
    id: string;
    name?: string | null;
    houseSystem: "placidus" | "whole";
    houses?: number[];
    points: { name: string; lon: number; retro?: boolean }[];
    axes?: { AC: number; IC: number; DC: number; MC: number };
  };
  aspects: {
    a: { who: "user" | "person"; name: string; lon: number };
    b: { who: "user" | "person"; name: string; lon: number };
    type: "conjunction" | "sextile" | "square" | "trine" | "opposition";
    delta: number; exact: number; strength: number;
  }[];
};

export default function ChatSynastryPane({ context }: { context: SynastryContext }) {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Array<{ role: "user" | "assistant"; content: string }>>([
    { role: "assistant", content: "Ciao! Fammi una domanda sulla sinastria; ho già il contesto calcolato." },
  ]);

  const onSend = async () => {
    if (!input.trim()) return;
    setMessages((m) => [...m, { role: "user", content: input }]);
    // Stub: integra qui il tuo endpoint chat (POST /api/chat) passando { messages, context }
    setMessages((m) => [...m, { role: "assistant", content: "Ricevuto! Userò il contesto di sinastria per risponderti." }]);
    setInput("");
  };

  return (
    <div className="flex h-full flex-col gap-3">
      <div className="rounded-lg border border-gray-200 bg-white p-3 shadow-sm">
        <div className="mb-2 text-sm font-medium">Chat Sinastria</div>
        <div className="h-64 overflow-auto rounded-md border p-2 text-sm">
          {messages.map((m, i) => (
            <div key={i} className={`mb-2 ${m.role === "user" ? "text-gray-900" : "text-sky-700"}`}>
              <strong>{m.role === "user" ? "Tu" : "Assistente"}:</strong> {m.content}
            </div>
          ))}
        </div>
        <div className="mt-2 flex gap-2">
          <input
            className="flex-1 rounded-md border px-2 py-1 text-sm"
            placeholder="Scrivi…"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => (e.key === "Enter" ? onSend() : undefined)}
          />
          <button className="rounded-md bg-gray-900 px-3 py-1 text-sm text-white" onClick={onSend}>
            Invia
          </button>
        </div>
      </div>

      <details className="rounded-lg border border-gray-200 bg-white p-3 text-xs shadow-sm">
        <summary className="cursor-pointer select-none font-medium">Vedi SynastryContext (debug)</summary>
        <pre className="mt-2 max-h-72 overflow-auto">{JSON.stringify(context, null, 2)}</pre>
      </details>
    </div>
  );
}

```


## File: src\app\lab\people-pro\[id]\page.tsx

```tsx
// src/app/lab/people-pro/[id]/page.tsx

import { headers } from 'next/headers';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import SynastryPeopleProClient from './SynastryPeopleProClient';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

type HouseRow = { longitude: number };
type CPRow = { name: string; longitude: number; retro: boolean | null; sign?: string | null; house?: number | null };

type PlanetNameStrict =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';
type AngleName = 'ASC' | 'MC';
type PlanetOrAngle = PlanetNameStrict | AngleName;

type ChartPoint = {
  name: PlanetOrAngle;
  lon: number;           // 0..360
  retro?: boolean;
  sign?: string | null;
  house?: number | null;
};

type SAspectType = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';

type AspectRow = {
  p1_owner: 'user'|'person';
  p1_name: string;
  p2_owner: 'user'|'person';
  p2_name: string;
  aspect: SAspectType;
  angle: number | null;            // es. 0,60,90,120,180
  orb: number | null;              // distanza dall'angolo esatto (±gradi)
  applying: boolean | null;
  score: number | null;
};

const PLANETS: ReadonlySet<string> = new Set([
  'Sun','Moon','Mercury','Venus','Mars','Jupiter','Saturn','Uranus','Neptune','Pluto',
  'ASC','MC',
]);
const isPlanetOrAngle = (x: string): x is PlanetOrAngle => PLANETS.has(x);

function to12(rows: HouseRow[] | null | undefined): number[] | undefined {
  const xs = (rows ?? []).map(r => Number(r.longitude)).filter(n => Number.isFinite(n));
  return xs.length === 12 ? xs : undefined;
}

async function fetchHousesForPerson(supabase: ReturnType<typeof createSupabaseServerComponentClient>, personId: string, system: 'placidus'|'whole') {
  const { data } = await supabase
    .from('people_house_cusps')
    .select('longitude')
    .eq('person_id', personId)
    .eq('system', system)
    .order('cusp', { ascending: true }) as unknown as { data: HouseRow[] | null };
  return to12(data);
}

async function fetchHousesForUser(supabase: ReturnType<typeof createSupabaseServerComponentClient>, userId: string, system: 'placidus'|'whole') {
  const { data } = await supabase
    .from('house_cusps')
    .select('longitude')
    .eq('user_id', userId)
    .eq('system', system)
    .order('cusp', { ascending: true }) as unknown as { data: HouseRow[] | null };
  return to12(data);
}

async function serverPostWithCookies(path: string, body: Record<string, unknown>) {
  const h = headers();
  const host = h.get('x-forwarded-host') ?? h.get('host') ?? '';
  const proto = h.get('x-forwarded-proto') ?? 'https';
  const origin = `${proto}://${host}`;
  const res = await fetch(`${origin}${path}`, {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      cookie: h.get('cookie') ?? '',
    },
    body: JSON.stringify(body),
    cache: 'no-store',
  });
  return res;
}

export default async function Page({
  params,
  searchParams,
}: {
  params: { id: string },
  searchParams?: { system?: string; cj?: string; sx?: string; sq?: string; tr?: string; op?: string; orb?: string }
}) {
  const personId = params.id;
  const chosenSystem: 'placidus'|'whole' = searchParams?.system === 'whole' ? 'whole' : 'placidus';

  // flags iniziali (da URL; default ON)
  const initialFlags = {
    conjunction: searchParams?.cj !== '0',
    sextile:     searchParams?.sx !== '0',
    square:      searchParams?.sq !== '0',
    trine:       searchParams?.tr !== '0',
    opposition:  searchParams?.op !== '0',
  };
  const rawOrbOffset = Number(searchParams?.orb ?? 0);
  const initialOrbOffset = Number.isFinite(rawOrbOffset) ? rawOrbOffset : 0;

  const supabase = createSupabaseServerComponentClient();
  const { data: auth } = await supabase.auth.getUser();
  const userId = auth?.user?.id ?? null;

  // USER houses
  const [uPlac, uWhole] = await Promise.all([
    userId ? fetchHousesForUser(supabase, userId, 'placidus') : Promise.resolve(undefined),
    userId ? fetchHousesForUser(supabase, userId, 'whole')    : Promise.resolve(undefined),
  ]);

  // PERSON houses (compute se mancano)
  let pPlac = await fetchHousesForPerson(supabase, personId, 'placidus');
  let pWhole = await fetchHousesForPerson(supabase, personId, 'whole');

  if (!pPlac) {
    const res = await serverPostWithCookies('/api/people/house-cusps/upsert?system=placidus', { person_id: personId });
    if (res.ok) pPlac = await fetchHousesForPerson(supabase, personId, 'placidus');
  }
  if (!pWhole) {
    const res = await serverPostWithCookies('/api/people/house-cusps/upsert?system=whole', { person_id: personId });
    if (res.ok) pWhole = await fetchHousesForPerson(supabase, personId, 'whole');
  }

  // Points
  const { data: userPtsRaw } = await supabase
    .from('chart_points')
    .select('name,longitude,retro,sign,house')
    .eq('user_id', userId) as unknown as { data: CPRow[] | null };

  const { data: personPtsRaw } = await supabase
    .from('people_chart_points')
    .select('name,longitude,retro')
    .eq('person_id', personId) as unknown as { data: CPRow[] | null };

  const userPts: ChartPoint[] = (userPtsRaw ?? [])
    .filter(p => isPlanetOrAngle(p.name))
    .map(p => ({
      name: p.name as PlanetOrAngle,
      lon: Number(p.longitude),
      retro: !!p.retro,
      sign: p.sign ?? null,
      house: p.house ?? null,
    }));

  const personPts: ChartPoint[] = (personPtsRaw ?? [])
    .filter(p => isPlanetOrAngle(p.name))
    .map(p => ({
      name: p.name as PlanetOrAngle,
      lon: Number(p.longitude),
      retro: !!p.retro,
    }));

  // Assicura aspetti aggiornati (persistenza server, ma la UI filtrerà live)
  await serverPostWithCookies('/api/synastry/compute?persist=1', {
    person_id: personId,
    enabled: initialFlags,
    orbOffset: initialOrbOffset,
  });

  // Leggi aspetti “grezzi” (con orb numerico)
  const { data: aspectsRaw } = await supabase
    .from('synastry_aspects')
    .select('p1_owner,p1_name,p2_owner,p2_name,aspect,angle,orb,applying,score')
    .eq('user_id', userId)
    .eq('person_id', personId) as unknown as { data: AspectRow[] | null };

  // Case scelte
  const housesUser   = chosenSystem === 'placidus' ? (uPlac ?? undefined) : (uWhole ?? undefined);
  const housesPerson = chosenSystem === 'placidus' ? (pPlac ?? undefined) : (pWhole ?? undefined);

  const axesUser   = housesUser   ? { asc: housesUser[0]!,   mc: housesUser[9]! }   : undefined;
  const axesPerson = housesPerson ? { asc: housesPerson[0]!, mc: housesPerson[9]! } : undefined;

  return (
    <SynastryPeopleProClient
      personId={personId}
      chosenSystem={chosenSystem}
      user={{ points: userPts, houses: housesUser, axes: axesUser }}
      person={{ points: personPts, houses: housesPerson, axes: axesPerson }}
      aspectsRaw={aspectsRaw ?? []}
      initialFlags={initialFlags}
      initialOrbOffset={initialOrbOffset}
    />
  );
}

```


## File: src\app\lab\people-pro\[id]\SynastryPeopleProClient.tsx

```tsx
'use client';

import React from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import SynastryWheelPro, { type PlanetOrAngle, type SAspect, type SAspectType } from '@/components/astro/SynastryWheelPro';

type ChartPoint = {
  name: PlanetOrAngle;
  lon: number;
  retro?: boolean;
  sign?: string | null;
  house?: number | null;
};
type Axes = { asc: number; mc: number };

type AspectRow = {
  p1_owner: 'user'|'person';
  p1_name: string;
  p2_owner: 'user'|'person';
  p2_name: string;
  aspect: SAspectType;
  angle: number | null;
  orb: number | null;
  applying: boolean | null;
  score: number | null;
};

type Flags = {
  conjunction: boolean;
  sextile: boolean;
  square: boolean;
  trine: boolean;
  opposition: boolean;
};

const BASE_ORBS: Record<SAspectType, number> = {
  conjunction: 8,
  sextile: 4,
  square: 6,
  trine: 6,
  opposition: 8,
};

function isPlanetOrAngle(x: string): x is PlanetOrAngle {
  return ['Sun','Moon','Mercury','Venus','Mars','Jupiter','Saturn','Uranus','Neptune','Pluto','ASC','MC'].includes(x);
}

export default function SynastryPeopleProClient(props: {
  personId: string;
  chosenSystem: 'placidus'|'whole';
  user: { points: ChartPoint[]; houses?: number[]; axes?: Axes };
  person: { points: ChartPoint[]; houses?: number[]; axes?: Axes };
  aspectsRaw: AspectRow[];
  initialFlags: Flags;
  initialOrbOffset: number;
}) {
  const { personId, chosenSystem, user, person, aspectsRaw, initialFlags, initialOrbOffset } = props;

  const router = useRouter();
  const search = useSearchParams();

  // Stato controlli (client-side → real-time)
  const [flags, setFlags] = React.useState<Flags>(initialFlags);
  const [orbOffset, setOrbOffset] = React.useState<number>(initialOrbOffset);

  // Aggiorna URL (shallow) ad ogni modifica controlli
  React.useEffect(() => {
    const qs = new URLSearchParams(search?.toString() ?? '');
    qs.set('system', chosenSystem);
    qs.set('cj', flags.conjunction ? '1' : '0');
    qs.set('sx', flags.sextile ? '1' : '0');
    qs.set('sq', flags.square ? '1' : '0');
    qs.set('tr', flags.trine ? '1' : '0');
    qs.set('op', flags.opposition ? '1' : '0');
    qs.set('orb', String(orbOffset));
    router.replace(`/lab/people-pro/${personId}?${qs.toString()}`, { scroll: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [flags, orbOffset]);

  // Debounced recompute lato server (opzionale, non blocca la UI)
  React.useEffect(() => {
    const t = setTimeout(() => {
      fetch('/api/synastry/compute?persist=1', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ person_id: personId, enabled: flags, orbOffset }),
      }).catch(() => {});
    }, 400);
    return () => clearTimeout(t);
  }, [personId, flags, orbOffset]);

  // Filtro realtime client-side
  const enabledSet = React.useMemo(() => new Set<SAspectType>(
    (Object.entries(flags) as Array<[SAspectType, boolean]>).filter(([,v]) => v).map(([k]) => k)
  ), [flags]);

  const aspects: SAspect[] = React.useMemo(() => {
    return aspectsRaw
      .filter(r => isPlanetOrAngle(r.p1_name) && isPlanetOrAngle(r.p2_name))
      .filter(r => enabledSet.has(r.aspect))
      .filter(r => {
        const base = BASE_ORBS[r.aspect] ?? 0;
        const maxOrb = Math.max(0, base + orbOffset);
        const orbVal = Math.abs(Number(r.orb ?? 0));
        return orbVal <= maxOrb;
      })
      .map(r => ({
        a: { owner: r.p1_owner, name: r.p1_name as PlanetOrAngle },
        b: { owner: r.p2_owner, name: r.p2_name as PlanetOrAngle },
        aspect: r.aspect,
        applying: r.applying ?? undefined,
        score: r.score ?? undefined,
      }));
  }, [aspectsRaw, enabledSet, orbOffset]);

  // UI controlli (tipo Transits-Pro) — realtime
  return (
    <div className="px-4 py-6 space-y-4">
      <div className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm space-y-3">
        <div className="flex flex-wrap items-center gap-3">
          <label htmlFor="system" className="text-sm text-gray-700">Sistema case:</label>
          <select
            id="system"
            className="rounded-md border border-gray-300 bg-white px-2 py-1 text-sm"
            value={chosenSystem}
            onChange={(e) => {
              const qs = new URLSearchParams(search?.toString() ?? '');
              qs.set('system', e.target.value === 'whole' ? 'whole' : 'placidus');
              router.replace(`/lab/people-pro/${personId}?${qs.toString()}`);
            }}
          >
            <option value="placidus">Placidus</option>
            <option value="whole">Whole Sign</option>
          </select>
          <div className="text-xs text-gray-500">
            Mostrando: <b>{chosenSystem === 'placidus' ? 'Placidus' : 'Whole Sign'}</b>
          </div>
        </div>

        <div className="flex flex-wrap gap-6">
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={flags.conjunction}
              onChange={(e) => setFlags(f => ({ ...f, conjunction: e.target.checked }))}
            />
            Conjunction
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={flags.sextile}
              onChange={(e) => setFlags(f => ({ ...f, sextile: e.target.checked }))}
            />
            Sextile
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={flags.square}
              onChange={(e) => setFlags(f => ({ ...f, square: e.target.checked }))}
            />
            Square
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={flags.trine}
              onChange={(e) => setFlags(f => ({ ...f, trine: e.target.checked }))}
            />
            Trine
          </label>
          <label className="flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={flags.opposition}
              onChange={(e) => setFlags(f => ({ ...f, opposition: e.target.checked }))}
            />
            Opposition
          </label>
        </div>

        <div>
          <div className="mb-1 text-sm text-slate-700">
            Orb globale (± gradi): <b>{orbOffset > 0 ? `+${orbOffset}°` : `${orbOffset}°`}</b>
          </div>
          <input
            type="range"
            min={-6} max={+6} step={1}
            value={orbOffset}
            onChange={(e) => setOrbOffset(Number(e.target.value))}
            className="w-full"
            aria-label="Orb globale"
          />
          <div className="mt-1 text-xs text-slate-500">
            Applica un offset agli orbi base (conj 8°, sext 4°, sq 6°, tr 6°, opp 8°).
          </div>
        </div>
      </div>

      <div className="rounded-2xl border border-gray-200 bg-white p-3 shadow-sm">
        <div className="mx-auto w-full max-w-[860px]">
          <SynastryWheelPro
            user={user}
            person={person}
            aspects={aspects}
            responsive
          />
        </div>
      </div>
    </div>
  );
}
```


## File: src\app\lab\people-pro\page.tsx

```tsx
// FILE: src/app/lab/people-pro/page.tsx
import { Suspense } from "react";
import PeoplePanel from "@/components/PeoplePanel";
import PeopleList from "@/components/PeopleList";

export const revalidate = 60;

/**
 * Pagina "people-pro" (elenco + form).
 * - Colonna sinistra: form creazione/modifica persona (PeoplePanel)
 * - Colonna destra: lista persone (PeopleList)
 * Alla submit -> redirect automatico a /lab/people/[id]
 * Al click su card -> navigazione a /lab/people/[id]
 */
export default async function Page() {
  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamento…</div>}>
      <div className="mx-auto max-w-6xl px-4 py-8 grid gap-6 md:grid-cols-[1.2fr,1fr]">
        <section className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
          <h1 className="mb-3 text-xl font-semibold">Aggiungi/Modifica Persona</h1>
          <PeoplePanel />
        </section>

        <aside className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
          <h2 className="mb-3 text-lg font-semibold">Persone salvate</h2>
          <PeopleList />
        </aside>
      </div>
    </Suspense>
  );
}

```


## File: src\app\lab\transits-pro\ClientTransitsPro.tsx

```tsx
// FILE: src/app/lab/transits-pro/ClientTransitsPro.tsx
"use client";

import React, { useState } from "react";
import TransitsWheelPro, {
  type ProPoint,
  type AspectType,
} from "@/components/astro/TransitsWheelPro";

function Controls({
  enabledAspects,
  setEnabledAspects,
  orbOffsetDeg,
  setOrbOffsetDeg,
}: {
  enabledAspects: Record<AspectType, boolean>;
  setEnabledAspects: (val: Record<AspectType, boolean>) => void;
  orbOffsetDeg: number;
  setOrbOffsetDeg: (v: number) => void;
}) {
  const toggle = (k: AspectType) =>
    setEnabledAspects({ ...enabledAspects, [k]: !enabledAspects[k] });

  return (
    <div className="mb-4 grid gap-3 rounded-xl border border-gray-200 bg-white p-4 text-sm shadow-sm">
      <div className="font-medium text-gray-800">Impostazioni aspetti (natal ↔ transit)</div>

      <div className="grid grid-cols-2 gap-2 sm:grid-cols-5">
        {(["conjunction", "sextile", "square", "trine", "opposition"] as AspectType[]).map(
          (t) => (
            <label key={t} className="inline-flex items-center gap-2">
              <input
                type="checkbox"
                className="h-4 w-4 accent-gray-900"
                checked={enabledAspects[t]}
                onChange={() => toggle(t)}
              />
              <span className="capitalize">{t}</span>
            </label>
          )
        )}
      </div>

      <div className="mt-2">
        <label htmlFor="orb" className="mb-1 block text-gray-700">
          Orb globale (± gradi):{" "}
          <span className="font-semibold">
            {orbOffsetDeg >= 0 ? `+${orbOffsetDeg}` : orbOffsetDeg}°
          </span>
        </label>
        <input
          id="orb"
          type="range"
          min={-4}
          max={6}
          step={1}
          value={orbOffsetDeg}
          onChange={(e) => setOrbOffsetDeg(Number(e.target.value))}
          className="w-full"
        />
        <p className="mt-1 text-xs text-gray-500">
          Applica un offset agli orbi base (conj 8°, sext 4°, sq 6°, tr 6°, opp 8°).
        </p>
      </div>
    </div>
  );
}

export default function ClientTransitsPro({
  today,
  natal,
  houseCusps,
}: {
  today: ProPoint[];
  natal: ProPoint[];
  houseCusps?: number[];
}) {
  const [enabledAspects, setEnabledAspects] = useState<Record<AspectType, boolean>>({
    conjunction: true,
    sextile: true,
    square: true,
    trine: true,
    opposition: true,
  });
  const [orbOffsetDeg, setOrbOffsetDeg] = useState<number>(0);

  return (
    <div className="mx-auto max-w-5xl px-4 py-8">
      {/* Header */}
      <div className="mb-6">
        <h1 className="text-2xl font-semibold tracking-tight">Transits — Pro</h1>
        <p className="text-sm text-gray-500">
          Aspetti tra i pianeti natali dell’utente e i pianeti del cielo di oggi.
        </p>
      </div>

      {/* Controls */}
      <Controls
        enabledAspects={enabledAspects}
        setEnabledAspects={setEnabledAspects}
        orbOffsetDeg={orbOffsetDeg}
        setOrbOffsetDeg={setOrbOffsetDeg}
      />

      {/* Wheel */}
      <div className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
        <div className="aspect-square w-full max-w-[720px] mx-auto">
          <TransitsWheelPro
            today={today}
            natal={natal}
            houseCusps={houseCusps}
            enabledAspects={enabledAspects}
            orbOffsetDeg={orbOffsetDeg}
            responsive
          />
        </div>
      </div>
    </div>
  );
}

```


## File: src\app\lab\transits-pro\page.tsx

```tsx
// FILE: src/app/lab/transits-pro/page.tsx
import { Suspense } from "react";
import ClientTransitsPro from "./ClientTransitsPro";
import { computeDailyPlanets } from "@/lib/planets/runtime";
import { createSupabaseServerComponentClient } from "@/lib/supabaseServer";
import { computeHousesForDateUTC } from "@/lib/houses/runtime";

// ---------------------------
// Tipi locali (adattatore)
// ---------------------------

type RuntimePlanet = {
  name: string;
  longitude: number;
  retro?: boolean;
  sign?: string | null;
};

export type ProPoint = {
  id: string;
  name: string;
  lon: number;
  retro?: boolean;
  sign?: string | null;
};

type HouseSystem = "placidus" | "whole";

// Caching leggero
export const revalidate = 60;

// ---------------------------
// Loader pianeti natali da DB: chart_points
// ---------------------------

async function loadNatalForUser() {
  const supabase = createSupabaseServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { natal: [] as ProPoint[], missingReason: "not_logged" as const };
  }

  const { data, error } = await supabase
    .from("chart_points")
    .select("name, longitude, sign, house, retro")
    .eq("user_id", user.id);

  if (error) {
    return { natal: [] as ProPoint[], missingReason: "db_error" as const };
  }

  if (!data || data.length === 0) {
    return { natal: [] as ProPoint[], missingReason: "no_points" as const };
  }

  const natal: ProPoint[] = data
    .filter((row) => typeof row.longitude === "number" && row.name)
    .map((row) => ({
      id: row.name,
      name: row.name,
      lon: ((row.longitude % 360) + 360) % 360,
      retro: !!row.retro,
      sign: row.sign ?? null,
    }));

  return { natal, missingReason: null as null };
}

// ---------------------------
// Loader house cusps (natal) dal runtime case
// ---------------------------

async function loadNatalHouses() {
  const supabase = createSupabaseServerComponentClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { cusps: undefined as number[] | undefined, reason: "not_logged" as const };

  // Sistema case da user_prefs
  const { data: prefs } = await supabase
    .from("user_prefs")
    .select("house_system")
    .eq("user_id", user.id)
    .maybeSingle();

  const system = (prefs?.house_system ?? "placidus") as HouseSystem;

  // Dati di nascita (UTC + luogo) — adatta al tuo schema reale
  const { data: birth } = await supabase
    .from("birth_data")
    .select("date, lat, lon")
    .eq("user_id", user.id)
    .maybeSingle();

  if (!birth?.date || birth.lat == null || birth.lon == null) {
    return { cusps: undefined, reason: "no_birth_data" as const };
  }

  const houses = await computeHousesForDateUTC({
    system,
    dateUTC: new Date(birth.date),
    latDeg: birth.lat,
    lonDeg: birth.lon,
  });

  const cusps =
    houses?.cusps && Array.isArray(houses.cusps) && houses.cusps.length >= 12
      ? houses.cusps.slice(0, 12).map((d: number) => ((d % 360) + 360) % 360)
      : undefined;

  return { cusps, reason: null as null };
}

// ---------------------------
// Loader transiti di oggi
// ---------------------------

async function loadToday() {
  const nowUTC = new Date();
  const todayRaw: RuntimePlanet[] = await computeDailyPlanets(nowUTC);
  const today: ProPoint[] = todayRaw.map((p) => ({
    id: p.name,
    name: p.name,
    lon: p.longitude,
    retro: !!p.retro,
    sign: p.sign ?? null,
  }));
  return today;
}

// ---------------------------
// Page (Server Component)
// ---------------------------

export default async function Page() {
  const [today, natalRes, housesRes] = await Promise.all([
    loadToday(),
    loadNatalForUser(),
    loadNatalHouses(),
  ]);

  const { natal, missingReason } = natalRes;
  const { cusps: houseCusps, reason: housesReason } = housesRes;

  return (
    <Suspense fallback={<div className="p-6 text-sm text-gray-500">Caricamento Transits…</div>}>
      <ClientTransitsPro today={today} natal={natal} houseCusps={houseCusps} />

      {(missingReason || housesReason) && (
        <div className="mx-auto mt-4 max-w-5xl px-4 space-y-2">
          {missingReason === "not_logged" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Accedi per vedere i tuoi pianeti natali e le case nella ruota dei transiti.
            </div>
          )}
          {missingReason === "no_points" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Nessun punto natale trovato in <em>chart_points</em>.
            </div>
          )}
          {missingReason === "db_error" && (
            <div className="rounded-lg border border-rose-300 bg-rose-50 p-3 text-sm text-rose-800">
              Errore nel caricamento dei punti natali. Riprova più tardi.
            </div>
          )}
          {housesReason === "no_birth_data" && (
            <div className="rounded-lg border border-amber-300 bg-amber-50 p-3 text-sm text-amber-800">
              Dati di nascita mancanti: imposta data/ora/luogo di nascita per calcolare le case (sistema: da <code>user_prefs.house_system</code>).
            </div>
          )}
        </div>
      )}
    </Suspense>
  );
}

```


## File: src\app\layout.tsx

```tsx
// src/app/layout.tsx
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'Natal + Transits + Chat',
  description: 'Your chart-aware AI astrologer — wellness & entertainment only.',
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-white text-gray-900">
        <header className="border-b">
          <div className="mx-auto max-w-5xl px-4 py-4 flex items-center justify-between">
            <div className="font-semibold">Natal + Transits + Chat</div>
            <nav className="text-sm text-gray-600">MVP</nav>
          </div>
        </header>
        <main className="mx-auto max-w-5xl px-4 py-10">
          {children}
        </main>
        <footer className="border-t text-xs text-gray-500">
          <div className="mx-auto max-w-5xl px-4 py-6 space-y-2">
            <p>
              Disclaimer: this app provides content for wellness &amp; entertainment purposes only.
              It does not replace professional medical, legal, or financial advice.
            </p>
            <p>
              Transparency: MVP uses Whole Sign houses when birth time is available; otherwise a solar chart
              (no houses/ASC) with simplified orbs.
            </p>
          </div>
        </footer>
      </body>
    </html>
  )
}

```


## File: src\app\onboarding\page.tsx

```tsx
import Link from 'next/link';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';
import AuthForm from '@/components/AuthForm';
import BirthSection from '@/components/BirthSection';
import CurrentLocationForm from '@/components/CurrentLocationForm';

export const dynamic = 'force-dynamic';

export default async function OnboardingPage() {
  const supabase = createSupabaseServerComponentClient();

  // Auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return (
      <main className="max-w-3xl mx-auto p-6 space-y-6">
        <h1 className="text-2xl font-semibold">Get started</h1>
        <p className="text-sm text-gray-600">
          Create an account or sign in to save your chart and preferences.
        </p>
        <AuthForm />
      </main>
    );
  }

  // Dati salvati
  const { data: birth } = await supabase
    .from('birth_data')
    .select('name,date,time,place_name,lat,lon')
    .eq('user_id', user.id)
    .maybeSingle();

  const { data: prefs } = await supabase
    .from('user_prefs')
    .select('current_place_name,current_lat,current_lon,current_tz_name')
    .eq('user_id', user.id)
    .maybeSingle();

  return (
    <main className="max-w-3xl mx-auto p-6 space-y-10">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">Onboarding</h1>
        <Link href="/dashboard" className="text-sm rounded border px-3 py-2 hover:bg-gray-50">
          Go to dashboard
        </Link>
      </header>

      {/* Top bar azioni account */}
        {user ? (
        <div className="mb-4 flex items-center justify-end">
          <form action="/api/auth/signout" method="post">
             <button className="rounded-lg border px-3 py-1 text-sm hover:bg-gray-50">
             Sign out
             </button>
          </form>
        </div>
        ) : null}


      {/* Birth section gestita da client component (legge ?edit=birth) */}
      <section id="birth" className="space-y-3">
        <h2 className="text-lg font-medium">Birth data</h2>
        <BirthSection
          birth={{
            name: birth?.name ?? '',
            date: birth?.date ?? '',
            time: birth?.time ?? '',
            place_name: birth?.place_name ?? '',
            lat: birth?.lat ?? null,
            lon: birth?.lon ?? null,
          }}
        />
      </section>

      {/* Current Location */}
      <section id="location" className="space-y-3">
        <h2 className="text-lg font-medium">Current location (for transits)</h2>
        <CurrentLocationForm
          initial={{
            place_name: prefs?.current_place_name ?? '',
            lat: prefs?.current_lat ?? null,
            lon: prefs?.current_lon ?? null,
            tz_name: prefs?.current_tz_name ?? '',
          }}
        />
      </section>
    </main>
  );
}

```


## File: src\app\page.tsx

```tsx
// src/app/page.tsx
import Link from 'next/link';
import { createSupabaseServerComponentClient } from '@/lib/supabaseServer';

export const dynamic = 'force-dynamic';

export default async function HomePage() {
  const supabase = createSupabaseServerComponentClient();
  const { data: { user } } = await supabase.auth.getUser();

  const ctaHref = user ? '/dashboard' : '/onboarding';

  return (
    <main className="min-h-screen flex items-center justify-center p-8">
      <div className="max-w-3xl text-center space-y-6">
        <h1 className="text-3xl font-bold">Il tuo astrologo AI tascabile</h1>
        <p className="text-gray-600">
          Tema natale, transiti quotidiani/settimanali, e una chat AI che conosce la tua carta.
        </p>
        <div className="flex items-center justify-center gap-3">
          <Link
            href={ctaHref}
            className="rounded-xl bg-blue-600 text-white px-5 py-3 hover:bg-blue-700"
          >
            Get Started
          </Link>
          <Link
            href="/onboarding"
            className="rounded-xl border px-5 py-3 hover:bg-gray-50"
          >
            Onboarding
          </Link>
        </div>
        <p className="text-xs text-gray-500">
          Benessere/entertainment. Non sostituisce consigli medici/legali/finanziari.
        </p>
      </div>
    </main>
  );
}

```


## File: src\components\astro\_parts.tsx

```tsx
// FILE: src/components/astro/_parts.tsx
"use client";

import React from "react";
import type { Point } from "../../lib/aspects";
import { ASPECTS } from "../../lib/aspects";
import "./proTheme.css";

/* ===== utilities ===== */
const rad = (deg: number) => ((deg - 90) * Math.PI) / 180;
const X = (cx: number, r: number, deg: number) => cx + r * Math.cos(rad(deg));
const Y = (cy: number, r: number, deg: number) => cy + r * Math.sin(rad(deg));

/* ===== glifi & colori ===== */
const ZODIAC_GLYPH: Record<number, string> = {
  0: "♈", 30: "♉", 60: "♊", 90: "♋", 120: "♌", 150: "♍",
  180: "♎", 210: "♏", 240: "♐", 270: "♑", 300: "♒", 330: "♓",
};
const SIGN_COLOR_VAR: Record<number, string> = {
  0: "var(--sign-aries)",      30: "var(--sign-taurus)",
  60: "var(--sign-gemini)",    90: "var(--sign-cancer)",
  120: "var(--sign-leo)",      150: "var(--sign-virgo)",
  180: "var(--sign-libra)",    210: "var(--sign-scorpio)",
  240: "var(--sign-sagittarius)", 270: "var(--sign-capricorn)",
  300: "var(--sign-aquarius)", 330: "var(--sign-pisces)",
};

const PLANET_GLYPH: Record<string, string> = {
  Sun: "☉", Moon: "☽", Mercury: "☿", Venus: "♀", Mars: "♂",
  Jupiter: "♃", Saturn: "♄", Uranus: "♅", Neptune: "♆", Pluto: "♇",
  NNode: "☊", SNode: "☋", Asc: "ASC", Mc: "MC",
};

/* ===== 1) Zodiac Ring ===== */
type ZodiacProps = { cx: number; cy: number; r: number };
export function ZodiacRingPro({ cx, cy, r }: ZodiacProps) {
  const stroke = "var(--wheel-stroke)";
  return (
    <g>
      <circle cx={cx} cy={cy} r={r} fill="none" stroke={stroke} strokeWidth={3} />
      {Array.from({ length: 12 }).map((_, i) => {
        const deg = i * 30;
        const x1 = X(cx, r - 18, deg), y1 = Y(cy, r - 18, deg);
        const x2 = X(cx, r, deg),     y2 = Y(cy, r, deg);
        return (
          <line key={`zdiv-${i}`} x1={x1} y1={y1} x2={x2} y2={y2}
            stroke={stroke} strokeWidth={2}/>
        );
      })}
      {Object.entries(ZODIAC_GLYPH).map(([degStr, glyph]) => {
        const base = Number(degStr);
        const deg = base + 15; // centro settore
        return (
          <text key={`zgl-${base}`} x={X(cx, r - 28, deg)} y={Y(cy, r - 28, deg) + 7}
            textAnchor="middle" fontSize={22} style={{ fill: SIGN_COLOR_VAR[base] }}>
            {glyph}
          </text>
        );
      })}
    </g>
  );
}

/* ===== 2) Houses Ring (dell'utente) ===== */
type HousesProps = { cx: number; cy: number; rOuter: number; rInner: number; cusps: number[] };
export function HousesRingPro({ cx, cy, rOuter, rInner, cusps }: HousesProps) {
  const grid = "var(--grid-strong)";
  return (
    <g>
      <circle cx={cx} cy={cy} r={rOuter} fill="none" stroke={grid} />
      <circle cx={cx} cy={cy} r={rInner} fill="none" stroke={grid} />
      {cusps?.length === 12 && cusps.map((deg, i) => (
        <line key={`h-${i}`} x1={X(cx, rInner, deg)} y1={Y(cy, rInner, deg)}
          x2={X(cx, rOuter, deg)} y2={Y(cy, rOuter, deg)} stroke={grid} />
      ))}
    </g>
  );
}

/* ===== 3) Pianeti (oggi) ===== */
type PlanetGlyphsProps = {
  cx: number; cy: number; r: number; points: Point[];
  onHover?: (key: string | null)=>void; hoverSet?: Set<string> | null; ringId?: "t";
};
export function PlanetGlyphsPro({ cx, cy, r, points, onHover, hoverSet }: PlanetGlyphsProps) {
  return (
    <g>
      {points.map((p) => {
        const k = `t:${p.name}`;
        const active = !hoverSet || hoverSet.has(k);
        const x = X(cx, r, p.longitude), y = Y(cy, r, p.longitude);
        const glyph = PLANET_GLYPH[p.name] ?? p.name.slice(0,2);
        return (
          <g key={k} transform={`translate(${x},${y})`}
             onMouseEnter={()=>onHover?.(k)} onMouseLeave={()=>onHover?.(null)}
             style={{ cursor: "pointer" }}>
            <circle r={13} fill={active ? "var(--planet-fill)" : "var(--planet-fill-dim)"} />
            <text x={0} y={4} textAnchor="middle" fontSize={12} fill="var(--planet-label)">{glyph}</text>
          </g>
        );
      })}
    </g>
  );
}

/* ===== 4) Aspect Lines (oggi↔oggi) ===== */
type AspectLinesProps = {
  cx: number; cy: number; r: number;
  aspects: Array<{ a: string; b: string; aspect: keyof typeof ASPECTS; orb: number }>;
  idx: Map<string, number>; hoverSet: Set<string> | null;
};
const ASPECT_COLOR: Record<keyof typeof ASPECTS, string> = {
  conj: "var(--aspect-conjunction)",
  sext: "var(--aspect-sextile)",
  sq:   "var(--aspect-square)",
  tri:  "var(--aspect-trine)",
  opp:  "var(--aspect-opposition)",
};
export function AspectLinesStraightToday({ cx, cy, r, aspects, idx, hoverSet }: AspectLinesProps) {
  return (
    <g>
      {aspects.map((a, i) => {
        const d1 = idx.get(a.a), d2 = idx.get(a.b);
        if (d1 == null || d2 == null) return null;
        const key1 = `t:${a.a}`, key2 = `t:${a.b}`;
        const active = !hoverSet || hoverSet.has(key1) || hoverSet.has(key2);
        const x1 = X(cx, r, d1), y1 = Y(cy, r, d1);
        const x2 = X(cx, r, d2), y2 = Y(cy, r, d2);
        return (
          <line key={`${i}-${a.a}-${a.b}`} x1={x1} y1={y1} x2={x2} y2={y2}
            stroke={ASPECT_COLOR[a.aspect]} strokeOpacity={active ? 0.9 : 0.25}
            strokeWidth={active ? 1.8 : 0.8}/>
        );
      })}
    </g>
  );
}

/* ===== 5) Cerchi aspectogram ===== */
export function AspectGuides({ cx, cy, rOuter, rInner }:{cx:number;cy:number;rOuter:number;rInner:number}) {
  return (
    <g>
      <circle cx={cx} cy={cy} r={rOuter} fill="none" stroke="var(--grid-strong)" />
      <circle cx={cx} cy={cy} r={rInner} fill="none" stroke="var(--grid-stroke)" />
    </g>
  );
}

```


## File: src\components\astro\ChartWheelPro.tsx

```tsx
// src/components/astro/ChartWheelPro.tsx
'use client';

import React, { useMemo, useState } from 'react';
import { ProPoint } from '@/lib/graphics/types';
import {
  signColor,
  planetChar,
  PlanetName,
  ZodiacSign,
  signChar,
} from '@/lib/graphics/glyphs';
import { ASPECT_COLORS } from '@/lib/graphics/tokens';
import { polarToXY, resolveCollisions } from '@/lib/graphics/polar';

type Axes = { asc: number; mc: number };

export default function ChartWheelPro({
  title = 'ChartWheelPro (Natal)',
  points,
  houseCusps,
  axes,                 // opzionale
  size = 520,
  className,
  responsive = true,
  usePlanetBadges = false,
}: {
  title?: string;
  points: ProPoint[];
  houseCusps?: number[];
  axes?: Axes;
  size?: number;
  className?: string;
  responsive?: boolean;
  usePlanetBadges?: boolean;
}) {
  const r = size / 2;

  // —— RAGGI (dal centro verso l’esterno) ——
  const aspectsR          = r * 0.34;
  const housesNumR        = r * 0.48;
  const housesNumInnerR   = r * 0.44;
  const housesNumOuterR   = r * 0.52;
  const planetsR          = r * 0.76;
  const zodiacInnerR      = r * 0.86;
  const zodiacOuterR      = r * 0.98;

  // —— Assi: derivazione se non forniti —— //
  const baseAxes: Axes = useMemo(() => {
    if (axes) return { asc: norm(axes.asc), mc: norm(axes.mc) };
    if (houseCusps && houseCusps.length === 12) {
      return { asc: norm(houseCusps[0]!), mc: norm(houseCusps[9]!) };
    }
    return { asc: 180, mc: 90 }; // placeholder
  }, [axes, houseCusps]);

  // —— Rotazione ANGOLI (non testo): vogliamo AC a 270° (sinistra) —— //
  // polarToXY usa 0° in alto, 90° a destra, 180° in basso, 270° a sinistra.
  // Quindi rot = 270 - ASC.
  const rot = useMemo(() => norm(270 - baseAxes.asc), [baseAxes.asc]);
  const applyRot = (deg: number) => norm(deg + rot);

  const [hoverAspectIdx, setHoverAspectIdx] = useState<number | null>(null);
  const [hoverPlanetIdx, setHoverPlanetIdx] = useState<number | null>(null);
  const [focusPlanetIdx, setFocusPlanetIdx] = useState<number | null>(null);

  const planetAnglesRaw = useMemo(
    () => resolveCollisions(points.map(p => p.longitude), 8),
    [points]
  );

  // —— aspetti natal —— //
  const aspects = useMemo(() => {
    const results: { from: number; to: number; type: keyof typeof ASPECT_COLORS }[] = [];
    const defs = [
      { type: 'conjunction' as const, deg: 0 },
      { type: 'opposition'  as const, deg: 180 },
      { type: 'trine'       as const, deg: 120 },
      { type: 'square'      as const, deg: 90 },
      { type: 'sextile'     as const, deg: 60 },
    ];
    const orb = 6;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const diff = Math.abs(points[i].longitude - points[j].longitude) % 360;
        const d = diff > 180 ? 360 - diff : diff;
        const found = defs.find(a => Math.abs(d - a.deg) <= orb);
        if (found) results.push({ from: i, to: j, type: found.type });
      }
    }
    return results;
  }, [points]);

  const aspectsByPlanet = useMemo(() => {
    const map = new Map<number, number[]>();
    aspects.forEach((a, idx) => {
      (map.get(a.from) ?? map.set(a.from, []).get(a.from)!).push(idx);
      (map.get(a.to) ?? map.set(a.to, []).get(a.to)!).push(idx);
    });
    return map;
  }, [aspects]);

  const highlightedPlanets = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) {
      const a = aspects[hoverAspectIdx];
      if (a) { set.add(a.from); set.add(a.to); }
    }
    if (hoverPlanetIdx != null) {
      set.add(hoverPlanetIdx);
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) { const a = aspects[idx]; set.add(a.from); set.add(a.to); }
    }
    if (focusPlanetIdx != null) set.add(focusPlanetIdx);
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, focusPlanetIdx, aspects, aspectsByPlanet]);

  const highlightedAspects = useMemo(() => {
    const set = new Set<number>();
    if (hoverAspectIdx != null) set.add(hoverAspectIdx);
    if (hoverPlanetIdx != null) {
      const rel = aspectsByPlanet.get(hoverPlanetIdx) ?? [];
      for (const idx of rel) set.add(idx);
    }
    return set;
  }, [hoverAspectIdx, hoverPlanetIdx, aspectsByPlanet]);

  function buildAriaLabel(p: ProPoint): string {
    const sign = p.sign ?? signFromLongitude(p.longitude);
    const deg = (p.longitude % 30 + 30) % 30;
    return `${p.name} ${deg.toFixed(1)}° ${sign}`;
  }

  return (
    <div className={`rounded-2xl border p-4 bg-white ${className ?? ''}`}>
      <div className="mb-3 text-sm font-medium">{title}</div>

      <svg
        role="img"
        aria-label={title}
        viewBox={`0 0 ${size} ${size}`}
        width={responsive ? '100%' : size}
        height={responsive ? 'auto' : size}
        className={responsive ? 'w-full h-auto' : undefined}
        style={responsive ? { aspectRatio: '1 / 1', display: 'block' } : undefined}
      >
        {/* —— Zodiac band —— */}
        {Array.from({ length: 12 }).map((_, i) => {
          const path = describeDonutSector(
            r, r, zodiacOuterR, zodiacInnerR,
            applyRot(i * 30), applyRot(i * 30 + 30)
          );
          return <path key={`sec-${i}`} d={path} fill="white" stroke="none" />;
        })}
        {Array.from({ length: 12 }).map((_, i) => {
          const deg = applyRot(i * 30);
          const p1 = polarToXY(r, r, zodiacInnerR, deg);
          const p2 = polarToXY(r, r, zodiacOuterR, deg);
          return <line key={`sep-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#111827" strokeWidth={1} opacity={0.7} />;
        })}
        <circle cx={r} cy={r} r={zodiacOuterR} fill="none" stroke="#111827" strokeWidth={1.5} />
        <circle cx={r} cy={r} r={zodiacInnerR} fill="none" stroke="#111827" strokeWidth={1} opacity={0.6} />

        {renderZodiacBandColored(r, size, (zodiacInnerR + zodiacOuterR) / 2, applyRot)}

        {/* —— Case —— */}
        {houseCusps && houseCusps.length === 12 && houseCusps.map((deg, i) => {
          const d = applyRot(deg);
          const p1 = polarToXY(r, r, 0, d);
          const p2 = polarToXY(r, r, zodiacInnerR, d);
          return <line key={`cusp-${i}`} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#9ca3af" strokeWidth={0.9} />;
        })}

        {/* —— Assi + etichette —— */}
        {renderAxes(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}
        {renderAxisLabels(r, size, { asc: applyRot(baseAxes.asc), mc: applyRot(baseAxes.mc) }, zodiacOuterR)}

        {/* —— Rete aspetti —— */}
        {aspects.map((a, idx) => {
          const a1 = applyRot(planetAnglesRaw[a.from]);
          const a2 = applyRot(planetAnglesRaw[a.to]);
          const p1 = polarToXY(r, r, aspectsR, a1);
          const p2 = polarToXY(r, r, aspectsR, a2);
          const isHi = highlightedAspects.has(idx);
          return (
            <line
              key={idx}
              x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
              stroke={ASPECT_COLORS[a.type]}
              strokeWidth={isHi ? 2.6 : 1.2}
              opacity={isHi ? 1 : 0.75}
              onMouseEnter={() => setHoverAspectIdx(idx)}
              onMouseLeave={() => setHoverAspectIdx(null)}
            />
          );
        })}

        {/* —— Anello numeri case —— */}
        <circle cx={r} cy={r} r={housesNumInnerR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        <circle cx={r} cy={r} r={housesNumOuterR} fill="none" stroke="#9ca3af" strokeWidth={0.8} opacity={0.7} />
        {houseCusps && houseCusps.length === 12 && renderHouseNumbers(r, size, housesNumR, houseCusps, applyRot)}

        {/* —— Pianeti —— */}
        {points.map((p, i) => {
          const aRot = applyRot(planetAnglesRaw[i]);

          const tickStartR = zodiacInnerR;
          const tickEndR   = zodiacInnerR - (zodiacInnerR - planetsR) * 0.45;

          const tickStart = polarToXY(r, r, tickStartR, aRot);
          const tickEnd   = polarToXY(r, r, tickEndR, aRot);
          const glyph     = polarToXY(r, r, planetsR, aRot);

          const isHi = highlightedPlanets.has(i) || focusPlanetIdx === i;
          const char = planetChar(p.name as PlanetName);
          const glyphFont = 14 * (size / 520);

          return (
            <g
              key={i}
              tabIndex={0}
              role="img"
              aria-label={buildAriaLabel(p)}
              onFocus={() => setFocusPlanetIdx(i)}
              onBlur={() => setFocusPlanetIdx(null)}
              onMouseEnter={() => setHoverPlanetIdx(i)}
              onMouseLeave={() => setHoverPlanetIdx(null)}
              style={{ cursor: 'pointer' }}
            >
              <line x1={tickStart.x} y1={tickStart.y} x2={tickEnd.x} y2={tickEnd.y} stroke="#111827" strokeWidth={0.9} opacity={0.85} />
              <circle cx={glyph.x} cy={glyph.y} r={9 * (size / 520)} fill="white" />
              <text
                x={glyph.x}
                y={glyph.y}
                textAnchor="middle"
                dominantBaseline="central"
                fontSize={glyphFont}
                fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                fill="#111827"
                pointerEvents="none"
              >
                {char}
              </text>
              {usePlanetBadges ? (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={10 * (size / 520)} fill="white" stroke={isHi ? '#111827' : 'black'} strokeWidth={isHi ? 1.8 : 1} />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={13.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.85} />}
                </>
              ) : (
                <>
                  <circle cx={glyph.x} cy={glyph.y} r={12 * (size / 520)} fill="transparent" pointerEvents="all" />
                  {isHi && <circle cx={glyph.x} cy={glyph.y} r={12.5 * (size / 520)} fill="none" stroke="#2563eb" strokeWidth={2} opacity={0.9} />}
                </>
              )}
              <title>{buildAriaLabel(p)}</title>
            </g>
          );
        })}
      </svg>
    </div>
  );
}

/** Glifi dei segni colorati (testo diritto), con angoli ruotati */
function renderZodiacBandColored(
  cx: number,
  size: number,
  radius: number,
  applyRot: (deg: number) => number
) {
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs.map((s, i) => {
    const mid = applyRot(i * 30 + 15);
    const { x, y } = polarToXY(cx, cx, radius, mid);
    return (
      <text
        key={s}
        x={x}
        y={y}
        textAnchor="middle"
        dominantBaseline="central"
        fontSize={14 * (size / 520)}
        fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
        fill={signColor(s)}
      >
        {signChar(s)}
      </text>
    );
  });
}

function renderAxes(
  r: number,
  size: number,
  axesRot: Axes,   // asc/mc già ruotati via applyRot
  outerRingR: number
) {
  // Invertiamo MC/IC per avere MC in alto e IC in basso
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Chart axes">
      {items.map((it, idx) => {
        const p1 = polarToXY(r, r, 0, it.deg);
        const p2 = polarToXY(r, r, outerRingR, it.deg);
        return (
          <line
            key={idx}
            x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y}
            stroke="#111827" strokeWidth={1.1} opacity={0.7}
          />
        );
      })}
    </g>
  );
}

function renderAxisLabels(
  r: number,
  size: number,
  axesRot: Axes,
  outerRingR: number
) {
  const labelR = outerRingR + 14 * (size / 520);
  const dc = norm(axesRot.asc + 180);
  const mcTop = norm(axesRot.mc + 180);
  const icBottom = norm(axesRot.mc);

  const items = [
    { deg: axesRot.asc, label: 'AC' },
    { deg: dc,          label: 'DC' },
    { deg: mcTop,       label: 'MC' },
    { deg: icBottom,    label: 'IC' },
  ];
  return (
    <g aria-label="Axis labels">
      {items.map((it, idx) => {
        const t = polarToXY(r, r, labelR, it.deg);
        return (
          <text
            key={idx}
            x={t.x}
            y={t.y}
            textAnchor="middle"
            dominantBaseline="central"
            fontSize={11 * (size / 520)}
            fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
            fill="#111827"
          >
            {it.label}
          </text>
        );
      })}
    </g>
  );
}

/** Numeri delle case nel “middle” tra cusp[i] e cusp[i+1], con rotazione applicata */
function renderHouseNumbers(
  r: number,
  size: number,
  radius: number,
  cusps: number[],
  applyRot: (deg: number) => number
) {
  const items = Array.from({ length: 12 }).map((_, i) => {
    const a = applyRot(cusps[i]!);
    const b = applyRot(cusps[(i + 1) % 12]!);
    const mid = midAngle(a, b);
    const { x, y } = polarToXY(r, r, radius, mid);
    return { i: i + 1, x, y };
  });
  return (
    <g aria-label="House numbers">
      {items.map(({ i, x, y }) => (
        <text
          key={i}
          x={x}
          y={y}
          textAnchor="middle"
          dominantBaseline="central"
          fontSize={12 * (size / 520)}
          fontFamily='ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial'
          fill="#111827"
          opacity={0.85}
        >
          {i}
        </text>
      ))}
    </g>
  );
}

function midAngle(a: number, b: number) {
  let d = norm(b - a);
  if (d > 180) d -= 360;
  return norm(a + d / 2);
}

function norm(deg: number) {
  let d = deg % 360;
  if (d < 0) d += 360;
  return d;
}

/** Settore ad anello (donut) tra due raggi */
function describeDonutSector(
  cx: number, cy: number,
  rOuter: number, rInner: number,
  startDeg: number, endDeg: number
): string {
  const startOuter = polarToXY(cx, cy, rOuter, endDeg);
  const endOuter   = polarToXY(cx, cy, rOuter, startDeg);
  const startInner = polarToXY(cx, cy, rInner, startDeg);
  const endInner   = polarToXY(cx, cy, rInner, endDeg);
  const delta = norm(endDeg - startDeg);
  const largeArc = delta <= 180 ? 0 : 1;
  return [
    `M ${startOuter.x} ${startOuter.y}`,
    `A ${rOuter} ${rOuter} 0 ${largeArc} 0 ${endOuter.x} ${endOuter.y}`,
    `L ${startInner.x} ${startInner.y}`,
    `A ${rInner} ${rInner} 0 ${largeArc} 1 ${endInner.x} ${endInner.y}`,
    'Z',
  ].join(' ');
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor((((longitude % 360) + 360) % 360) / 30);
  const signs: ZodiacSign[] = [
    'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
    'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'
  ];
  return signs[idx]!;
}

```


## File: src\components\astro\css\proTheme.css

```css
/* FILE: src/components/astro/proTheme.css */

/* 
  Palette guidata da CSS variables.
  Se ChartWheelPro/natal-pro definiscono già variabili di tema,
  queste faranno semplicemente da fallback.
*/

:root {
  /* Segni – fallback */
  --sign-aries: #e05858;
  --sign-taurus: #c58b2b;
  --sign-gemini: #d6a11a;
  --sign-cancer: #4aa9c8;
  --sign-leo: #f08c2e;
  --sign-virgo: #3e8e7e;
  --sign-libra: #b66ad3;
  --sign-scorpio: #6b5bd3;
  --sign-sagittarius: #3ea56e;
  --sign-capricorn: #2f4858;
  --sign-aquarius: #4b8bd8;
  --sign-pisces: #6fb0ff;

  /* Aspetti – fallback */
  --aspect-conjunction: #3a3a3a;
  --aspect-sextile: #1e88e5;
  --aspect-square: #d32f2f;
  --aspect-trine: #43a047;
  --aspect-opposition: #8e24aa;

  /* Ruota */
  --wheel-stroke: #101419;
  --grid-stroke: #9aa4b214;   /* linee sottili intermedie */
  --grid-strong: #9aa4b235;   /* linee cuspidi/cerchi principali */
  --planet-fill: #0f172a;     /* balloon pianeti */
  --planet-fill-dim: #0f172a55;
  --planet-label: #ffffff;
}

```


## File: src\components\astro\DailySkyWheelPro.tsx

```tsx
// FILE: src/components/astro/DailySkyWheelPro.tsx
"use client";

import React, { useMemo, useState, useId } from "react";
import { polarToXY } from "@/lib/graphics/polar";
import {
  planetChar,
  signChar,
  signColor,
  aspectColor,
  type PlanetName,
  type ZodiacSign,
} from "@/lib/graphics/glyphs";

// -------------------------------
// Tipi
// -------------------------------

export type ProPoint = {
  id: string;      // "Sun" | ...
  name: string;
  lon: number;     // [0..360)
  retro?: boolean;
  sign?: string | null;
};

export type AspectType = "conjunction" | "sextile" | "square" | "trine" | "opposition";

export type InterAspect = {
  id: string;
  a: ProPoint;
  b: ProPoint;
  type: AspectType;
  exactAngle: number; // 0,60,90,120,180
  delta: number;      // distanza dall'esatto
  strength: number;   // 0..1
};

// -------------------------------
// Costanti (coerenti con ChartWheelPro)
// -------------------------------

const STROKES = {
  ringThin: 0.22,
  ringMid: 0.28,
  ringBold: 0.9,
  aspects: 0.35,
  aspectsHi: 1.0,
  planetHalo: 0.35,
  planetHaloHi: 1.0,
};

const ASPECTS_MAP: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

// Orbi "base" (come deciso in Step 3); lo slider applica un offset globale
const ORBS_BASE: Record<AspectType, number> = {
  conjunction: 8,
  sextile: 4,
  square: 6,
  trine: 6,
  opposition: 8,
};

// -------------------------------
// Utility
// -------------------------------

function norm360(d: number) {
  return ((d % 360) + 360) % 360;
}

function angularDistance(a: number, b: number): number {
  let d = Math.abs(a - b) % 360;
  if (d > 180) d = 360 - d;
  return d;
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor(norm360(longitude) / 30);
  const signs: ZodiacSign[] = [
    "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
    "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"
  ];
  return signs[idx]!;
}

function PlanetGlyph({ name, size, fill = "currentColor" }: { name: string; size: number; fill?: string }) {
  const g = planetChar(name as PlanetName) ?? "•";
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={name}
      fill={fill}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

function SignGlyph({ sign, size }: { sign: ZodiacSign; size: number }) {
  const g = signChar(sign);
  const c = signColor(sign);
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={sign}
      fill={c} // solo glifo colorato, nessun contorno
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

// -------------------------------
// Props
// -------------------------------

export type DailySkyWheelProProps = {
  today: ProPoint[];
  /** Abilitazione per tipo di aspetto (default: tutti true) */
  enabledAspects?: Partial<Record<AspectType, boolean>>;
  /** Offset globale in gradi applicato agli orbi base (può essere negativo/positivo) */
  orbOffsetDeg?: number;
  size?: number;
  className?: string;
  responsive?: boolean;
};

// -------------------------------
// Component
// -------------------------------

const CX = 260;
const CY = 260;

export default function DailySkyWheelPro({
  today,
  enabledAspects,
  orbOffsetDeg = 0,
  size = 520,
  className,
  responsive = true,
}: DailySkyWheelProProps) {
  const uid = useId();

  // --- Geometrie (come concordato) ---
  const R_ZOD_OUT = 252;   // bordo esterno fascia segni
  const R_ZOD_IN  = 228;   // bordo interno fascia segni
  const R_PLANET  = 200;   // corona pianeti
  const R_ASPECT  = 150;   // hub aspetti
  const PLANET_TICK_LEN = 18;
  const PLANET_TICK_OPACITY = 0.28;
  const PLANET_TICK_WIDTH = 1.0;

  // Stato hover
  const [hoverPlanetId, setHoverPlanetId] = useState<string | null>(null);
  const [hoverAspectId, setHoverAspectId] = useState<string | null>(null);

  // Pianeti con posizioni e segni
  const planets = useMemo(() => {
    return today.map((p) => {
      const theta = norm360(p.lon);
      const posPlan = polarToXY(CX, CY, R_PLANET, theta);
      const posAsp  = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return {
        ...p,
        theta,
        x: posPlan.x, y: posPlan.y,
        ax: posAsp.x, ay: posAsp.y,
        signZ: s,
      };
    });
  }, [today]);

  // Mappa enabled (default tutti attivi)
  const enabled: Record<AspectType, boolean> = useMemo(() => {
    const allTrue: Record<AspectType, boolean> = {
      conjunction: true, sextile: true, square: true, trine: true, opposition: true,
    };
    return { ...allTrue, ...(enabledAspects ?? {}) };
  }, [enabledAspects]);

  // Orbi effettivi applicando l'offset (clamp min 0)
  const ORBS: Record<AspectType, number> = useMemo(() => {
    const clamp = (v: number) => Math.max(0, v);
    return {
      conjunction: clamp(ORBS_BASE.conjunction + orbOffsetDeg),
      sextile:     clamp(ORBS_BASE.sextile     + orbOffsetDeg),
      square:      clamp(ORBS_BASE.square      + orbOffsetDeg),
      trine:       clamp(ORBS_BASE.trine       + orbOffsetDeg),
      opposition:  clamp(ORBS_BASE.opposition  + orbOffsetDeg),
    };
  }, [orbOffsetDeg]);

  // Calcolo aspetti (rispetta enabled + ORBS correnti)
  type BestMatch = { t: AspectType; exact: number; delta: number; strength: number };

const aspects = useMemo<InterAspect[]>(() => {
  const out: InterAspect[] = [];

  for (let i = 0; i < today.length; i++) {
    for (let j = i + 1; j < today.length; j++) {
      const a = today[i];
      const b = today[j];
      const d = angularDistance(a.lon, b.lon);

      let best: BestMatch | undefined;

      for (const t of Object.keys(ASPECTS_MAP) as AspectType[]) {
        if (!enabled[t]) continue; // skip se tipo disabilitato

        const exact = ASPECTS_MAP[t];
        const orb = ORBS[t];
        const delta = Math.abs(d - exact);

        if (delta <= orb) {
          const strength = orb === 0 ? 0 : 1 - delta / orb;
          if (!best || delta < best.delta) {
            best = { t, exact, delta, strength };
          }
        }
      }

      if (best) {
        out.push({
          id: `${a.id}-${b.id}-${best.t}`,
          a,
          b,
          type: best.t,
          exactAngle: best.exact,
          delta: best.delta,
          strength: best.strength,
        });
      }
    }
  }

  return out;
}, [today, enabled, ORBS]);

  // Hover sets
  const involvedAspects = useMemo(() => {
    if (hoverPlanetId) return new Set(aspects.filter(a => a.a.id === hoverPlanetId || a.b.id === hoverPlanetId).map(a => a.id));
    if (hoverAspectId) return new Set([hoverAspectId]);
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  const involvedPlanets = useMemo(() => {
    if (hoverPlanetId) {
      const ids = aspects
        .filter(a => a.a.id === hoverPlanetId || a.b.id === hoverPlanetId)
        .flatMap(a => [a.a.id, a.b.id]);
      return new Set<string>([hoverPlanetId, ...ids]);
    }
    if (hoverAspectId) {
      const a = aspects.find(x => x.id === hoverAspectId);
      if (a) return new Set<string>([a.a.id, a.b.id]);
    }
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  // Zodiac band (ticks + glifi)
  const zodiacMarks = useMemo(() => {
    const out: {
      sign: ZodiacSign; mid: number;
      tx1: number; ty1: number; tx2: number; ty2: number;
      gx: number; gy: number;
    }[] = [];
    for (let i = 0; i < 12; i++) {
      const sign = ([
        "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
        "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces",
      ] as ZodiacSign[])[i]!;
      const start = i * 30;
      const mid = start + 15;

      const t1 = polarToXY(CX, CY, R_ZOD_OUT, start);
      const t2 = polarToXY(CX, CY, R_ZOD_IN,  start);
      const g  = polarToXY(CX, CY, (R_ZOD_OUT + R_ZOD_IN) / 2, mid);

      out.push({
        sign, mid,
        tx1: t1.x, ty1: t1.y,
        tx2: t2.x, ty2: t2.y,
        gx: g.x, gy: g.y,
      });
    }
    return out;
  }, []);

  // --- Render ---
  return (
    <div className={className}>
      <svg
        width={responsive ? "100%" : size}
        height={responsive ? "100%" : size}
        viewBox="0 0 520 520"
        role="img"
        aria-label="Daily Sky Pro Wheel"
      >
        {/* Fascia segni */}
        <circle cx={CX} cy={CY} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringBold} strokeWidth={2.1} />
        <circle cx={CX} cy={CY} r={R_ZOD_IN}  fill="none" stroke="currentColor" strokeOpacity={STROKES.ringMid} strokeWidth={1.2} />

        {/* Ticks settore e glifi dei segni */}
        {zodiacMarks.map((z, i) => (
          <g key={`z-${i}-${uid}`}>
            <line
              x1={z.tx1} y1={z.ty1}
              x2={z.tx2} y2={z.ty2}
              stroke="currentColor"
              strokeOpacity={STROKES.ringMid}
              strokeWidth={1}
            />
            <g transform={`translate(${z.gx}, ${z.gy})`}>
              <SignGlyph sign={z.sign} size={16} />
            </g>
          </g>
        ))}

        {/* Hub aspetti (cerchio interno) */}
        <circle cx={CX} cy={CY} r={R_ASPECT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />

        {/* Aspettogramma: linee tra proiezioni sull'hub */}
        {aspects.map((a) => {
          const A = planets.find(p => p.id === a.a.id)!;
          const B = planets.find(p => p.id === a.b.id)!;
          const isHi = involvedAspects.has(a.id);
          const c = aspectColor(a.type);
          const w = isHi ? 1.35 : 0.95;
          const op = isHi ? STROKES.aspectsHi : STROKES.aspects;

          return (
            <g key={a.id}
               onMouseEnter={() => setHoverAspectId(a.id)}
               onMouseLeave={() => setHoverAspectId(null)}>
              <line x1={A.ax} y1={A.ay} x2={B.ax} y2={B.ay} stroke={c} strokeOpacity={op} strokeWidth={w} />
              <circle cx={A.ax} cy={A.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
              <circle cx={B.ax} cy={B.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
            </g>
          );
        })}

        {/* Tacche per-pianeta (lunghezza fissa) */}
        {planets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke="currentColor"
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Pianeti: nessun bordo di default; halo solo in hover/involved */}
        {planets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const sCol = signColor(p.signZ);
          const haloOpacity = involved ? STROKES.planetHaloHi : STROKES.planetHalo;
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={p.id}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={sCol}
                  strokeOpacity={haloOpacity}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} />
            </g>
          );
        })}
      </svg>
    </div>
  );
}

```


## File: src\components\astro\DailyWheelPro.tsx

```tsx
// FILE: src/components/astro/DailyWheelPro.tsx
"use client";

import React, { useMemo, useState } from "react";
import { Point, ASPECTS } from "../../lib/aspects";
import {
  ZodiacRingPro,
  HousesRingPro,
  PlanetGlyphsPro,
  AspectLinesStraight,
} from "./_parts";

type Props = {
  natalPoints: Point[];
  natalCusps: number[];
  todayPoints: Point[];
  todayCusps: number[];
  aspects: Array<{ t: string; n: string; aspect: keyof typeof ASPECTS; orb: number }>;
  className?: string;
};

export default function DailyWheelPro({
  natalPoints,
  natalCusps,
  todayPoints,
  aspects,
  className,
}: Props) {
  const [hoverKey, setHoverKey] = useState<string | null>(null);

  const hoverFilter = useMemo(() => {
    if (!hoverKey) return null;
    const [, name] = hoverKey.split(":");
    return new Set<string>([`n:${name}`, `t:${name}`]);
  }, [hoverKey]);

  const natalIndex = useMemo(() => {
    const m = new Map<string, number>();
    natalPoints.forEach((p) => m.set(p.name, p.longitude));
    return m;
  }, [natalPoints]);

  const todayIndex = useMemo(() => {
    const m = new Map<string, number>();
    todayPoints.forEach((p) => m.set(p.name, p.longitude));
    return m;
  }, [todayPoints]);

  const width = 720;
  const height = 720;
  const cx = width / 2;
  const cy = height / 2;

  const R_ZODIAC = 320;
  const R_HOUSES_OUT = 292;
  const R_HOUSES_IN = 250;
  const R_PLANETS_NATAL = 238;
  const R_PLANETS_TRANSIT = 200;
  const R_ASPECT_OUT = 170;
  const R_ASPECT_IN = 80;

  return (
    <div className={className ?? ""}>
      <svg width={width} height={height} role="img" aria-label="Daily Pro Wheel">
        <defs>
          <filter id="soft-blur" x="-20%" y="-20%" width="140%" height="140%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="0.6" />
          </filter>
          <clipPath id="clip-aspects">
            <circle cx={cx} cy={cy} r={R_ASPECT_OUT} />
          </clipPath>
        </defs>

        <ZodiacRingPro cx={cx} cy={cy} r={R_ZODIAC} />
        <HousesRingPro cx={cx} cy={cy} rOuter={R_HOUSES_OUT} rInner={R_HOUSES_IN} cusps={natalCusps} />

        <PlanetGlyphsPro
          cx={cx}
          cy={cy}
          r={R_PLANETS_NATAL}
          points={natalPoints}
          ringId="n"
          onHover={setHoverKey}
          hoverFilter={hoverFilter}
        />
        <PlanetGlyphsPro
          cx={cx}
          cy={cy}
          r={R_PLANETS_TRANSIT}
          points={todayPoints}
          ringId="t"
          onHover={setHoverKey}
          hoverFilter={hoverFilter}
        />

        <g clipPath="url(#clip-aspects)">
          <AspectLinesStraight
            cx={cx}
            cy={cy}
            rOuter={R_ASPECT_OUT}
            aspects={aspects}
            natalIndex={natalIndex}
            todayIndex={todayIndex}
            hoverFilter={hoverFilter}
          />
        </g>

        <circle cx={cx} cy={cy} r={R_ASPECT_OUT} fill="none" stroke="currentColor" strokeOpacity="0.1" />
        <circle cx={cx} cy={cy} r={R_ASPECT_IN} fill="none" stroke="currentColor" strokeOpacity="0.08" />
      </svg>
    </div>
  );
}

```


## File: src\components\astro\labeling.ts

```ts
// src/components/astro/labeling.ts

export type LabeledPoint = {
  name: string;          // 'Sun' | 'Venus' | ...
  lon: number;           // 0..360 (gradi eclittici)
  baseR: number;         // raggio base del glifo
};

export type DisplayPoint = LabeledPoint & {
  r: number;             // raggio effettivo per il glifo (dopo anti-overlap)
  level: number;         // livello di "scalino"
};

/**
 * Radial staggering:
 * - ordina per longitudine
 * - se due consecutivi sono più vicini di minSepDeg, alza il successivo di uno "step" radiale
 * - resetta il livello quando la distanza torna sufficiente
 */
export function radialStagger(
  points: LabeledPoint[],
  minSepDeg = 2.0,   // distanza angolare minima tra glifi sullo stesso raggio
  stepPx    = 8,     // incremento radiale per ogni livello
  maxLevels = 3      // prevenire allontanamenti eccessivi
): DisplayPoint[] {
  if (points.length <= 1) return points.map(p => ({ ...p, r: p.baseR, level:0 }));

  const sorted = [...points].sort((a,b)=>a.lon-b.lon);
  let prev = sorted[0];
  let level = 0;
  const out: DisplayPoint[] = [{ ...prev, r: prev.baseR, level }];

  for (let i=1; i<sorted.length; i++){
    const cur = sorted[i];
    const delta = Math.min(
      Math.abs(cur.lon - prev.lon),
      360 - Math.abs(cur.lon - prev.lon)
    );
    if (delta < minSepDeg) {
      level = Math.min(level + 1, maxLevels);
    } else {
      level = 0;
    }
    out.push({ ...cur, r: cur.baseR + level*stepPx, level });
    prev = cur;
  }
  return out;
}

```


## File: src\components\astro\proLayout.ts

```ts
// src/components/astro/proLayout.ts
export type ProRadiiOptions = {
  R?: number;            // raggio esterno totale della ruota
  gap?: number;          // gap uniforme tra le fasce (px) - metti 0 per "a filo"
  ringZodiac?: number;   // spessore fascia zodiaco
  ringUserHouses?: number;
  ringPersonHouses?: number;
  ringAspectogram?: number; // raggio del cerchio dell’aspettogramma (non spessore)
};

export function getProRadii(opts: ProRadiiOptions = {}) {
  const R  = opts.R  ?? 300;
  const G  = opts.gap ?? 0; // 0 => bordi a contatto
  const WZ = opts.ringZodiac ?? 36;
  const WHu = opts.ringUserHouses ?? 28;
  const WHp = opts.ringPersonHouses ?? 28;
  const RA = opts.ringAspectogram ?? 140;

  // Parto dall’esterno e scendo
  const zodiacOuter = R;
  const zodiacInner = zodiacOuter - WZ;

  const userHousesOuter = zodiacInner - G;
  const userHousesInner = userHousesOuter - WHu;

  const personHousesOuter = userHousesInner - G;
  const personHousesInner = personHousesOuter - WHp;

  const aspectogramRadius = Math.min(personHousesInner - G, RA);

  return {
    R,
    zodiac: { outer: zodiacOuter, inner: zodiacInner },
    userHouses: { outer: userHousesOuter, inner: userHousesInner },
    personHouses: { outer: personHousesOuter, inner: personHousesInner },
    aspectogramRadius,
  };
}

```


## File: src\components\astro\SynastryAspectControls.tsx

```tsx
'use client';
import React from 'react';

export type AspectFlags = {
  conjunction: boolean;
  sextile: boolean;
  square: boolean;
  trine: boolean;
  opposition: boolean;
};
export type SynastryAspectControlsProps = {
  value: AspectFlags;
  orbOffset: number;           // in gradi; es ±0..±6
  onChange: (next: { value: AspectFlags; orbOffset: number }) => void;
  className?: string;
};

export default function SynastryAspectControls({
  value,
  orbOffset,
  onChange,
  className,
}: SynastryAspectControlsProps) {
  const set = (k: keyof AspectFlags) => (e: React.ChangeEvent<HTMLInputElement>) =>
    onChange({ value: { ...value, [k]: e.target.checked }, orbOffset });
  const setOrb = (e: React.ChangeEvent<HTMLInputElement>) =>
    onChange({ value, orbOffset: Number(e.target.value) });

  return (
    <div className={className ?? 'rounded-xl border border-slate-200 bg-white p-4 shadow-sm'}>
      <div className="font-semibold mb-2">Impostazioni aspetti (user ↔ person)</div>

      <div className="flex flex-wrap gap-6 mb-3">
        <label className="flex items-center gap-2"><input type="checkbox" checked={value.conjunction} onChange={set('conjunction')} /> Conjunction</label>
        <label className="flex items-center gap-2"><input type="checkbox" checked={value.sextile} onChange={set('sextile')} /> Sextile</label>
        <label className="flex items-center gap-2"><input type="checkbox" checked={value.square} onChange={set('square')} /> Square</label>
        <label className="flex items-center gap-2"><input type="checkbox" checked={value.trine} onChange={set('trine')} /> Trine</label>
        <label className="flex items-center gap-2"><input type="checkbox" checked={value.opposition} onChange={set('opposition')} /> Opposition</label>
      </div>

      <div className="mb-1 text-sm text-slate-700">
        Orb globale (± gradi): <b>{orbOffset > 0 ? `+${orbOffset}°` : `${orbOffset}°`}</b>
      </div>
      <input
        type="range"
        min={-6} max={+6} step={1}
        value={orbOffset}
        onChange={setOrb}
        className="w-full"
        aria-label="Orb globale"
      />
      <div className="mt-1 text-xs text-slate-500">
        Applica un offset agli orbi base (conj 8°, sext 4°, sq 6°, tr 6°, opp 8°).
      </div>
    </div>
  );
}

```


## File: src\components\astro\SynastryWheelPro.tsx

```tsx
'use client';

import React, { useCallback, useMemo, useState } from 'react';
import { polarToXY } from '@/lib/graphics/polar';
import {
  planetChar,
  signChar,
  signColor,
  aspectColor,
  type PlanetName,
  type ZodiacSign,
} from '@/lib/graphics/glyphs';

// new utilities
import { getProRadii } from '@/components/astro/proLayout';
import { radialStagger } from '@/components/astro/labeling';

// ---------- Tipi ----------
export type PlanetNameStrict =
  | 'Sun' | 'Moon' | 'Mercury' | 'Venus' | 'Mars'
  | 'Jupiter' | 'Saturn' | 'Uranus' | 'Neptune' | 'Pluto';
export type AngleName = 'ASC' | 'MC';
export type PlanetOrAngle = PlanetNameStrict | AngleName;

export type ChartPoint = {
  name: PlanetOrAngle;
  lon: number;           // 0..360
  retro?: boolean;
  sign?: string | null;
  house?: number | null;
};

export type SAspectType = 'conjunction' | 'sextile' | 'square' | 'trine' | 'opposition';
export type SAspect = {
  a: { owner: 'user' | 'person'; name: PlanetOrAngle };
  b: { owner: 'user' | 'person'; name: PlanetOrAngle };
  aspect: SAspectType;
  exact?: boolean;
  applying?: boolean;
  score?: number;
};

type Axes = { asc: number; mc: number };
type PtWithTheta = ChartPoint & { theta: number };

export type SynastryWheelProProps = {
  user:   { points: ChartPoint[]; houses?: number[]; axes?: Axes };
  person: { points: ChartPoint[]; houses?: number[]; axes?: Axes };
  aspects?: SAspect[];
  size?: number;
  responsive?: boolean;
  className?: string;
  zodiacPhaseDeg?: number; // offset solo per la fascia zodiacale (default 0). Metti 180 per "ribaltarla".
  tickSize?: number; /** lunghezza delle tacche che indicano dove cade un pianeta (px) */
  userGlyphOffset?: number;   // px, positivo = verso il centro
  personGlyphOffset?: number; // px, positivo = verso il centro
  radiiOverrides?: Partial<Parameters<typeof getProRadii>[0]>; /** controllo fine dei raggi (opzionale) */
};

// ---------- Utility ----------
const norm360 = (d: number) => ((d % 360) + 360) % 360;
const pKey = (owner: 'user'|'person', name: PlanetOrAngle) => `${owner}:${name}`;
// micro-offset per centrare otticamente glifo e cerchio hover
const GLYPH_DX = 0;     // se vedi un lieve disallineamento orizzontale, regola di ±0.5
const GLYPH_DY = 0.5;   // 0.5–1px spesso basta per la Luna


// ---------- Component ----------
export default function SynastryWheelPro({
  user,
  person,
  aspects = [],
  size = 560,
  responsive = true,
  className,
  tickSize = 12,                 // <— parametrico
  radiiOverrides,
  zodiacPhaseDeg = 180,
  userGlyphOffset = 6,        // prova 6–10 px
  personGlyphOffset = 0,
}: SynastryWheelProProps) {

  // colori e grid come prima
  const COLOR_USER = '#1d4ed8';    // blu
  const COLOR_PERSON = '#f59e0b';  // arancione
  const GRID = '#6b7280';
  const GRID_MID = '#9ca3af';
  const GRID_LIGHT = '#e5e7eb';
  const TEXT = '#111827';

  // Canvas
  const r = size / 2;
  const CX = r, CY = r;

  // Geometrie centralizzate: niente fessure (gap: 0)
  const radii = useMemo(() => getProRadii({
    R: r * 0.94,          // manteniamo proporzioni simili al tuo originale
    gap: 0,               // 0 => fasce a filo
    ringZodiac: 40,
    ringUserHouses: 36,
    ringPersonHouses: 36,
    ringAspectogram: r * 0.48, // hub aspetti
    ...radiiOverrides,
  }), [r, radiiOverrides]);

  // derivati comodi come prima
  const R_ZOD_OUT = radii.zodiac.outer;
  const R_ZOD_IN  = radii.zodiac.inner;

  const R_USER_OUT   = radii.userHouses.outer;
  const R_USER_IN    = radii.userHouses.inner;

  const R_PERSON_OUT = radii.personHouses.outer;
  const R_PERSON_IN  = radii.personHouses.inner;

  const R_ASPECT     = radii.aspectogramRadius;
  const R_CENTER     = R_ASPECT * 0.77; // simile al tuo

  // Rotazione: ASC utente a sinistra (ore 9)
  const rot = useMemo(() => norm360(270 - (user.axes?.asc ?? 180)), [user.axes?.asc]);
  const applyRot = useCallback((deg: number) => norm360(deg + rot), [rot]);

  // Pianeti con theta ruotato
  const userPts = useMemo<PtWithTheta[]>(
    () => user.points.map(p => ({ ...p, theta: applyRot(norm360(p.lon)) })),
    [user.points, applyRot]
  );
  const personPts = useMemo<PtWithTheta[]>(
    () => person.points.map(p => ({ ...p, theta: applyRot(norm360(p.lon)) })),
    [person.points, applyRot]
  );

  // Hover state
    const [hover, setHover] = useState<{ kind:'planet'|'aspect'; key: string } | null>(null);
  // quando si passa su una linea di aspetto, evidenzia i due pianeti coinvolti
  const highlightedByAspect = useMemo<Set<string>>(() => {
    if (!hover || hover.kind !== 'aspect') return new Set();
    const idx = Number(hover.key);
    const a = aspects?.[idx];
    if (!a) return new Set();
    return new Set([ pKey(a.a.owner, a.a.name), pKey(a.b.owner, a.b.name) ]);
  }, [hover, aspects]);

    const highlightedByPlanet = useMemo<Set<string>>(() => {
    if (!hover || hover.kind !== 'planet') return new Set();
    const k = hover.key; // es. "user:Sun"
    const set = new Set<string>([k]); // sempre illuminiamo anche il pianeta stesso
    for (const a of (aspects ?? [])) {
      const aKey = pKey(a.a.owner, a.a.name);
      const bKey = pKey(a.b.owner, a.b.name);
      if (aKey === k) set.add(bKey);
      if (bKey === k) set.add(aKey);
    }
    return set;
  }, [hover, aspects]);

  // Unione dei due set: se sono su una linea oppure su un pianeta
  const highlighted = useMemo(() => {
    const s = new Set<string>(highlightedByAspect);
    for (const k of highlightedByPlanet) s.add(k);
    return s;
  }, [highlightedByAspect, highlightedByPlanet]);


  // ---------- Labeling anti-overlap (radial staggering) ----------
  const userDisp = useMemo(() => {
    // baseR: centro dell'anello user
    const baseR = (R_USER_OUT + R_USER_IN) / 2  - userGlyphOffset;  // <-- offset
    return radialStagger(
      userPts.map(p => ({ name: p.name, lon: p.theta, baseR })), // NB: lon = theta (ruotato)
      2.0,  // min distanza angolare (°) per salire di livello
      8,    // incremento raggio per livello
      3     // max livelli
    );
  }, [R_USER_OUT, R_USER_IN, userGlyphOffset, userPts]);

  const personDisp = useMemo(() => {
    const baseR = (R_PERSON_OUT + R_PERSON_IN) / 2  - personGlyphOffset;  // <-- offset
    return radialStagger(
      personPts.map(p => ({ name: p.name, lon: p.theta, baseR })),
      2.7, 8, 5
    );
  }, [R_PERSON_OUT, R_PERSON_IN, personGlyphOffset, personPts]);

  // ---------- Render helpers ----------
  const SignGlyph = ({ sign, sizePx }: { sign: ZodiacSign; sizePx: number }) => (
    <text
      x={0} y={0} fontSize={sizePx}
      textAnchor="middle" dominantBaseline="middle"
      fill={signColor(sign)}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {signChar(sign)}
    </text>
  );

  function drawZodiac() {
    const applyRotZ = (deg: number) => applyRot(norm360(deg + zodiacPhaseDeg));

    const nodes: React.ReactNode[] = [];
    for (let i = 0; i < 12; i++) {
      const sign = ([
        'Aries','Taurus','Gemini','Cancer','Leo','Virgo',
        'Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces',
      ] as ZodiacSign[])[i]!;

      const start = applyRotZ(i * 30);           // <-- usa applyRotZ
      const mid   = applyRotZ(i * 30 + 15);      // <-- usa applyRotZ
      const t1 = polarToXY(CX, CY, R_ZOD_OUT, start);
      const t2 = polarToXY(CX, CY, R_ZOD_IN,  start);
      const g  = polarToXY(CX, CY, (R_ZOD_OUT + R_ZOD_IN) / 2, mid);

      nodes.push(
        <g key={`z-${i}`}>
          <line x1={t1.x} y1={t1.y} x2={t2.x} y2={t2.y} stroke={GRID} strokeOpacity={0.45} strokeWidth={1}/>
          <g transform={`translate(${g.x},${g.y})`}>
            <SignGlyph sign={sign} sizePx={16} />
          </g>
        </g>
      );
    }
    return (
      <g>
        <circle cx={CX} cy={CY} r={R_ZOD_OUT} fill="none" stroke={TEXT} strokeOpacity={0.65} strokeWidth={2}/>
        <circle cx={CX} cy={CY} r={R_ZOD_IN}  fill="none" stroke={GRID} strokeOpacity={0.5}/>
        {nodes}
      </g>
    );
  }


  function drawHouseBand(cusps: number[] | undefined, color: string, rOuter: number, rInner: number, putNumbersInside: boolean) {
    if (!cusps || cusps.length !== 12) return null;

    const ticks: React.ReactNode[] = [];
    const labels: React.ReactNode[] = [];
    const rMid = (rOuter + rInner) / 2;

    for (let i = 0; i < 12; i++) {
      const v = cusps[i]!;
      const next = cusps[(i + 1) % 12]!;
      const a = applyRot(v);
      const pOut = polarToXY(CX, CY, rOuter, a);
      const pIn  = polarToXY(CX, CY, rInner, a);

      ticks.push(
        <line key={`tick-${color}-${i}`} x1={pOut.x} y1={pOut.y} x2={pIn.x} y2={pIn.y} stroke={color} strokeWidth={1.35} strokeOpacity={0.95} />
      );

      const arc = (next - v + 360) % 360;
      const mid = applyRot(v + arc / 2);
      const labelR = putNumbersInside ? rMid - 10 : rMid + 10;
      const lp = polarToXY(CX, CY, labelR, mid);
      labels.push(
        <text key={`h-${color}-${i}`} x={lp.x} y={lp.y} fontSize={10} textAnchor="middle" dominantBaseline="middle" fill={color} opacity={0.95}>
          {i + 1}
        </text>
      );
    }

    return (
      <g>
        {/* bordi a filo: nessun offset oltre rOuter/rInner */}
        <circle cx={CX} cy={CY} r={rOuter} fill="none" stroke={GRID_MID} />
        <circle cx={CX} cy={CY} r={rInner} fill="none" stroke={GRID_MID} />
        {ticks}
        {labels}
      </g>
    );
  }

 function drawAxes(ax: Axes | undefined, color: string, flipMC = true) {
  if (!ax) return null;

  // ASC resta invariato
  const asc = applyRot(ax.asc);

  // MC: se flipMC === true lo ribaltiamo di 180° (MC va in alto, IC in basso)
  const mcRaw = flipMC ? norm360(ax.mc + 180) : ax.mc;
  const mc = applyRot(mcRaw);

  const A1 = polarToXY(CX, CY, R_ZOD_OUT + 6, asc);
  const A2 = polarToXY(CX, CY, R_ZOD_IN - 6, asc);
  const M1 = polarToXY(CX, CY, R_ZOD_OUT + 6, mc);
  const M2 = polarToXY(CX, CY, R_ZOD_IN - 6, mc);

  const AcLab = polarToXY(CX, CY, R_ZOD_OUT + 12, asc);
  const McLab = polarToXY(CX, CY, R_ZOD_OUT + 12, mc);

  return (
    <g>
      <line x1={A1.x} y1={A1.y} x2={A2.x} y2={A2.y} stroke={color} strokeWidth={1.2} />
      <line x1={M1.x} y1={M1.y} x2={M2.x} y2={M2.y} stroke={color} strokeWidth={1.2} />
      <text x={AcLab.x} y={AcLab.y} fontSize={11} fill={color} textAnchor="middle" dominantBaseline="middle" style={{ fontWeight: 600 }}>AC</text>
      <text x={McLab.x} y={McLab.y} fontSize={11} fill={color} textAnchor="middle" dominantBaseline="middle" style={{ fontWeight: 600 }}>MC</text>
    </g>
  );
}


  // Tacche dei pianeti: ora parametrizzate da tickSize
function drawPlanetTicksLabeled(
  pts: PtWithTheta[],              // deve contenere name + theta
  owner: 'user' | 'person',
  color: string,
  hiSet: Set<string>,              // set di chiavi evidenziate es. "user:Sun"
  baseTick = tickSize              // usa la prop già introdotta
) {
  const nodes: React.ReactNode[] = [];
  for (let i = 0; i < pts.length; i++) {
    const p = pts[i]!;
    const key = `${owner}:${p.name}`;
    const th  = p.theta;
    const a   = polarToXY(CX, CY, R_ZOD_IN, th);
    const len = hiSet.has(key) ? baseTick + 4 : baseTick; // tacca più lunga se evidenziata
    const w   = hiSet.has(key) ? 2 : 1;                   // e più spessa
    const b   = polarToXY(CX, CY, R_ZOD_IN - len, th);
    nodes.push(
      <line
        key={`pt-${owner}-${i}`}
        x1={a.x} y1={a.y} x2={b.x} y2={b.y}
        stroke={color}
        strokeWidth={w}
        strokeOpacity={hiSet.has(key) ? 0.95 : 0.55}
      />
    );
  }
  return <g>{nodes}</g>;
}


  // Disegna glifi usando il raggio “staggered” ma lascia le tacche al raggio base
  function drawPlanets(
    disp: ReturnType<typeof radialStagger>,
    color: string,
    owner: 'user' | 'person',
    hiSet: Set<string>
  ) {
    return (
      <g>
        {disp.map((p) => {
          const pos = polarToXY(CX, CY, p.r, p.lon);
          const key = `${owner}:${p.name}`;
          const isActive =
            (hover?.kind === 'planet' && hover.key === key) || // pianeta sotto il mouse
            hiSet.has(key);                                     // pianeti collegati
          return (
            <g key={key}
              transform={`translate(${pos.x},${pos.y})`}
              onMouseEnter={() => setHover({ kind:'planet', key })}
              onMouseLeave={() => setHover(null)}
              style={{ cursor: 'pointer' }}>
              {isActive && <circle cx={GLYPH_DX} cy={GLYPH_DY} r={12} fill="none" stroke={color} strokeWidth={1.5} />}
              <text x={GLYPH_DX}
                y={GLYPH_DY}
                fontSize={16}
                textAnchor="middle"
                dominantBaseline="middle"
                fill={color}
                fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
                aria-label={p.name}>{planetChar(p.name as PlanetName)}</text>
            </g>
          );
        })}
      </g>
    );
  }



  function drawAspects(list: SAspect[]) {
    if (!list || list.length === 0) return null;

    // Mappa nome -> theta per lookup veloce (usiamo i pts originali con theta)
    const mapUser = new Map<PlanetOrAngle, number>(userPts.map(p => [p.name, p.theta]));
    const mapPerson = new Map<PlanetOrAngle, number>(personPts.map(p => [p.name, p.theta]));

    return (
      <g>
        <circle cx={CX} cy={CY} r={R_ASPECT} fill="none" stroke={GRID_MID} />
        <circle cx={CX} cy={CY} r={R_CENTER} fill="none" stroke={GRID_LIGHT} />
        {list.map((a, idx) => {
          const thA = (a.a.owner === 'user' ? mapUser.get(a.a.name) : mapPerson.get(a.a.name));
          const thB = (a.b.owner === 'user' ? mapUser.get(a.b.name) : mapPerson.get(a.b.name));
          if (thA == null || thB == null) return null;
          const A = polarToXY(CX, CY, R_ASPECT, thA);
          const B = polarToXY(CX, CY, R_ASPECT, thB);
          const c = aspectColor(a.aspect);
          const isHi = (hover?.kind === 'aspect' && hover.key === `${idx}`) ||
                       (hover?.kind === 'planet' && (
                         hover.key === `${a.a.owner}:${a.a.name}` || hover.key === `${a.b.owner}:${a.b.name}`
                       ));
          return (
            <g key={idx}
               onMouseEnter={() => setHover({ kind:'aspect', key: String(idx) })}
               onMouseLeave={() => setHover(null)}
               style={{ cursor:'pointer' }}>
              <line x1={A.x} y1={A.y} x2={B.x} y2={B.y}
                    stroke={c} strokeWidth={isHi ? 1.6 : 1}
                    strokeOpacity={isHi ? 1 : 0.75}/>
              <circle cx={A.x} cy={A.y} r={isHi ? 2.4 : 1.7} fill={c} fillOpacity={isHi ? 1 : 0.8}/>
              <circle cx={B.x} cy={B.y} r={isHi ? 2.4 : 1.7} fill={c} fillOpacity={isHi ? 1 : 0.8}/>
            </g>
          );
        })}
      </g>
    );
  }

  // ---------- Axes (derivati da cuspidi I e X) ----------
  const axesUser: Axes | undefined = useMemo(() => {
    const a = user.houses?.[0], m = user.houses?.[9];
    return (typeof a === 'number' && typeof m === 'number') ? { asc: a, mc: m } : undefined;
  }, [user.houses]);
  const axesPerson: Axes | undefined = useMemo(() => {
    const a = person.houses?.[0], m = person.houses?.[9];
    return (typeof a === 'number' && typeof m === 'number') ? { asc: a, mc: m } : undefined;
  }, [person.houses]);

  return (
    <div className={className}>
      <svg viewBox={`0 0 ${size} ${size}`} className={responsive ? 'h-auto w-full' : undefined} role="img" aria-label="Synastry Pro Wheel">
        {/* sfondo leggero */}
        <circle cx={CX} cy={CY} r={r-1} fill="#f8fafc" stroke="#e5e7eb" />

        {/* fascia segni */}
        {drawZodiac()}

        {/* case utente (anello più esterno) */}
        {drawHouseBand(user.houses, COLOR_USER, R_USER_OUT, R_USER_IN, false)}

        {/* case persona (anello interno) */}
        {drawHouseBand(person.houses, COLOR_PERSON, R_PERSON_OUT, R_PERSON_IN, true)}

        {/* assi */}
        {drawAxes(axesUser, COLOR_USER, true)}
        {drawAxes(axesPerson, COLOR_PERSON, true)}

        {/* tacche verticali per ogni pianeta sotto la fascia segni (dimensione configurabile) */}
        {/* tacche verticali sotto la fascia segni */}
        {drawPlanetTicksLabeled(userPts, 'user', COLOR_USER, highlighted)}
        {drawPlanetTicksLabeled(personPts, 'person', COLOR_PERSON, highlighted)}

        {/* aspetti al centro */}
        {drawAspects(aspects)}

        {/* pianeti (anti-overlap radiale) */}
        {drawPlanets(userDisp, COLOR_USER, 'user', highlighted)}
        {drawPlanets(personDisp, COLOR_PERSON, 'person', highlighted)}

        {/* legenda */}
        <g>
          <circle cx={16} cy={size-24} r={5} fill={COLOR_USER} />
          <text x={28} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>User</text>
          <circle cx={76} cy={size-24} r={5} fill={COLOR_PERSON} />
          <text x={88} y={size-24} fontSize={11} dominantBaseline="middle" fill={TEXT}>Person</text>
        </g>
      </svg>
    </div>
  );
}

```


## File: src\components\astro\TransitsWheelPro.tsx

```tsx
// FILE: src/components/astro/TransitsWheelPro.tsx
"use client";

import React, { useMemo, useState, useId } from "react";
import { polarToXY } from "@/lib/graphics/polar";
import {
  planetChar,
  signChar,
  signColor,
  aspectColor,
  type PlanetName,
  type ZodiacSign,
} from "@/lib/graphics/glyphs";

// -------------------------------
// Tipi condivisi
// -------------------------------

export type ProPoint = {
  id: string;      // "Sun" | ...
  name: string;
  lon: number;     // [0..360)
  retro?: boolean;
  sign?: string | null;
};

export type AspectType = "conjunction" | "sextile" | "square" | "trine" | "opposition";

export type InterAspect = {
  id: string;
  a: ProPoint;
  b: ProPoint;
  type: AspectType;
  exactAngle: number; // 0,60,90,120,180
  delta: number;      // distanza dall'esatto
  strength: number;   // 0..1
};

// -------------------------------
// Stilistica & Costanti
// -------------------------------

const STROKES = {
  ringThin: 0.22,
  ringMid: 0.28,
  ringBold: 0.9,
  aspects: 0.35,
  aspectsHi: 1.0,
  planetHalo: 0.35,
  planetHaloHi: 1.0,
};

const ASPECTS_MAP: Record<AspectType, number> = {
  conjunction: 0,
  sextile: 60,
  square: 90,
  trine: 120,
  opposition: 180,
};

// Orbi base
const ORBS_BASE: Record<AspectType, number> = {
  conjunction: 8,
  sextile: 4,
  square: 6,
  trine: 6,
  opposition: 8,
};

// Colori serie
const TRANSIT_GLYPH_COLOR = "#ea580c";   // orange-600
const NATAL_GLYPH_COLOR   = "#0284c7";   // sky-600
const TRANSIT_TICK_COLOR  = TRANSIT_GLYPH_COLOR;
const NATAL_TICK_COLOR    = NATAL_GLYPH_COLOR;

// Punti non planetari da escludere dall’anello dei pianeti (failsafe)
const BLOCKED_POINTS = new Set([
  "ASC","AC","Asc","Ascendant","MC","Midheaven","IC","DSC","DC","Desc","Descendant","Vertex","Lilith","Fortuna","?"
]);

// -------------------------------
// Utility
// -------------------------------

function norm360(d: number) {
  return ((d % 360) + 360) % 360;
}

function angularDistance(a: number, b: number): number {
  let d = Math.abs(a - b) % 360;
  if (d > 180) d = 360 - d;
  return d;
}

function midAngle(a: number, b: number) {
  const A = norm360(a);
  const B = norm360(b);
  const delta = ((B - A + 360) % 360);
  return norm360(A + delta / 2);
}

function signFromLongitude(longitude: number): ZodiacSign {
  const idx = Math.floor(norm360(longitude) / 30);
  const signs: ZodiacSign[] = [
    "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
    "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"
  ];
  return signs[idx]!;
}

function PlanetGlyph({ name, size, fill = "currentColor" }: { name: string; size: number; fill?: string }) {
  const g = planetChar(name as PlanetName) ?? "•";
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={name}
      fill={fill}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

function SignGlyph({ sign, size }: { sign: ZodiacSign; size: number }) {
  const g = signChar(sign);
  const c = signColor(sign);
  return (
    <text
      x={0}
      y={0}
      fontSize={size}
      textAnchor="middle"
      dominantBaseline="middle"
      aria-label={sign}
      fill={c}
      fontFamily='"Noto Sans Symbols 2","Segoe UI Symbol","Apple Symbols","DejaVu Sans",sans-serif'
    >
      {g}
    </text>
  );
}

// -------------------------------
// Props
// -------------------------------

export type TransitsWheelProProps = {
  today: ProPoint[];
  natal: ProPoint[];
  /** 12 cuspidi (gradi eclittici) del tema natale */
  houseCusps?: number[];
  enabledAspects?: Partial<Record<AspectType, boolean>>;
  orbOffsetDeg?: number;
  size?: number;
  className?: string;
  responsive?: boolean;
};

// -------------------------------
// Component
// -------------------------------

const CX = 260;
const CY = 260;

export default function TransitsWheelPro({
  today,
  natal,
  houseCusps,
  enabledAspects,
  orbOffsetDeg = 0,
  size = 520,
  className,
  responsive = true,
}: TransitsWheelProProps) {
  const uid = useId();

  // ===== Geometrie =====
  const R_ZOD_OUT = 252;
  const R_ZOD_IN  = 228;

  const R_NATAL   = 214;   // anello NATAL (puoi regolare)
  const R_TRANSIT = 200;   // anello TRANSITI (puoi regolare)

  // Hub aspetti + fascia numeri case
  const R_ASPECT  = 148;   // inner border fascia numeri + punto di ancoraggio aspetti
  const HOUSE_NUM_BAND_W = 20;
  const R_HOUSE_NUM_IN   = R_ASPECT;
  const R_HOUSE_NUM_OUT  = R_ASPECT + HOUSE_NUM_BAND_W;
  const R_HOUSE_NUM_MID  = (R_HOUSE_NUM_IN + R_HOUSE_NUM_OUT) / 2;
  const HOUSE_NUM_FONT   = 11;
  const HOUSE_NUM_TICK_W = 1.2;

  // Tacche verso i pianeti
  const PLANET_TICK_LEN = 18;
  const PLANET_TICK_OPACITY = 0.5;
  const PLANET_TICK_WIDTH = 1.2;

  // === Nuova fascia assi (AC/IC/DC/MC) esterna alla zodiac band ===
  const AXIS_LABEL_RADIUS   = R_ZOD_OUT + 10; // raggio su cui posare le label (fuori dalla fascia segni)
  const AXIS_TICK_OUT_LEN   = 8;              // lunghezza tacca esterna
  const AXIS_LABEL_FONT     = 11.5;
  const AXIS_COLOR          = "#111827";      // quasi nero

  // ===== Stato hover =====
  const [hoverPlanetId, setHoverPlanetId] = useState<string | null>(null);
  const [hoverAspectId, setHoverAspectId] = useState<string | null>(null);

  // ===== Filtra eventuali punti non planetari (ASC/MC...) =====
  const natalFiltered = useMemo(
    () => natal.filter((p) => !BLOCKED_POINTS.has(p.name)),
    [natal]
  );

  // ===== Pianeti su anelli + proiezione su hub =====
  const natalPlanets = useMemo(() => {
    return natalFiltered.map((p) => {
      const theta = norm360(p.lon);
      const posNat = polarToXY(CX, CY, R_NATAL, theta);
      const posAsp = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return { ...p, theta, x: posNat.x, y: posNat.y, ax: posAsp.x, ay: posAsp.y, signZ: s, band: "natal" as const };
    });
  }, [natalFiltered]);

  const transitPlanets = useMemo(() => {
    return today.map((p) => {
      const theta = norm360(p.lon);
      const posTr = polarToXY(CX, CY, R_TRANSIT, theta);
      const posAsp = polarToXY(CX, CY, R_ASPECT, theta);
      const s = signFromLongitude(p.lon);
      return { ...p, theta, x: posTr.x, y: posTr.y, ax: posAsp.x, ay: posAsp.y, signZ: s, band: "transit" as const };
    });
  }, [today]);

  // ===== Abilitazioni & Orbi =====
  const enabled: Record<AspectType, boolean> = useMemo(() => {
    const allTrue: Record<AspectType, boolean> = {
      conjunction: true, sextile: true, square: true, trine: true, opposition: true,
    };
    return { ...allTrue, ...(enabledAspects ?? {}) };
  }, [enabledAspects]);

  const ORBS: Record<AspectType, number> = useMemo(() => {
    const clamp = (v: number) => Math.max(0, v);
    return {
      conjunction: clamp(ORBS_BASE.conjunction + orbOffsetDeg),
      sextile:     clamp(ORBS_BASE.sextile     + orbOffsetDeg),
      square:      clamp(ORBS_BASE.square      + orbOffsetDeg),
      trine:       clamp(ORBS_BASE.trine       + orbOffsetDeg),
      opposition:  clamp(ORBS_BASE.opposition  + orbOffsetDeg),
    };
  }, [orbOffsetDeg]);

  // ===== Aspetti SOLO natal ↔ transit =====
  type BestMatch = { t: AspectType; exact: number; delta: number; strength: number };
  const aspects = useMemo<InterAspect[]>(() => {
    const out: InterAspect[] = [];
    for (const a of natalFiltered) {
      for (const b of today) {
        const d = angularDistance(a.lon, b.lon);
        let best: BestMatch | undefined;
        for (const t of Object.keys(ASPECTS_MAP) as AspectType[]) {
          if (!enabled[t]) continue;
          const exact = ASPECTS_MAP[t];
          const orb = ORBS[t];
          const delta = Math.abs(d - exact);
          if (delta <= orb) {
            const strength = orb === 0 ? 0 : 1 - delta / orb;
            if (!best || delta < best.delta) best = { t, exact, delta, strength };
          }
        }
        if (best) {
          out.push({
            id: `${a.id}-${b.id}-${best.t}`,
            a, b,
            type: best.t,
            exactAngle: best.exact,
            delta: best.delta,
            strength: best.strength,
          });
        }
      }
    }
    return out;
  }, [natalFiltered, today, enabled, ORBS]);

  // ===== Hover sets =====
  const involvedAspects = useMemo(() => {
    if (hoverPlanetId) return new Set(aspects.filter(x => x.a.id === hoverPlanetId || x.b.id === hoverPlanetId).map(x => x.id));
    if (hoverAspectId) return new Set([hoverAspectId]);
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  const involvedPlanets = useMemo(() => {
    if (hoverPlanetId) {
      const ids = aspects
        .filter(x => x.a.id === hoverPlanetId || x.b.id === hoverPlanetId)
        .flatMap(x => [x.a.id, x.b.id]);
      return new Set<string>([hoverPlanetId, ...ids]);
    }
    if (hoverAspectId) {
      const a = aspects.find(x => x.id === hoverAspectId);
      if (a) return new Set<string>([a.a.id, a.b.id]);
    }
    return new Set<string>();
  }, [hoverPlanetId, hoverAspectId, aspects]);

  // ===== Zodiac band (ticks + glifi) =====
  const zodiacMarks = useMemo(() => {
    const out: {
      sign: ZodiacSign; mid: number;
      tx1: number; ty1: number; tx2: number; ty2: number;
      gx: number; gy: number;
    }[] = [];
    for (let i = 0; i < 12; i++) {
      const sign = ([
        "Aries","Taurus","Gemini","Cancer","Leo","Virgo",
        "Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces",
      ] as ZodiacSign[])[i]!;
      const start = i * 30;
      const mid = start + 15;

      const t1 = polarToXY(CX, CY, R_ZOD_OUT, start);
      const t2 = polarToXY(CX, CY, R_ZOD_IN,  start);
      const g  = polarToXY(CX, CY, (R_ZOD_OUT + R_ZOD_IN) / 2, mid);

      out.push({
        sign, mid,
        tx1: t1.x, ty1: t1.y,
        tx2: t2.x, ty2: t2.y,
        gx: g.x, gy: g.y,
      });
    }
    return out;
  }, []);

  // ===== Case natali =====
  const houseLines = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    return houseCusps.slice(0, 12).map((deg, i) => {
      const theta = norm360(deg);
      const { x, y } = polarToXY(CX, CY, R_ZOD_OUT, theta);
      const isAxis = i === 0 || i === 3 || i === 6 || i === 9; // ASC/IC/DSC/MC
      return { i, theta, x, y, isAxis };
    });
  }, [houseCusps]);

  const houseNumbers = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    const cusps = houseCusps.slice(0, 12).map(norm360);
    const out: { n: number; theta: number; x: number; y: number }[] = [];
    for (let i = 0; i < 12; i++) {
      const a = cusps[i]!;
      const b = cusps[(i + 1) % 12]!;
      const m = midAngle(a, b);
      const pos = polarToXY(CX, CY, R_HOUSE_NUM_MID, m);
      out.push({ n: i + 1, theta: m, x: pos.x, y: pos.y });
    }
    return out;
  }, [houseCusps, R_HOUSE_NUM_MID]);

  // ===== Etichette assi (AC/IC/DC/MC) esterne =====
  const axisLabels = useMemo(() => {
    if (!houseCusps || houseCusps.length < 12) return [];
    const cusps = houseCusps.slice(0, 12).map(norm360);
    // Indici convenzionali: 1=ASC, 4=IC, 7=DSC, 10=MC
    const items: { key: "AC"|"IC"|"DC"|"MC"; theta: number; tx1:number;ty1:number;tx2:number;ty2:number; lx:number;ly:number }[] = [];

    const defs: { key: "AC"|"IC"|"DC"|"MC"; idx: number }[] = [
      { key: "AC", idx: 0 },
      { key: "IC", idx: 3 },
      { key: "DC", idx: 6 },
      { key: "MC", idx: 9 },
    ];

    for (const d of defs) {
      const theta = cusps[d.idx]!;
      const tickOuter = polarToXY(CX, CY, R_ZOD_OUT + AXIS_TICK_OUT_LEN, theta);
      const tickInner = polarToXY(CX, CY, R_ZOD_OUT, theta);
      const labelPos  = polarToXY(CX, CY, AXIS_LABEL_RADIUS, theta);
      items.push({
        key: d.key,
        theta,
        tx1: tickInner.x, ty1: tickInner.y,
        tx2: tickOuter.x, ty2: tickOuter.y,
        lx: labelPos.x, ly: labelPos.y,
      });
    }
    return items;
  }, [houseCusps, AXIS_LABEL_RADIUS]);

  // ===== Render =====
  return (
    <div className={className}>
      <svg
        width={responsive ? "100%" : size}
        height={responsive ? "100%" : size}
        viewBox="0 0 520 520"
        role="img"
        aria-label="Transits Pro Wheel"
      >
        {/* Fascia segni */}
        <circle cx={CX} cy={CY} r={R_ZOD_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringBold} strokeWidth={2.1} />
        <circle cx={CX} cy={CY} r={R_ZOD_IN}  fill="none"  stroke="currentColor" strokeOpacity={STROKES.ringMid}  strokeWidth={1.2} />

        {/* Case (linee radiali lunghe) */}
        {houseLines.map(({ i, x, y, isAxis }) => (
          <line
            key={`house-${i}-${uid}`}
            x1={CX}
            y1={CY}
            x2={x}
            y2={y}
            stroke="#111827"
            strokeOpacity={isAxis ? 0.55 : 0.25}
            strokeWidth={isAxis ? 1.15 : 0.9}
          />
        ))}

        {/* Ticks dei 12 settori + glifi dei segni */}
        {zodiacMarks.map((z, i) => (
          <g key={`z-${i}-${uid}`}>
            <line
              x1={z.tx1} y1={z.ty1}
              x2={z.tx2} y2={z.ty2}
              stroke="currentColor"
              strokeOpacity={STROKES.ringMid}
              strokeWidth={1}
            />
            <g transform={`translate(${z.gx}, ${z.gy})`}>
              <SignGlyph sign={z.sign} size={16} />
            </g>
          </g>
        ))}

        {/* ==== Fascia numerica delle case ==== */}
        <circle cx={CX} cy={CY} r={R_HOUSE_NUM_IN} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />
        <circle cx={CX} cy={CY} r={R_HOUSE_NUM_OUT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringMid} strokeWidth={1.0} />
        {houseLines.map(({ i, theta }) => {
          const a = polarToXY(CX, CY, R_HOUSE_NUM_OUT, theta);
          const b = polarToXY(CX, CY, R_HOUSE_NUM_IN,  theta);
          return (
            <line
              key={`hnum-tick-${i}-${uid}`}
              x1={a.x} y1={a.y}
              x2={b.x} y2={b.y}
              stroke="currentColor"
              strokeOpacity={0.45}
              strokeWidth={HOUSE_NUM_TICK_W}
            />
          );
        })}
        {houseNumbers.map((hn) => (
          <text
            key={`hnum-${hn.n}-${uid}`}
            x={hn.x}
            y={hn.y}
            fontSize={HOUSE_NUM_FONT}
            textAnchor="middle"
            dominantBaseline="middle"
            fill="currentColor"
            opacity={0.85}
            aria-label={`House ${hn.n}`}
            style={{ userSelect: "none" }}
          >
            {hn.n}
          </text>
        ))}

        {/* ==== Etichette assi esterne: AC / IC / DC / MC ==== */}
        {axisLabels.map((ax) => (
          <g key={`ax-${ax.key}-${uid}`}>
            {/* tacca che esce dalla fascia zodiacale */}
            <line
              x1={ax.tx1} y1={ax.ty1}
              x2={ax.tx2} y2={ax.ty2}
              stroke={AXIS_COLOR}
              strokeWidth={1.2}
              strokeOpacity={0.9}
            />
            {/* label esterna */}
            <text
              x={ax.lx}
              y={ax.ly}
              fontSize={AXIS_LABEL_FONT}
              textAnchor="middle"
              dominantBaseline="middle"
              fill={AXIS_COLOR}
              style={{ userSelect: "none", fontWeight: 600 }}
            >
              {ax.key}
            </text>
          </g>
        ))}

        {/* ==== Hub aspetti (coincide con inner border fascia numeri) ==== */}
        <circle cx={CX} cy={CY} r={R_ASPECT} fill="none" stroke="currentColor" strokeOpacity={STROKES.ringThin} />

        {/* Aspetti natal ↔ transit */}
        {aspects.map((a) => {
          const A =
            natalPlanets.find(p => p.id === a.a.id) ??
            transitPlanets.find(p => p.id === a.a.id)!;
          const B =
            natalPlanets.find(p => p.id === a.b.id) ??
            transitPlanets.find(p => p.id === a.b.id)!;

          const isHi = involvedAspects.has(a.id);
          const c = aspectColor(a.type);
          const w = isHi ? 1.35 : 0.95;
          const op = isHi ? STROKES.aspectsHi : STROKES.aspects;

          return (
            <g key={a.id}
               onMouseEnter={() => setHoverAspectId(a.id)}
               onMouseLeave={() => setHoverAspectId(null)}>
              <line x1={A.ax} y1={A.ay} x2={B.ax} y2={B.ay} stroke={c} strokeOpacity={op} strokeWidth={w} />
              <circle cx={A.ax} cy={A.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
              <circle cx={B.ax} cy={B.ay} r={isHi ? 2.3 : 1.6} fill={c} fillOpacity={op} />
            </g>
          );
        })}

        {/* Tacche per-pianeta — NATALI (azzurre) */}
        {natalPlanets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-natal-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke={NATAL_TICK_COLOR}
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Tacche per-pianeta — TRANSITI (arancioni) */}
        {transitPlanets.map((p) => {
          const theta = p.theta;
          const tickStart = polarToXY(CX, CY, R_ZOD_IN, theta);
          const tickEnd   = polarToXY(CX, CY, R_ZOD_IN - PLANET_TICK_LEN, theta);
          return (
            <line
              key={`ptick-transit-${p.id}`}
              x1={tickStart.x} y1={tickStart.y}
              x2={tickEnd.x}   y2={tickEnd.y}
              stroke={TRANSIT_TICK_COLOR}
              strokeOpacity={PLANET_TICK_OPACITY}
              strokeWidth={PLANET_TICK_WIDTH}
            />
          );
        })}

        {/* Pianeti NATALI (glifi azzurri) */}
        {natalPlanets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const haloCol = signColor(p.signZ);
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={`nat-${p.id}`}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={haloCol}
                  strokeOpacity={STROKES.planetHaloHi}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} fill={NATAL_GLYPH_COLOR} />
            </g>
          );
        })}

        {/* Pianeti TRANSITI (glifi arancioni) */}
        {transitPlanets.map((p) => {
          const involved = involvedPlanets.has(p.id);
          const haloCol = signColor(p.signZ);
          const glyphSize = involved ? 18 : 16;
          const showHalo = involved || hoverPlanetId === p.id;
          const dimOthers = (hoverPlanetId || hoverAspectId) && !involved;

          return (
            <g
              key={`tr-${p.id}`}
              transform={`translate(${p.x}, ${p.y})`}
              onMouseEnter={() => setHoverPlanetId(p.id)}
              onMouseLeave={() => setHoverPlanetId(null)}
              style={{ cursor: "pointer", opacity: dimOthers ? 0.5 : 1 }}
            >
              {showHalo && (
                <circle
                  cx={0}
                  cy={0}
                  r={13}
                  fill="none"
                  stroke={haloCol}
                  strokeOpacity={STROKES.planetHaloHi}
                  strokeWidth={1.5}
                />
              )}
              <PlanetGlyph name={p.name} size={glyphSize} fill={TRANSIT_GLYPH_COLOR} />
            </g>
          );
        })}
      </svg>
    </div>
  );
}

```
